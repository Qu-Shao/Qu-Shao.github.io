<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>自用 IDEA 插件</title>
      <link href="/2024/0149d53e76.html"/>
      <url>/2024/0149d53e76.html</url>
      
        <content type="html"><![CDATA[<h1 id="自用 IDEA 插件"><a href="# 自用 IDEA 插件" class="headerlink" title="自用 IDEA 插件"></a> 自用 IDEA 插件 </h1><hr><h2 id="Grep-Console"><a href="#Grep-Console" class="headerlink" title="Grep Console"></a>Grep Console</h2><p> 控制台日志自定义输出颜色，可以更好地定位 Bug</p><h2 id="CodeGlancePro"><a href="#CodeGlancePro" class="headerlink" title="CodeGlancePro"></a>CodeGlancePro</h2><p> 代码编辑区缩略图插件，可以快速定位代码 </p><h2 id="RestfulToolkit"><a href="#RestfulToolkit" class="headerlink" title="RestfulToolkit"></a>RestfulToolkit</h2><p> 一套 RESTful 服务开发辅助工具集，可快速生成 API 调用 </p><h2 id="Maven-Helper"><a href="#Maven-Helper" class="headerlink" title="Maven Helper"></a>Maven Helper</h2><p> 依赖冲突分析插件 </p><h2 id="Json-Parser"><a href="#Json-Parser" class="headerlink" title="Json Parser"></a>Json Parser</h2><p>Json 格式化工具 </p><h2 id="Translation"><a href="#Translation" class="headerlink" title="Translation"></a>Translation</h2><p> 翻译工具，需自己配置翻译接口 </p><h2 id="CheckStyle-IDEA"><a href="#CheckStyle-IDEA" class="headerlink" title="CheckStyle-IDEA"></a>CheckStyle-IDEA</h2><p> 代码规范检查 </p><h2 id="Alibaba-Java-Coding-Guidelines"><a href="#Alibaba-Java-Coding-Guidelines" class="headerlink" title="Alibaba Java Coding Guidelines"></a>Alibaba Java Coding Guidelines</h2><p> 阿里巴巴 Java 代码规范检查 </p><h2 id="Key-promoter-X"><a href="#Key-promoter-X" class="headerlink" title="Key promoter X"></a>Key promoter X</h2><p> 快捷键提示工具 </p><h2 id="GsonFormatPlus"><a href="#GsonFormatPlus" class="headerlink" title="GsonFormatPlus"></a>GsonFormatPlus</h2><p>Json 转对象工具，前后端对接比较实用 </p><h2 id="Rainbow-Brackets"><a href="#Rainbow-Brackets" class="headerlink" title="Rainbow Brackets"></a>Rainbow Brackets</h2><p> 彩虹括号插件，代码结构更美观 </p><h2 id="Redis-Helper"><a href="#Redis-Helper" class="headerlink" title="Redis Helper"></a>Redis Helper</h2><p>Redis 助手 </p><h2 id="ASM-Bytecode-Outline"><a href="#ASM-Bytecode-Outline" class="headerlink" title="ASM Bytecode Outline"></a>ASM Bytecode Outline</h2><p> 查看字节码工具 </p><h2 id="HighlightBracketPair"><a href="#HighlightBracketPair" class="headerlink" title="HighlightBracketPair"></a>HighlightBracketPair</h2><p> 高亮 </p><hr>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 插件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Springboot 集成 Elasticsearch——RestHighLevelClient</title>
      <link href="/2023/12d3f80982.html"/>
      <url>/2023/12d3f80982.html</url>
      
        <content type="html"><![CDATA[<h1 id="Springboot 集成 Elasticsearch——RestHighLevelClient"><a href="#Springboot 集成 Elasticsearch——RestHighLevelClient" class="headerlink" title="Springboot 集成 Elasticsearch——RestHighLevelClient"></a>Springboot 集成 Elasticsearch——RestHighLevelClient</h1><hr><h1 id="本次实验 Elasticsearch 版本为 8-11-3（截至 2023-12-28 官方最新版本），实验代码已托管至 github-Files-Springboot 集成 Elasticsearch——RestHighLevelClient-at-main-·-qu-shao-Files-github-com"><a href="# 本次实验 Elasticsearch 版本为 8-11-3（截至 2023-12-28 官方最新版本），实验代码已托管至 github-Files-Springboot 集成 Elasticsearch——RestHighLevelClient-at-main-·-qu-shao-Files-github-com" class="headerlink" title="本次实验 Elasticsearch 版本为 8.11.3（截至 2023.12.28 官方最新版本），实验代码已托管至 github: Files&#x2F;Springboot 集成 Elasticsearch——RestHighLevelClient at main · qu-shao&#x2F;Files (github.com)"></a>本次实验 Elasticsearch 版本为 8.11.3（截至 2023.12.28 官方最新版本），实验代码已托管至 github: <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3F1LXNoYW8vRmlsZXMvdHJlZS9tYWluL1NwcmluZ2Jvb3QlRTklOUIlODYlRTYlODglOTBFbGFzdGljc2VhcmNoJUUyJTgwJTk0JUUyJTgwJTk0UmVzdEhpZ2hMZXZlbENsaWVudA==">Files&#x2F;Springboot 集成 Elasticsearch——RestHighLevelClient at main · qu-shao&#x2F;Files (github.com)<i class="fa fa-external-link-alt"></i></span></h1><h2 id="环境依赖"><a href="# 环境依赖" class="headerlink" title="环境依赖"></a>环境依赖 </h2><p> 项目 pom 文件中添加 elasticsearch 依赖，官方给出的 rest-high-level-client 最后一个版本为 7.17.16，官方文档指出，此版本在 Elasticsearch 8.x 版本上仍然可以使用。（若是 Elasticsearch 7.x 版本则保证依赖和 Elasticsearch 同版本即可）</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.elasticsearch<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>elasticsearch<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>7.17.16<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.elasticsearch.client<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>elasticsearch-rest-high-level-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>7.17.16<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><hr><h2 id="环境变量"><a href="# 环境变量" class="headerlink" title="环境变量"></a>环境变量</h2><p>Elasticsearch 需要配置 URL 和端口，集群下的话还需要配置通信端口，我们推荐将这些参数在环境变量中配置而不是写死在程序中。</p><p>项目 application.yml 文件关于 ES 的配置如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">elasticsearch:</span><br><span class="line">  host: 127.0.0.1</span><br><span class="line">  port: 9200</span><br><span class="line">  index: test</span><br><span class="line">  type: _doc</span><br></pre></td></tr></table></figure><hr><h2 id="创建 RestHighLevelClient 客户端"><a href="# 创建 RestHighLevelClient 客户端" class="headerlink" title="创建 RestHighLevelClient 客户端"></a>创建 RestHighLevelClient 客户端 </h2><p> 一般我们会用 @Configuration 或者 @Component 修饰 ES 配置类并在其中将 RestHighLevelClient 注册为 Bean 对象交由 Spring 容器管理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.demo.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.http.HttpHost;</span><br><span class="line"><span class="keyword">import</span> org.elasticsearch.client.RestClient;</span><br><span class="line"><span class="keyword">import</span> org.elasticsearch.client.RestHighLevelClient;</span><br><span class="line"><span class="keyword">import</span> org.elasticsearch.client.RestHighLevelClientBuilder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Value;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ESConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;elasticsearch.host&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String esHost;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;elasticsearch.port&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> esPort;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RestHighLevelClient <span class="title function_">restClient</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">RestHighLevelClient</span> <span class="variable">restClient</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RestHighLevelClientBuilder</span>(RestClient.builder(<span class="keyword">new</span> <span class="title class_">HttpHost</span>(esHost,</span><br><span class="line">                esPort)).build()).setApiCompatibilityMode(<span class="literal">true</span>).build();</span><br><span class="line">        <span class="keyword">return</span> restClient;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 setApiCompatibilityMode(true)方法是根据官方文档为了使 7.17.16 的客户端能够访问 8.x 的 ES 而添加的额外属性，如果 ES 版本和客户端版本符合的话则不需要添加该属性。</p><hr><p>RestHighLevelClient 的调用逻辑其实和 Restul API 很类似，一般可分为三个步骤。</p><p>第一步，构建请求；第二步，准备请求体数据；第三步，执行请求。其中对于请求体数据的构建，官方提供了三种方式，第一种是直接以 JSON 字符串的形式传入，第二种是以参数列表 HashMap 映射的形式传入，第三种是以建造者模式 XContentBuilder 构建。个人觉得虽然用 JSON 字符串最直观，也最贴合 Restful API，但是从面向对象的角度出发，后两种方式更符合 Java 开发的思想，逐步构建参数对象。本次实验以 HashMap 的使用方式为例，其余调用方式可参考官方文档。</p><h2 id="创建索引"><a href="# 创建索引" class="headerlink" title="创建索引"></a>创建索引</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createIndex</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">CreateIndexRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CreateIndexRequest</span>(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">    request.settings(Settings.builder()</span><br><span class="line">        .put(<span class="string">&quot;index.number_of_shards&quot;</span>, <span class="number">3</span>)</span><br><span class="line">        .put(<span class="string">&quot;index.number_of_replicas&quot;</span>, <span class="number">0</span>)</span><br><span class="line">        .put(<span class="string">&quot;analysis.analyzer&quot;</span>, <span class="string">&quot;ik_smart&quot;</span>)</span><br><span class="line">    );</span><br><span class="line">    Map &lt; String, Object &gt; name = <span class="keyword">new</span> <span class="title class_">HashMap</span> &lt; &gt; ();</span><br><span class="line">    name.put(<span class="string">&quot;type&quot;</span>, <span class="string">&quot;keyword&quot;</span>);</span><br><span class="line">    name.put(<span class="string">&quot;ignore_above&quot;</span>, <span class="number">256</span>);</span><br><span class="line">    Map &lt; String, Object &gt; sex = <span class="keyword">new</span> <span class="title class_">HashMap</span> &lt; &gt; ();</span><br><span class="line">    sex.put(<span class="string">&quot;type&quot;</span>, <span class="string">&quot;integer&quot;</span>);</span><br><span class="line">    sex.put(<span class="string">&quot;index&quot;</span>, <span class="string">&quot;false&quot;</span>);</span><br><span class="line">    Map &lt; String, Object &gt; introduce = <span class="keyword">new</span> <span class="title class_">HashMap</span> &lt; &gt; ();</span><br><span class="line">    introduce.put(<span class="string">&quot;type&quot;</span>, <span class="string">&quot;text&quot;</span>);</span><br><span class="line">    introduce.put(<span class="string">&quot;analyzer&quot;</span>, <span class="string">&quot;ik_max_word&quot;</span>);</span><br><span class="line">    Map &lt; String, Object &gt; birthday = <span class="keyword">new</span> <span class="title class_">HashMap</span> &lt; &gt; ();</span><br><span class="line">    birthday.put(<span class="string">&quot;type&quot;</span>, <span class="string">&quot;date&quot;</span>);</span><br><span class="line">    Map &lt; String, Object &gt; properties = <span class="keyword">new</span> <span class="title class_">HashMap</span> &lt; &gt; ();</span><br><span class="line">    properties.put(<span class="string">&quot;name&quot;</span>, name);</span><br><span class="line">    properties.put(<span class="string">&quot;sex&quot;</span>, sex);</span><br><span class="line">    properties.put(<span class="string">&quot;introduce&quot;</span>, introduce);</span><br><span class="line">    properties.put(<span class="string">&quot;birthday&quot;</span>, birthday);</span><br><span class="line">    Map &lt; String, Object &gt; mapping = <span class="keyword">new</span> <span class="title class_">HashMap</span> &lt; &gt; ();</span><br><span class="line">    mapping.put(<span class="string">&quot;properties&quot;</span>, properties);</span><br><span class="line">    request.mapping(mapping);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">CreateIndexResponse</span> <span class="variable">createIndexResponse</span> <span class="operator">=</span> restHighLevelClient.indices().create(request,</span><br><span class="line">            RequestOptions.DEFAULT);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="创建文档"><a href="# 创建文档" class="headerlink" title="创建文档"></a>创建文档</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createDocument</span><span class="params">()</span> &#123;</span><br><span class="line">    Map &lt; String, Object &gt; jsonMap = <span class="keyword">new</span> <span class="title class_">HashMap</span> &lt; &gt; ();</span><br><span class="line">    jsonMap.put(<span class="string">&quot;name&quot;</span>, <span class="string">&quot; 屈少 &quot;</span>);</span><br><span class="line">    jsonMap.put(<span class="string">&quot;birthday&quot;</span>, <span class="string">&quot;2000-01-01&quot;</span>);</span><br><span class="line">    jsonMap.put(<span class="string">&quot;introduce&quot;</span>, <span class="string">&quot; 他日若遂凌云志，敢笑黄巢不丈夫 &quot;</span>);</span><br><span class="line">    jsonMap.put(<span class="string">&quot;sex&quot;</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="type">IndexRequest</span> <span class="variable">indexRequest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IndexRequest</span>(<span class="string">&quot;test&quot;</span>)</span><br><span class="line">        .id(<span class="string">&quot;001&quot;</span>).source(jsonMap);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">IndexResponse</span> <span class="variable">indexResponse</span> <span class="operator">=</span> restHighLevelClient.index(indexRequest, RequestOptions.DEFAULT);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="更新文档"><a href="# 更新文档" class="headerlink" title="更新文档"></a>更新文档</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateDocument</span><span class="params">()</span> &#123;</span><br><span class="line">    Map &lt; String, Object &gt; jsonMap = <span class="keyword">new</span> <span class="title class_">HashMap</span> &lt; &gt; ();</span><br><span class="line">    jsonMap.put(<span class="string">&quot;introduce&quot;</span>, <span class="string">&quot; 天生我材必有用，千金散尽还复来。&quot;</span>);</span><br><span class="line">    <span class="type">UpdateRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UpdateRequest</span>(<span class="string">&quot;test&quot;</span>, <span class="string">&quot;001&quot;</span>)</span><br><span class="line">        .doc(jsonMap);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">UpdateResponse</span> <span class="variable">updateResponse</span> <span class="operator">=</span> restHighLevelClient.update(</span><br><span class="line">            request, RequestOptions.DEFAULT);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="查询文档"><a href="# 查询文档" class="headerlink" title="查询文档"></a>查询文档 </h2><p>ES 的查询条件十分丰富，具体可以参考官方链接<span class="exturl" data-url="aHR0cHM6Ly93d3cuZWxhc3RpYy5jby9ndWlkZS9lbi9lbGFzdGljc2VhcmNoL2NsaWVudC9qYXZhLXJlc3QvNy4xNy9qYXZhLXJlc3QtaGlnaC1xdWVyeS1idWlsZGVycy5odG1s">https://www.elastic.co/guide/en/elasticsearch/client/java-rest/7.17/java-rest-high-query-builders.html<i class="fa fa-external-link-alt"></i></span><br> 这里仅构造两个查询作为实战案例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># 对应基础篇章中的 match 匹配查询（控制精度）</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">matchQueryDocument</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">SearchRequest</span> <span class="variable">searchRequest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SearchRequest</span>().indices(<span class="string">&quot;test&quot;</span>).types(<span class="string">&quot;_doc&quot;</span>);</span><br><span class="line">    <span class="type">SearchSourceBuilder</span> <span class="variable">searchSourceBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SearchSourceBuilder</span>();</span><br><span class="line">    <span class="type">MatchQueryBuilder</span> <span class="variable">matchQueryBuilder</span> <span class="operator">=</span> QueryBuilders.matchQuery(<span class="string">&quot;introduce&quot;</span>, <span class="string">&quot; 如果天生我材 &quot;</span>).minimumShouldMatch(<span class="string">&quot;50%&quot;</span>);</span><br><span class="line">    searchSourceBuilder.query(matchQueryBuilder);</span><br><span class="line">    searchRequest.source(searchSourceBuilder);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">SearchResponse</span> <span class="variable">searchResponse</span> <span class="operator">=</span> restHighLevelClient.search(searchRequest, RequestOptions.DEFAULT);</span><br><span class="line">        System.out.println(searchResponse.toString());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># 对应基础篇章中的 bool 查询</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">boolQueryDocument</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">SearchRequest</span> <span class="variable">searchRequest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SearchRequest</span>().indices(<span class="string">&quot;test&quot;</span>).types(<span class="string">&quot;_doc&quot;</span>);</span><br><span class="line">    <span class="type">SearchSourceBuilder</span> <span class="variable">searchSourceBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SearchSourceBuilder</span>();</span><br><span class="line">    <span class="type">BoolQueryBuilder</span> <span class="variable">boolQueryBuilder</span> <span class="operator">=</span> QueryBuilders.boolQuery();</span><br><span class="line">    boolQueryBuilder.must(QueryBuilders.termQuery(<span class="string">&quot;name&quot;</span>, <span class="string">&quot; 屈少 &quot;</span>));</span><br><span class="line">    boolQueryBuilder.must(QueryBuilders.rangeQuery(<span class="string">&quot;sex&quot;</span>).gte(<span class="number">1</span>).lte(<span class="number">1</span>));</span><br><span class="line">    boolQueryBuilder.should(QueryBuilders.matchPhraseQuery(<span class="string">&quot;introduce&quot;</span>, <span class="string">&quot; 你真棒 &quot;</span>));</span><br><span class="line">    searchSourceBuilder.query(boolQueryBuilder);</span><br><span class="line">    searchRequest.source(searchSourceBuilder);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">SearchResponse</span> <span class="variable">searchResponse</span> <span class="operator">=</span> restHighLevelClient.search(searchRequest, RequestOptions.DEFAULT);</span><br><span class="line">        System.out.println(searchResponse.toString());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的两个例子我们可以发现，查询语句的构建大同小异，首先需要创建一个 SearchRequest 对象并在其中指定 index 和 type；然后创建一个 SearchSourceBuilder 加载之后的查询条件。这两个步骤是所有查询语句公共的，不同的查询主要体现在查询条件的组装上。根据所需要的查询类型，分别构建对应的”QueryBuilder”，参数以方法调用的形式设置。完成后又是所有查询语句公共的操作——SearchSourceBuilder 加载查询语句，restHighLevelClient 执行 SearchRequest。</p><p>最后简单介绍下查询返回的结果，SearchResponse 中包含了整个查询语句的命中情况，执行效率等，我们可以调用 getHits()方法获取到我们真正所需要的检索数据，再将其转换成字符串或者 Map 进行处理。</p>]]></content>
      
      
      <categories>
          
          <category> Elasticsearch </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Elasticsearch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Elasticsearch 基础</title>
      <link href="/2023/12a8c4ef2d.html"/>
      <url>/2023/12a8c4ef2d.html</url>
      
        <content type="html"><![CDATA[<h1 id="Elasticsearch- 基础"><a href="#Elasticsearch- 基础" class="headerlink" title="Elasticsearch 基础"></a>Elasticsearch 基础</h1><hr><h2 id="基础知识"><a href="# 基础知识" class="headerlink" title="基础知识"></a>基础知识 </h2><p>​Elasticsearch 的思想是<strong> 倒排索引 </strong>，个人理解传统的数据库是文档找单词，你可以很轻松地获取到一篇文档（一般通过文档的唯一标志），进而获取文档中的单词，然而 Elasticsearch 是单词找文档，在 Elasticsearch 中，你可以很轻松地获取到一个单词（通过字符串 Hash 或者维护一张映射表就可以做到，具体 Elasticsearch 底层实现暂未深究，只需要知道在 Elasticsearch 中一个单词相当于 key），进而获取到文档中含有这个单词的所有文档，这就要求在存储数据（一篇文档）的时候先对文档进行分词，再将每一个分词存入到 ES 中，当然，如果每一个分词下都要存储一份文档实体虽然在访问时可以一次访问提高速度，但是会存在大量的冗余，因此这里和数据库中的非聚簇索引类似（不知道是否存在参考），在分词中只存储文档的唯一标志（一般是自动生成的，也可以<strong> 指定 ID</strong>）和一些其他信息，例如该分词在文档中出现的位置、出现的次数等。如果 ES 中已经存在该分词，则直接追加文档的相关信息，否则就新建一个分词结构并存入。本篇文章主要是对 ES 的基础进行学习记录，并未深究其底层实现，如有错误之处，欢迎指正。</p><hr><h2 id="数据类型"><a href="# 数据类型" class="headerlink" title="数据类型"></a>数据类型 </h2><p> 字符串：text(分词)、keyword(不分词)</p><p>数字型：long、integer、short、byte、double、float、half_float、scaled_float</p><p>布尔：boolean</p><p>日期：date</p><p>二进制：binary</p><p>范围类型：integer_range、float_range、long_range、double_range、date_range</p><hr><h2 id="Restful-API"><a href="#Restful-API" class="headerlink" title="Restful API"></a>Restful API</h2><h3 id="1- 查看所有 -cat 命令："><a href="#1- 查看所有 -cat 命令：" class="headerlink" title="1. 查看所有_cat 命令："></a>1. 查看所有_cat 命令：</h3><p>有点类似于 Linux 指令的 help</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET _cat</span><br></pre></td></tr></table></figure><h3 id="2- 查看 ES 的集群状态："><a href="#2- 查看 ES 的集群状态：" class="headerlink" title="2. 查看 ES 的集群状态："></a>2. 查看 ES 的集群状态：</h3><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET _cluster/health?pretty</span><br></pre></td></tr></table></figure><h3 id="3- 查看 ES 索引的信息："><a href="#3- 查看 ES 索引的信息：" class="headerlink" title="3. 查看 ES 索引的信息："></a>3. 查看 ES 索引的信息：</h3><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET _cat/indices?v&amp;pretty</span><br></pre></td></tr></table></figure><h3 id="4- 查看具体某个索引的设置："><a href="#4- 查看具体某个索引的设置：" class="headerlink" title="4. 查看具体某个索引的设置："></a>4. 查看具体某个索引的设置：</h3><p>test 为索引名称</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /test/_settings</span><br></pre></td></tr></table></figure><h3 id="5- 查看具体某个索引的结构："><a href="#5- 查看具体某个索引的结构：" class="headerlink" title="5. 查看具体某个索引的结构："></a>5. 查看具体某个索引的结构：</h3><p>每一个 mappings 下的字段代表了 ES 需要进行处理的字段，类型对应上面的数据类型</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /test/_mappings</span><br></pre></td></tr></table></figure><h3 id="6- 创建索引："><a href="#6- 创建索引：" class="headerlink" title="6. 创建索引："></a>6. 创建索引：</h3><p>以 test 为例</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PUT /test</span><br></pre></td></tr></table></figure><h3 id="7- 创建索引并指定设置："><a href="#7- 创建索引并指定设置：" class="headerlink" title="7. 创建索引并指定设置："></a>7. 创建索引并指定设置：</h3><p>一般需要设置分词器、分片数和副本数，<strong>分片数和分词器 </strong> 在索引创建时设置并且后续 <strong> 无法修改</strong>，副本数后期可以更改</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">PUT /test</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;settings&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;analysis&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;analyzer&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ik_smart&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;number_of_shards&quot;</span><span class="punctuation">:</span> <span class="number">3</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;number_of_replicas&quot;</span><span class="punctuation">:</span> <span class="number">1</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="8- 设置索引映射："><a href="#8- 设置索引映射：" class="headerlink" title="8. 设置索引映射："></a>8. 设置索引映射：</h3><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">PUT /test/_mapping/people</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;properties&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;keyword&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;ignore_above&quot;</span><span class="punctuation">:</span> <span class="number">256</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;sex&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;integer&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;index&quot;</span><span class="punctuation">:</span> <span class="string">&quot;false&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;introduce&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;text&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;analyzer&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ik_max_word&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;birthday&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;date&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>这里需要注意的是，老的 ES 版本当中存在 type 的概念，原意是对标数据库中的 table（index 对标 database），但在后续中发现该层设计其实没有什么实际意义，所以在老版本的 ES 当中需要定义一层 type（即例子中的 people），新版本（7.x 以上）默认 type 为”<strong>_doc</strong>“，因此在处理时不需要添加 type 参数(PUT &#x2F;test&#x2F;_mapping 即可)；同时，我们可以在创建索引时进行 settings 和 mappings，也可以在创建索引后单独修改 mapping，但是部分 mapping 的属性是不允许修改的（比如字段的属性），因此建议在创建索引的时候就设计好 mapping。</p><p>另一方面，ES 也提供了一种 <strong> 动态映射 </strong> 的机制，即指定索引不定义 mappings（索引不存在也可以，会自动创建），直接向其中插入文档，ES 会自动解析传入的文档并建立相应的映射。虽然如此，但还是建议手动创建索引和映射，提高可控性。</p><h3 id="9- 删除索引："><a href="#9- 删除索引：" class="headerlink" title="9. 删除索引："></a>9. 删除索引：</h3><p>删除前请务必确认索引已经存在并且确实是想要删除的</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DELETE /test</span><br></pre></td></tr></table></figure><h3 id="10- 查询 ES 当前所有文档："><a href="#10- 查询 ES 当前所有文档：" class="headerlink" title="10. 查询 ES 当前所有文档："></a>10. 查询 ES 当前所有文档：</h3><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /_search?pretty</span><br></pre></td></tr></table></figure><h3 id="11- 查询分词结果"><a href="#11- 查询分词结果" class="headerlink" title="11. 查询分词结果"></a>11. 查询分词结果</h3><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">POST /_analyze</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;analyzer&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ik_smart&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;text&quot;</span><span class="punctuation">:</span> <span class="string">&quot; 我爱编程 &quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="12- 插入文档"><a href="#12- 插入文档" class="headerlink" title="12. 插入文档"></a>12. 插入文档</h3><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">PUT /test/people/<span class="number">001</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot; 屈少 &quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;sex&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;introduce&quot;</span><span class="punctuation">:</span> <span class="string">&quot; 他日若遂凌云志，敢笑黄巢不丈夫 &quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;birthday&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2000-01-01&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>老版本 ES 在插入文档时需要指定 type，在高版本的 ES 当中将“people”或者其他 type 统一替换为”<strong>_doc</strong>“，例子中的”001”为手动指定的文档 ID，也可以不传，由 ES 自动生成。</p><h3 id="13- 删除文档"><a href="#13- 删除文档" class="headerlink" title="13. 删除文档"></a>13. 删除文档</h3><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DELETE /test/people/<span class="number">001</span></span><br></pre></td></tr></table></figure><h3 id="14- 修改文档"><a href="#14- 修改文档" class="headerlink" title="14. 修改文档"></a>14. 修改文档 </h3><p> 修改文档分为两种方式，一种是按照插入的方式并指定 ID<strong>覆盖 </strong> 原来的数据，此时即使是修改一个属性也需要重新传入整个文档；另一种是修改原来文档中的属性，此时请求方式为 POST，且在外层需要嵌套一层 doc</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">POST /test/people/<span class="number">001</span>/_update</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;doc&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;introduce&quot;</span><span class="punctuation">:</span> <span class="string">&quot; 天生我材必有用，千金散尽还复来。&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>类似的，在新版本中，使用</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">POST /test/_update/<span class="number">001</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;doc&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;introduce&quot;</span><span class="punctuation">:</span> <span class="string">&quot; 天生我材必有用，千金散尽还复来。&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="15- 查询文档"><a href="#15- 查询文档" class="headerlink" title="15. 查询文档"></a>15. 查询文档 </h3><p> 老版本中不指定 type 将在所有的 type 中查询，新版本没有 type 概念无需指定</p><h4 id="根据 ID 查询"><a href="# 根据 ID 查询" class="headerlink" title="根据 ID 查询"></a>根据 ID 查询</h4><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">GET /test/people/_search</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;ids&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;values&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="string">&quot;001&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;002&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;003&quot;</span></span><br><span class="line">      <span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>新版本查询只需要去除”people”(type)即可，之后的查询统一以 <strong> 新版本 ES</strong>为准，老版本可以查询对应 API，使用方法上大同小异。</p><h4 id="match-all- 全部查询"><a href="#match-all- 全部查询" class="headerlink" title="match_all 全部查询"></a>match_all 全部查询</h4><p>match_all 就是查询索引库中所有文档，默认返回 10 条，可以通过指定 size 设置查询条数，也可以自定义排序规则；但由于 ES 的保护机制，单次返回不能超过 10000 条，可以通过配置来改变最大条数或使用滚动查询</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET /test/_search</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;match_all&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;size&quot;</span><span class="punctuation">:</span> <span class="number">100</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h4 id="match- 匹配查询"><a href="#match- 匹配查询" class="headerlink" title="match 匹配查询"></a>match 匹配查询</h4><p>match 查询首先会对输入的检索词进行分词，对文档对应属性也进行分词，如果任一分词匹配则成功</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET /test/_search</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;match&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;introduce&quot;</span><span class="punctuation">:</span> <span class="string">&quot; 天生我材 &quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h4 id="match- 匹配查询（控制精度）"><a href="#match- 匹配查询（控制精度）" class="headerlink" title="match 匹配查询（控制精度）"></a>match 匹配查询（控制精度）</h4><p>对于一般的 match 查询只要匹配一个分词即成功，但是有时候我们希望匹配的结果可以更加精确一点，match 提供了两个参数，operator 和 minimum_should_match。operator 可以为 and 或者 or，minimum_should_match 表示成功匹配下最少的分词数量，相当于“大于等于”的关系，minimum_should_match 可以是 <strong> 整数 </strong> 也可以是 <strong> 百分数 </strong>，百分数是为了满足那些我们无法提前预知输入的检索数据被分词器拆分的单词数量的情况。需要注意的一点是，minimum_should_match 只有在 operator 为<strong>or</strong> 时才生效，这点也很好理解，如果你允许分词之间是“and”的关系，那么隐含的意思就是此时 minimum_should_match 恒为 100%</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">GET /test/_search</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;match&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;introduce&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="string">&quot; 如果天生我材 &quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;minimum_should_match&quot;</span><span class="punctuation">:</span> <span class="string">&quot;50%&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>此时很明显“如果”一词并未出现在文档中，但结果依然命中。通过这种方式，我们可以实现一定程度上精度可控的非完全匹配，这也是在很多情况下比较容易的实现。</p><h4 id="multi-match- 多字段批量查询"><a href="#multi-match- 多字段批量查询" class="headerlink" title="multi_match 多字段批量查询"></a>multi_match 多字段批量查询 </h4><p> 在普通的 match 查询中，我们需要指定要查询的字段，multi_match 可以实现多个字段同时对检索数据查询</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">GET /test/_search</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;multi_match&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="string">&quot; 屈少天生我材 &quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;fields&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;introduce&quot;</span><span class="punctuation">,</span> <span class="string">&quot;name&quot;</span><span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>此时依然可以命中。</p><h4 id="match-phrase- 短语匹配"><a href="#match-phrase- 短语匹配" class="headerlink" title="match_phrase 短语匹配"></a>match_phrase 短语匹配</h4><p>match_phrase 短语匹配是一种更为精准的查询方式，这种查询方式需要匹配到检索数据中所有出现的分词，且每个词的顺序要与文档中词语顺序保持一致，这里的顺序主要指的是分词的相连</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">GET /test/_search</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;match_phrase&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;introduce&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="string">&quot; 我千金散尽还复来 &quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>此时无命中数据，因为在索引中存储的数据为“天生我材必有用，千金散尽还复来。”，通过执行 POST &#x2F;_analyze 我们知道在索引中是存在“我”和“千金散尽还复来”这两个分词的，但是两个分词的顺序和检索数据中不一致（中间 <strong> 间隔 </strong> 了其他单词），因此匹配失败。但是 ES 也提供了参数供用户自定义——slop，该参数表示的是允许分词之间存在的最大间隔。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">GET /test/_search</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;match_phrase&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;introduce&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="string">&quot; 我千金散尽还复来 &quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;slop&quot;</span><span class="punctuation">:</span> <span class="number">10</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>此时命中索引，因为我们允许分词之间存在最多 10 个间隔。</p><h4 id="match-phrase-prefix"><a href="#match-phrase-prefix" class="headerlink" title="match_phrase_prefix"></a>match_phrase_prefix</h4><p>match_phrase_prefix 和 match_phrase 比较类似，只是会给最后一个分词加上指定数量的通配符，也就是说，最后一个分词并不需要完全和索引中的分词匹配，只需要索引中的分词是以最后一个分词开头即可（具体容忍度可以通过参数 max_expansions 控制）</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">GET /test/_search</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;match_phrase_prefix&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;introduce&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="string">&quot; 天生我材必 &quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;max_expansions&quot;</span><span class="punctuation">:</span> <span class="number">2</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>实验发现，当 max_expansions 为 2 时命中数据，而当 max_expansions 为 1 或者 0 时无命中，因为索引在分词时将上半句话分为了“天生”、“我”、“材”、“必有用”，而将检索数据分词为了“天生”、“我”、“材”、“必”，此时前三个分词在索引中匹配，但是最后一个词“必”在索引中没有，当允许通配两个字符的时候，就和“必有用”匹配，因此数据命中。这种方式相当于在某种程度上提供了类似“<strong>联想词</strong>”的功能。</p><h4 id="term- 精准查询"><a href="#term- 精准查询" class="headerlink" title="term 精准查询"></a>term 精准查询 </h4><p> 在 ES 中，字符串分为“text”和“keyword”两种类型，ES 会对类型为 text 的字段进行分词，对类型为 keyword 的字段不分词直接存储，但是 ES 主要是用于检索并不适合存储长字符串，因此对于 keyword 类型提供了参数 ignore_above，超出 ignore_above 长度的字段将不会被索引，但是会存储。另外，keyword 类型的最大支持的长度为 32766 个 UTF-8 类型的字符。<br>term 查询不会对查询条件进行分词，即你输入什么查询条件就是什么，更多用于 keyword 类型的查询，因为 keyword 也不会被分词，可以精确匹配到文档</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">GET /test/_search</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;term&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;value&quot;</span><span class="punctuation">:</span> <span class="string">&quot; 屈少 &quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h4 id="range- 范围查询"><a href="#range- 范围查询" class="headerlink" title="range 范围查询"></a>range 范围查询</h4><p>range 查询用于范围查询，如查询某个日期范围内、某个价格区间内的文档，有 gt&#x2F;gte&#x2F;lt&#x2F;lte（大于 &#x2F; 大于等于 &#x2F; 小于 &#x2F; 小于等于）四种逻辑符</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">GET /test/_search</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;range&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;birthday&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;gte&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1999-01-01&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;lte&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2020-01-01&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">GET /test/_search</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;range&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;sex&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;gte&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;lte&quot;</span><span class="punctuation">:</span> <span class="number">10</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>此处对于 sex 其实我们一般不会将它设置为整数类型并且按照范围去检索，这里仅仅只是为了示范 range 查询可以用于时间和数字类型的查询。</p><h4 id="bool- 查询"><a href="#bool- 查询" class="headerlink" title="bool 查询"></a>bool 查询 </h4><p> 在实际的搜索场景下条件不可能只有一个，通常是将多个条件组合起来查询，类似 SQL 语句中的“WHERE a AND b AND c”，这时就可以用 bool 查询来拼接条件。<br>bool 查询分为四种：must&#x2F;should&#x2F;must_not&#x2F;filter<br>must：必须满足该条件，会进行分值计算；<br>should：分含有 must 条件和不含 must 条件两种情况，在不含 must 条件时，只要满足 should 条件就会返回该文档；含有 must 条件时，满足 should 条件的文档会加分（不满足也会返回），说明相关性更高，返回的优先级也会变高；<br>must_not：必须不满足该条件；<br>filter：必须满足该条件，但他不会进行分值计算，且常用 filter 会被缓存，非常推荐使用！能使用 filter 代替 must 的场景，尽量都使用 filter</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">GET /test/_search</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;bool&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;must&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;term&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">              <span class="attr">&quot;value&quot;</span><span class="punctuation">:</span> <span class="string">&quot; 屈少 &quot;</span></span><br><span class="line">            <span class="punctuation">&#125;</span></span><br><span class="line">          <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;range&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;sex&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">              <span class="attr">&quot;gte&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">              <span class="attr">&quot;lte&quot;</span><span class="punctuation">:</span> <span class="number">1</span></span><br><span class="line">            <span class="punctuation">&#125;</span></span><br><span class="line">          <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;should&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;match_phrase&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;introduce&quot;</span><span class="punctuation">:</span> <span class="string">&quot; 你真棒 &quot;</span></span><br><span class="line">          <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>在这个查询中，需要满足两个 must 条件和一个 should 条件，最后即使 should 条件没有满足我们也可以命中一条数据，当然，上面提到对于 must 条件，我们可以适当地使用 filter 进行改写</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">GET /test/_search</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;bool&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;filter&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;term&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">              <span class="attr">&quot;value&quot;</span><span class="punctuation">:</span> <span class="string">&quot; 屈少 &quot;</span></span><br><span class="line">            <span class="punctuation">&#125;</span></span><br><span class="line">          <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;range&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;sex&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">              <span class="attr">&quot;gte&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">              <span class="attr">&quot;lte&quot;</span><span class="punctuation">:</span> <span class="number">1</span></span><br><span class="line">            <span class="punctuation">&#125;</span></span><br><span class="line">          <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;should&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;match_phrase&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;introduce&quot;</span><span class="punctuation">:</span> <span class="string">&quot; 你真棒 &quot;</span></span><br><span class="line">          <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>两者实现的效果是一样的，唯一的变化在于 bool 下嵌套的“must”——&gt;”filter”，但是在实际查询中，如果我们多次对 name 和 sex 进行相同条件的查询，filter 会拥有更高的查询效率。</p><h2 id="小结"><a href="# 小结" class="headerlink" title="小结"></a>小结</h2><p>​ES 的功能其实还有很多，诸如聚合等操作，但是在大部分不是特别严格的场景下，最主要的还是上述那些普通查询的组合。在使用的过程中我也发现分词器对于检索的效果是相当重要的，有时候检索结果不理想（主要是搜出了大量不需要的数据），很有可能是因为在文档进行存储分词时就没有按照我们的预想去进行，比较经典的就是如果你直接使用 ES 默认的分词器对中文文档进行分词，分词器会根据每一个字进行拆分，这显然是不符合我们中文单词词组的实际的。所以，对于不同语种最好采用不同的分词器以达到更精确的分词效果。<br>​另外，ES 最核心的功能是检索，因此在实际中我们一般只需要将可能会被用于检索的字段进行存储即可，再通过唯一标识从数据库或者其他地方获取完整的数据，这样不但可以减少 ES 的存储压力，而且可以更好地保护我们的数据。</p>]]></content>
      
      
      <categories>
          
          <category> Elasticsearch </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Elasticsearch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Elasticsearch 安装及模拟集群部署</title>
      <link href="/2023/1296140704.html"/>
      <url>/2023/1296140704.html</url>
      
        <content type="html"><![CDATA[<h1 id="Elasticsearch 安装及模拟集群部署"><a href="#Elasticsearch 安装及模拟集群部署" class="headerlink" title="Elasticsearch 安装及模拟集群部署"></a>Elasticsearch 安装及模拟集群部署</h1><hr><h2 id="部署环境及 Elasticsearch 版本"><a href="# 部署环境及 Elasticsearch 版本" class="headerlink" title="部署环境及 Elasticsearch 版本"></a>部署环境及 Elasticsearch 版本 </h2><p> 服务器环境：Alibaba Cloud Linux 3 (Soaring Falcon)</p><p>操作系统内核版本：Linux 5.10.134-15.2.al8.x86_64</p><p>Elasticsearch 版本：elasticsearch-5.6.8 （官网下载地址：<span class="exturl" data-url="aHR0cHM6Ly9hcnRpZmFjdHMuZWxhc3RpYy5jby9kb3dubG9hZHMvZWxhc3RpY3NlYXJjaC9lbGFzdGljc2VhcmNoLTUuNi44LnRhci5neiVFRiVCQyU4OQ==">https://artifacts.elastic.co/downloads/elasticsearch/elasticsearch-5.6.8.tar.gz）<i class="fa fa-external-link-alt"></i></span></p><p>Elasticsearch 自带 JDK，虽然也有 NO-JDK 版本，但一般无需再进行 JDK 配置。</p><hr><h2 id="安装部署"><a href="# 安装部署" class="headerlink" title="安装部署"></a>安装部署</h2><p>Elasticsearch 不允许以 root 用户权限执行，因此我们需要先创建一个普通用户，这里我创建了一个名为”es”的普通用户，读者可根据自己喜好修改。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">useradd es</span><br></pre></td></tr></table></figure><p>将下载的安装包上传至安装目录并解压（此处我将 ES 安装在 &#x2F;opt&#x2F;elasticsearch 目录下）。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf elasticsearch-5.6.8.tar.gz</span><br></pre></td></tr></table></figure><p>解压后修改目录用户组。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chown -R es:es ./elasticsearch-5.6.8</span><br></pre></td></tr></table></figure><p>之后是一些需要修改的变量</p><ol><li>vm.max_map_count 是一个与内核虚拟内存子系统相关的参数，用于控制进程可以拥有的内存映射区域的最大数量。它通常用于限制一个进程可以打开的文件数量，特别是在使用大量内存映射文件的情况下。该变量位于 &#x2F;etc&#x2F;sysctl.conf 中，直接末尾添加或者修改变量即可，该变量过小会导致 ES 报错（max virtual memory areas vm.max_map_count [65530] is too low, increase to at least [262144]）<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vm.max_map_count=262144</span><br></pre></td></tr></table></figure>修改完成后记得在 root 权限下更新变量。<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sysctl -p</span><br></pre></td></tr></table></figure></li><li>在文件 &#x2F;etc&#x2F;security&#x2F;limits.conf 中修改以下变量（nofile 打开的文件句柄数量; nproc 打开的进程数量），未配置会导致报错（max file descriptors [4096] for elasticsearch process is too low, increase to at least [65535]）。<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">root soft nofile 65535</span><br><span class="line">root hard nofile 65535</span><br><span class="line">* soft nofile 65536</span><br><span class="line">* hard nofile 131072</span><br><span class="line">* soft nproc 65535</span><br><span class="line">* hard nproc 4096</span><br></pre></td></tr></table></figure>同上，记得更新变量。</li><li>进入 ES 安装目录下 config 目录，修改 jvm 参数，其他一般默认即可，堆内存默认 4g 太大服务器扛不住，这里注意初始堆大小和最大堆大小的值需要保持一致，不然同样也会报错。<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-Xms512m</span><br><span class="line">-Xmx512m</span><br></pre></td></tr></table></figure></li><li>最后就是 elasticsearch.yml 文件中的配置，笔者是在一台服务器上的两个端口模拟 ES 集群，直接将主从节点的配置文件给出，在此之前需要复制 elasticsearch-5.6.8 目录并更名，我的命名为 elasticsearch-master 和 elasticsearch-node1<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cp -R /opt/elasticsearch/elasticsearch-5.6.8 /opt/elasticsearch/elasticsearch-master</span><br><span class="line">cp -R /opt/elasticsearch/elasticsearch-5.6.8 /opt/elasticsearch/elasticsearch-node1</span><br></pre></td></tr></table></figure></li></ol><h4 id="master 节点配置"><a href="#master 节点配置" class="headerlink" title="master 节点配置"></a>master 节点配置 </h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">---------------------------------- Cluster -----------------------------------</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># Use a descriptive name for your cluster:</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># 集群名称，同一集群下的所有节点必须配置相同的名称</span></span></span><br><span class="line">cluster.name: my-application</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># ------------------------------------ Node ------------------------------------</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># Use a descriptive name for the node:</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># 节点名称</span></span></span><br><span class="line">node.name: master</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"> 节点是否可以被选举为主节点 </span></span><br><span class="line">node.master: true</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"> 节点是否可以存储数据（可以将主节点设置为 <span class="literal">false</span>）</span></span><br><span class="line">node.data: true</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># ---------------------------------- Network -----------------------------------</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># Set the bind address to a specific IP (IPv4 or IPv6):</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># 可访问的地址，因为笔者是在云服务器上部署，因此开放了所有 IP 方便远程访问，实际可以配置 IP 名单</span></span></span><br><span class="line">network.host: 0.0.0.0</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># Set a custom port for HTTP:</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># ES 端口</span></span></span><br><span class="line">http.port: 9200</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">ES 集群通信端口</span></span><br><span class="line">transport.tcp.port: 9300</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># For more information, consult the network module documentation.</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># --------------------------------- Discovery ----------------------------------</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># Pass an initial list of hosts to perform discovery when new node is started:</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">The default list of hosts is [<span class="string">&quot;127.0.0.1&quot;</span>, <span class="string">&quot;[::1]&quot;</span>]</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># 允许发现的其他 ES，其中“x.x.x.x”为部署 IP，笔者在此隐去，若是在本机部署，一般设置为“127.0.0.1”即可</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"> 受限于服务器性能，此处实际只多部署了端口 9301,9302 虽然配置了监听但是没有部署 </span></span><br><span class="line">discovery.zen.ping.unicast.hosts: [&quot;x.x.x.x:9301&quot;,&quot;x.x.x.x:9302&quot;]</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># Prevent the &quot;split brain&quot; by configuring the majority of nodes (total number of master-eligible nodes / 2 + 1):</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash">discovery.zen.minimum_master_nodes: 1</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment">#action.destructive_requires_name: true</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"> 下面两个配置是供插件 elasticsearch-head</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">开启跨域支持 </span></span><br><span class="line">http.cors.enabled: true</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"> 允许所有人跨域访问</span></span><br><span class="line">http.cors.allow-origin: &quot;*&quot;</span><br></pre></td></tr></table></figure><h4 id="node1 节点配置"><a href="#node1 节点配置" class="headerlink" title="node1 节点配置"></a>node1 节点配置 </h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">---------------------------------- Cluster -----------------------------------</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># Use a descriptive name for your cluster:</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># 集群名称，同一集群下的所有节点必须配置相同的名称</span></span></span><br><span class="line">cluster.name: my-application</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># ------------------------------------ Node ------------------------------------</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># Use a descriptive name for the node:</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># 节点名称</span></span></span><br><span class="line">node.name: node-1</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"> 节点是否可以被选举为主节点 </span></span><br><span class="line">node.master: false</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"> 节点是否可以存储数据（可以将主节点设置为 <span class="literal">false</span>）</span></span><br><span class="line">node.data: true</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># ---------------------------------- Network -----------------------------------</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># Set the bind address to a specific IP (IPv4 or IPv6):</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># 可访问的地址，因为笔者是在云服务器上部署，因此开放了所有 IP 方便远程访问，实际可以配置 IP 名单</span></span></span><br><span class="line">network.host: 0.0.0.0</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># Set a custom port for HTTP:</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># ES 端口</span></span></span><br><span class="line">http.port: 9201</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">ES 集群通信端口</span></span><br><span class="line">transport.tcp.port: 9301</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># For more information, consult the network module documentation.</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># --------------------------------- Discovery ----------------------------------</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># Pass an initial list of hosts to perform discovery when new node is started:</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">The default list of hosts is [<span class="string">&quot;127.0.0.1&quot;</span>, <span class="string">&quot;[::1]&quot;</span>]</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># 允许发现的其他 ES，其中“x.x.x.x”为部署 IP，笔者在此隐去，若是在本机部署，一般设置为“127.0.0.1”即可</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"> 受限于服务器性能，此处实际只多部署了端口 9300,9302 虽然配置了监听但是没有部署 </span></span><br><span class="line">discovery.zen.ping.unicast.hosts: [&quot;x.x.x.x:9300&quot;,&quot;x.x.x.x:9302&quot;]</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># Prevent the &quot;split brain&quot; by configuring the majority of nodes (total number of master-eligible nodes / 2 + 1):</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash">discovery.zen.minimum_master_nodes: 1</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment">#action.destructive_requires_name: true</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"> 下面两个配置是供插件 elasticsearch-head</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">开启跨域支持 </span></span><br><span class="line">http.cors.enabled: true</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"> 允许所有人跨域访问</span></span><br><span class="line">http.cors.allow-origin: &quot;*&quot;</span><br></pre></td></tr></table></figure><h4 id="差异配置项"><a href="# 差异配置项" class="headerlink" title="差异配置项"></a>差异配置项</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">node.name: </span><br><span class="line">node.master: </span><br><span class="line">http.port: </span><br><span class="line">transport.tcp.port: </span><br><span class="line">discovery.zen.ping.unicast.hosts:</span><br></pre></td></tr></table></figure><hr><h2 id="测试效果"><a href="# 测试效果" class="headerlink" title="测试效果"></a>测试效果 </h2><p> 分别进入 master 和 node-1 安装目录下的 bin 目录，执行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./elasticsearch -d</span><br></pre></td></tr></table></figure><p>-d 参数使服务后台运行，特别注意需要 <strong> 切换普通用户权限 </strong>（常见错误）。<br> 正常情况下直接访问<span class="exturl" data-url="aHR0cDovL2lwOjkyMDAv">http://IP:9200<i class="fa fa-external-link-alt"></i></span> 和 <span class="exturl" data-url="aHR0cDovL2lwOjkyMDEv">http://IP:9201<i class="fa fa-external-link-alt"></i></span> ，有类似如下输出即为成功。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;name&quot;: &quot;master&quot;,</span><br><span class="line">    &quot;cluster_name&quot;: &quot;my-application&quot;,</span><br><span class="line">    &quot;cluster_uuid&quot;: &quot;IyvYVkqbSjy_5QL7ZWdrKg&quot;,</span><br><span class="line">    &quot;version&quot;: &#123;</span><br><span class="line">        &quot;number&quot;: &quot;5.6.8&quot;,</span><br><span class="line">        &quot;build_hash&quot;: &quot;688ecce&quot;,</span><br><span class="line">        &quot;build_date&quot;: &quot;2018-02-16T16:46:30.010Z&quot;,</span><br><span class="line">        &quot;build_snapshot&quot;: false,</span><br><span class="line">        &quot;lucene_version&quot;: &quot;6.6.1&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;tagline&quot;: &quot;You Know, for Search&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;name&quot;: &quot;node-1&quot;,</span><br><span class="line">    &quot;cluster_name&quot;: &quot;my-application&quot;,</span><br><span class="line">    &quot;cluster_uuid&quot;: &quot;IyvYVkqbSjy_5QL7ZWdrKg&quot;,</span><br><span class="line">    &quot;version&quot;: &#123;</span><br><span class="line">        &quot;number&quot;: &quot;5.6.8&quot;,</span><br><span class="line">        &quot;build_hash&quot;: &quot;688ecce&quot;,</span><br><span class="line">        &quot;build_date&quot;: &quot;2018-02-16T16:46:30.010Z&quot;,</span><br><span class="line">        &quot;build_snapshot&quot;: false,</span><br><span class="line">        &quot;lucene_version&quot;: &quot;6.6.1&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;tagline&quot;: &quot;You Know, for Search&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Elasticsearch </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Elasticsearch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 多线程的几个经典问题</title>
      <link href="/2022/11beb6dc8d.html"/>
      <url>/2022/11beb6dc8d.html</url>
      
        <content type="html"><![CDATA[<h1 id="Java 多线程的几个经典问题"><a href="#Java 多线程的几个经典问题" class="headerlink" title="Java 多线程的几个经典问题"></a>Java 多线程的几个经典问题 </h1><p> 在最近的面试过程中，经常会被问到一些多线程的问题，大多数面试官主要把重点放在底层逻辑的实现上。但是学习万万不能舍本逐末，了解底层逻辑是为了更好地在实际中应用，因此总结了下多线程的一些经典的实际问题，在此学习记录。</p><hr><p>本次实验代码已托管至 github：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3F1LXNoYW8vRmlsZXMvdHJlZS9tYWluL0phdmElRTUlQTQlOUElRTclQkElQkYlRTclQTglOEIlRTclOUElODQlRTUlODclQTAlRTQlQjglQUElRTclQkIlOEYlRTUlODUlQjglRTklOTclQUUlRTklQTIlOTg=">Files&#x2F;Java 多线程的几个经典问题 at main · qu-shao&#x2F;Files (github.com)<i class="fa fa-external-link-alt"></i></span></p><hr><h2 id="死锁模拟问题"><a href="# 死锁模拟问题" class="headerlink" title="死锁模拟问题"></a>死锁模拟问题 </h2><h3 id="题意"><a href="# 题意" class="headerlink" title="题意"></a> 题意 </h3><p> 死锁的概念就不必再多提了，死锁通常发生在多线程下对资源的争抢场景下，现在需要用 Java 模拟实现一个死锁的场景。</p><h3 id="解决方案"><a href="# 解决方案" class="headerlink" title="解决方案"></a>解决方案 </h3><p> 我们知道死锁形成的四个必要条件：</p><ol><li>资源互斥</li><li>不可剥夺</li><li>持有和等待</li><li>环路请求</li></ol><p>只需要提供两个资源（锁），设计导致一个线程持有其中一个资源 A，接着请求另一个资源 B，但同时要保证另一个线程已经持有资源 B 且正在请求资源 A 即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> JUC;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeadLock</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">resourceA</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">        <span class="type">Object</span> <span class="variable">resourceB</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">threadA</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (resourceA)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;ThreadA is waiting for another lock... ...&quot;</span>);</span><br><span class="line">                <span class="keyword">synchronized</span> (resourceB)&#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;ThreadA gets two locks!&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">threadB</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (resourceB)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;ThreadB is waiting for another lock... ...&quot;</span>);</span><br><span class="line">                <span class="keyword">synchronized</span> (resourceA)&#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;ThreadB gets two locks!&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        threadA.start();</span><br><span class="line">        threadB.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>形成死锁的关键在于对资源 A 和 B 的请求顺序上，两个线程请求资源的顺序不一致，那么在 A 线程已经持有资源 A 且未请求资源 B 的间隙可能会存在线程 B 启动并持有了资源 B，此时 B 线程因为无法请求到资源 A 导致阻塞，同时线程 A 接着去请求资源 B 的时候因为已经被线程 B 持有也导致阻塞，两个线程互相等待，因此形成死锁（如果为了刻意增大线程形成死锁的概率，可以在 A 线程和 B 线程中获取到第一个资源后 sleep 一段时间，提供足够的时候使另一个线程启动）。</p><p>顺带一提，那么解决该死锁的方法也十分简单，只需要调整两个线程获取资源的顺序一致，那么只要有一个线程获取到了第一个资源，另一个线程就会被阻塞，直到已经获得第一个资源的线程接着获取第二个资源，执行完代码逻辑后释放资源，此时原先被阻塞的线程就可以顺利获得资源。另外，还有一种解决方案，就是将 A 和 B 两个资源聚合成一个新的对象，将两把锁对外变成一把锁，再由线程去争抢。</p><hr><h2 id="哲学家就餐问题"><a href="# 哲学家就餐问题" class="headerlink" title="哲学家就餐问题"></a>哲学家就餐问题 </h2><h3 id="题意 -1"><a href="# 题意 -1" class="headerlink" title="题意"></a> 题意 </h3><p> 哲学家就餐问题可以这样表述，假设有五位哲学家围坐在一张圆形餐桌旁，做以下两件事情之一：吃饭，或者思考。吃东西的时候，他们就停止思考，思考的时候也停止吃东西。餐桌中间有一大碗意大利面，每两个哲学家之间有一只餐叉。因为用一只餐叉很难吃到意大利面，所以假设哲学家必须用两只餐叉吃东西。他们只能使用自己左右手边的那两只餐叉。哲学家就餐问题有时也用米饭和筷子而不是意大利面和餐叉来描述，因为很明显，吃米饭必须用两根筷子。</p><p>抽象成实际情况就是有五个线程，只有当线程获取到该线程对应的两个资源的时候才能顺利运行，先要求运行这五个线程，保证内部的逻辑一定可以让每一个线程执行完毕。</p><h3 id="解决方案 -1"><a href="# 解决方案 -1" class="headerlink" title="解决方案"></a>解决方案</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> JUC;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DinningPhilosophersProblem</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Chopsticks</span> <span class="variable">chopsticks1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Chopsticks</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="type">Chopsticks</span> <span class="variable">chopsticks2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Chopsticks</span>(<span class="number">2</span>);</span><br><span class="line">        <span class="type">Chopsticks</span> <span class="variable">chopsticks3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Chopsticks</span>(<span class="number">3</span>);</span><br><span class="line">        <span class="type">Chopsticks</span> <span class="variable">chopsticks4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Chopsticks</span>(<span class="number">4</span>);</span><br><span class="line">        <span class="type">Chopsticks</span> <span class="variable">chopsticks5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Chopsticks</span>(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Philosohper</span> <span class="variable">philosohper1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Philosohper</span>(<span class="string">&quot;Philosohper1&quot;</span>, <span class="number">1</span>, chopsticks1, chopsticks5);</span><br><span class="line">        <span class="type">Philosohper</span> <span class="variable">philosohper2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Philosohper</span>(<span class="string">&quot;Philosohper2&quot;</span>, <span class="number">2</span>, chopsticks2, chopsticks1);</span><br><span class="line">        <span class="type">Philosohper</span> <span class="variable">philosohper3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Philosohper</span>(<span class="string">&quot;Philosohper3&quot;</span>, <span class="number">3</span>, chopsticks3, chopsticks2);</span><br><span class="line">        <span class="type">Philosohper</span> <span class="variable">philosohper4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Philosohper</span>(<span class="string">&quot;Philosohper4&quot;</span>, <span class="number">4</span>, chopsticks4, chopsticks3);</span><br><span class="line">        <span class="type">Philosohper</span> <span class="variable">philosohper5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Philosohper</span>(<span class="string">&quot;Philosohper5&quot;</span>, <span class="number">5</span>, chopsticks5, chopsticks4);</span><br><span class="line"></span><br><span class="line">        philosohper1.start();</span><br><span class="line">        philosohper2.start();</span><br><span class="line">        philosohper3.start();</span><br><span class="line">        philosohper4.start();</span><br><span class="line">        philosohper5.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Chopsticks</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Chopsticks</span><span class="params">(<span class="type">int</span> id)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Philosohper</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Chopsticks left;</span><br><span class="line">    <span class="keyword">private</span> Chopsticks right;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> index;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Philosohper</span><span class="params">(String name, <span class="type">int</span> index, Chopsticks left, Chopsticks right)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.index = index;</span><br><span class="line">        <span class="built_in">this</span>.left = left;</span><br><span class="line">        <span class="built_in">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(index % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (left)&#123;</span><br><span class="line">                System.out.println(<span class="built_in">this</span>.name + <span class="string">&quot; is waiting for the right chopsticks... ...&quot;</span>);</span><br><span class="line">                <span class="keyword">synchronized</span> (right)&#123;</span><br><span class="line">                    System.out.println(<span class="built_in">this</span>.name + <span class="string">&quot; finishes his dinner!&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (right)&#123;</span><br><span class="line">                System.out.println(<span class="built_in">this</span>.name + <span class="string">&quot; is waiting for the left chopsticks... ...&quot;</span>);</span><br><span class="line">                <span class="keyword">synchronized</span> (left)&#123;</span><br><span class="line">                    System.out.println(<span class="built_in">this</span>.name + <span class="string">&quot; finishes his dinner!&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先分析为何会出现死锁，如果每一个哲学家（线程）都先请求并持有了他对应左边（假设）的筷子（资源），总共五根筷子，此时五位哲学家每人持有一根，可以想象，任何一个哲学家想要就餐（完成代码逻辑），都必须等待其右手的哲学家放下筷子，但是哲学家放弃筷子的前提是已经完成就餐，那么此时就形成了一个循环请求的环，导致了死锁。</p><p>那么如何解决呢，其实很简单，只需要其中一个哲学家拿起筷子（获取资源）的顺序和其他哲学家不一样即可，可以想象，如果和上一个场景中每个哲学家依次先请求其左手的筷子，总会执行到这个特殊的哲学家，他会先请求自己右边的筷子，但是此时因为他右手的哲学家已经请求到了该哲学家左手的筷子（即这个特殊的哲学家右手的筷子），此时这个特殊的哲学家处于等待资源状态，并不会去请求持有其左手的哲学家，那么对于这个特殊哲学家左手的下一位哲学家，该哲学家获取到了其左手的资源，再成功申请获取到其右手的资源（对应特殊哲学家左手的资源），那么该哲学家一定可以顺利完成就餐，完成后他会释放自己持有的资源，那么对于他（此时可以将他看做另一个特殊的哲学家）左手的哲学家也可以完成就餐，以此类推，最后所有的哲学家一定可以完成就餐。</p><p>我们只需要保证至少一个哲学家请求资源的顺序和其他哲学家不一致即可破除该死锁，更一般地，更有效率的，我们可以设置一半的哲学家成为这个“特殊”的哲学家（通过哲学家的 index 或者其他标志区分），就可以更快地完成任务（相当于增加了破除死锁请求环的入口点）。</p><hr><h2 id="双线程交替打印问题"><a href="# 双线程交替打印问题" class="headerlink" title="双线程交替打印问题"></a>双线程交替打印问题 </h2><h3 id="题意 -2"><a href="# 题意 -2" class="headerlink" title="题意"></a> 题意 </h3><p> 有两个线程，其中一个线程依次打印数字，另一个线程依次打印大写字母，现在要求两个线程交替打印，并且满足每次都是先打印字母，即最后的结果形如 “A1B2C3D4… …”</p><h3 id="解决方案 1"><a href="# 解决方案 1" class="headerlink" title="解决方案 1"></a>解决方案 1</h3><p>首先我们知道，线程是可以通过调用方法进行休眠和唤醒的，那么这个问题的精髓在于两个线程通过什么方式什么手段进行休眠和唤醒。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> JUC;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.LockSupport;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CrossPrint1</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> Thread thread1, thread2;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[] letters = &#123;<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>,<span class="string">&#x27;C&#x27;</span>,<span class="string">&#x27;D&#x27;</span>,<span class="string">&#x27;E&#x27;</span>,<span class="string">&#x27;F&#x27;</span>,<span class="string">&#x27;G&#x27;</span>,<span class="string">&#x27;H&#x27;</span>&#125;;</span><br><span class="line">        <span class="type">char</span>[] nums = &#123;<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2&#x27;</span>,<span class="string">&#x27;3&#x27;</span>,<span class="string">&#x27;4&#x27;</span>,<span class="string">&#x27;5&#x27;</span>,<span class="string">&#x27;6&#x27;</span>,<span class="string">&#x27;7&#x27;</span>,<span class="string">&#x27;8&#x27;</span>&#125;;</span><br><span class="line"></span><br><span class="line">        thread1 = <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">char</span> c : letters)&#123;</span><br><span class="line">                System.out.println(c);</span><br><span class="line">                LockSupport.unpark(thread2);</span><br><span class="line">                LockSupport.park();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        thread2 = <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">char</span> c : nums)&#123;</span><br><span class="line">                LockSupport.park();</span><br><span class="line">                System.out.println(c);</span><br><span class="line">                LockSupport.unpark(thread1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先我们确认需要输出的字符数组，剩下的工作就是让两个线程依次打印自己负责的字符，在打印字母的线程中，首先会打印当前字母，然后唤醒打印数字的线程，随后自己进入等待状态；在打印数字的线程中，因为我们要求必须先打印字母，所以打印数字的线程必须是由另一个线程唤醒，所以一进入循环，该线程必须主动进入等待状态，随后被打印字母的线程唤醒，此时该线程打印自己当前循环负责的具体数字，打印结束后唤醒之前主动沉睡的负责打印字母的线程，同时打印数字的线程进入下一次循环，首先会自动陷入等待状态。至此，实现了交替打印的功能。</p><h3 id="解决方案 2"><a href="# 解决方案 2" class="headerlink" title="解决方案 2"></a>解决方案 2</h3><p>在解决方案 1 中，主要是通过调用 LockSupport 中提供的静态方法使得两个线程互相唤醒、自己沉睡，对于线程的同步，我们也可以通过经典的 wait&#x2F;notify 实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> JUC;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CrossPrint2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[] letters = &#123;<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>,<span class="string">&#x27;C&#x27;</span>,<span class="string">&#x27;D&#x27;</span>,<span class="string">&#x27;E&#x27;</span>,<span class="string">&#x27;F&#x27;</span>,<span class="string">&#x27;G&#x27;</span>,<span class="string">&#x27;H&#x27;</span>&#125;;</span><br><span class="line">        <span class="type">char</span>[] nums = &#123;<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2&#x27;</span>,<span class="string">&#x27;3&#x27;</span>,<span class="string">&#x27;4&#x27;</span>,<span class="string">&#x27;5&#x27;</span>,<span class="string">&#x27;6&#x27;</span>,<span class="string">&#x27;7&#x27;</span>,<span class="string">&#x27;8&#x27;</span>&#125;;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">        <span class="type">CountDownLatch</span> <span class="variable">countDownLatch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (object)&#123;</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">char</span> c : letters)&#123;</span><br><span class="line">                    System.out.println(c);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        object.notify();</span><br><span class="line">                        object.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                object.notify();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (object)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    countDownLatch.await();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">char</span> c : nums)&#123;</span><br><span class="line">                    System.out.println(c);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        object.notify();</span><br><span class="line">                        object.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                object.notify();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先我们定义了两个线程需要持有的“锁”对象，在具体的两个线程中，会争抢该锁，得到锁的线程首先打印自己当前的任务，然后唤醒其他的线程（另一个线程），随后自己主动进入等待状态，以此循环。但是要注意的一点是，在 for 循环执行完毕后，线程此时已经自主地进入了等待状态，所以需要两个线程互相唤醒，也就是两个线程代码中 for 循环外的 notify 代码的作用；同时，为了保证先打印字母，因为我们无法保证打印字母的线程在启动后先被 CPU 选中执行，需要人为地保证第一次打印的先后顺序（之后的顺序是通过 wait&#x2F;notify 控制），引入了 CountDownLatch 类，该类可以实现在倒计时为 0 之前，调用 countDownLatch.await() 方法之后的代码不被执行（阻塞在当前位置），所以我们在打印字母的线程第一次获取到锁的时候，将倒计时器减一，而在打印数字的线程第一次获取到锁的时候，检查当前的倒计时是否可以继续运行后面的逻辑，用这种方法保证字母一定优先于数字打印。</p><h3 id="解决方案 3"><a href="# 解决方案 3" class="headerlink" title="解决方案 3"></a>解决方案 3</h3><p>在解决方案 2 中，我们主要使用了 wait&#x2F;notify 进行线程间的同步控制，其本质就是对锁的控制，而在 Java 中，还提供了 Java 类级别上的锁的实现——lock&#x2F;condition，同样可以用这种锁进行实现，逻辑类似，但需要注意一点的是 lock 必须自己手动释放锁（一般在 finally 代码块中进行处理）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> JUC;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CrossPrint3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[] letters = &#123;<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>,<span class="string">&#x27;C&#x27;</span>,<span class="string">&#x27;D&#x27;</span>,<span class="string">&#x27;E&#x27;</span>,<span class="string">&#x27;F&#x27;</span>,<span class="string">&#x27;G&#x27;</span>,<span class="string">&#x27;H&#x27;</span>&#125;;</span><br><span class="line">        <span class="type">char</span>[] nums = &#123;<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2&#x27;</span>,<span class="string">&#x27;3&#x27;</span>,<span class="string">&#x27;4&#x27;</span>,<span class="string">&#x27;5&#x27;</span>,<span class="string">&#x27;6&#x27;</span>,<span class="string">&#x27;7&#x27;</span>,<span class="string">&#x27;8&#x27;</span>&#125;;</span><br><span class="line">        <span class="type">CountDownLatch</span> <span class="variable">countDownLatch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">        <span class="type">Condition</span> <span class="variable">condition</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">           lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">char</span> c : letters)&#123;</span><br><span class="line">                    System.out.println(c);</span><br><span class="line">                    condition.signal();</span><br><span class="line">                    condition.await();</span><br><span class="line">                &#125;</span><br><span class="line">                condition.signal();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                countDownLatch.await();</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">char</span> c : nums)&#123;</span><br><span class="line">                    System.out.println(c);</span><br><span class="line">                    condition.signal();</span><br><span class="line">                    condition.await();</span><br><span class="line">                &#125;</span><br><span class="line">                condition.signal();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="解决方案 4"><a href="# 解决方案 4" class="headerlink" title="解决方案 4"></a>解决方案 4</h3><p>TransferQueue 是一种典型的生产者 &#x2F; 消费者思想，其具体实现中，当生产者利用 transfer()方法发送消息给消费者时，生产者将一直被阻塞，直到消息被使用为止；当队列为空时，消费者调用的 take()方法也会被阻塞。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> JUC;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.LinkedTransferQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TransferQueue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CrossPrint4</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[] letters = &#123;<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>,<span class="string">&#x27;C&#x27;</span>,<span class="string">&#x27;D&#x27;</span>,<span class="string">&#x27;E&#x27;</span>,<span class="string">&#x27;F&#x27;</span>,<span class="string">&#x27;G&#x27;</span>,<span class="string">&#x27;H&#x27;</span>&#125;;</span><br><span class="line">        <span class="type">char</span>[] nums = &#123;<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2&#x27;</span>,<span class="string">&#x27;3&#x27;</span>,<span class="string">&#x27;4&#x27;</span>,<span class="string">&#x27;5&#x27;</span>,<span class="string">&#x27;6&#x27;</span>,<span class="string">&#x27;7&#x27;</span>,<span class="string">&#x27;8&#x27;</span>&#125;;</span><br><span class="line">        TransferQueue&lt;Character&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedTransferQueue</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">char</span> c : nums)&#123;</span><br><span class="line">                    System.out.println(queue.take());</span><br><span class="line">                    queue.transfer(c);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">char</span> c : letters)&#123;</span><br><span class="line">                    queue.transfer(c);</span><br><span class="line">                    System.out.println(queue.take());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们实现了两个线程，负责往队列中添加字母的线程会负责消费队列中已经存在的数字；负责往队列中添加数字的线程会负责消费队列中已经存在的字母。</p><hr><h2 id="三线程循环交替打印问题"><a href="# 三线程循环交替打印问题" class="headerlink" title="三线程循环交替打印问题"></a>三线程循环交替打印问题 </h2><h3 id="题意 -3"><a href="# 题意 -3" class="headerlink" title="题意"></a> 题意 </h3><p> 实现三个线程，每个线程打印的内容不同，要求按照 ABC 的顺序进行打印</p><h3 id="解决方案 1-1"><a href="# 解决方案 1-1" class="headerlink" title="解决方案 1"></a>解决方案 1</h3><p>受到之前的启发，我们在每个线程执行过程规定其需要唤醒的线程（下一个打印的线程），然后该线程进入等待状态让出 CPU，即保证在任何一个时刻（宏观上）都只有一个线程可以运行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> JUC;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.LockSupport;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PrintABC1</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> Thread threadA, threadB, threadC;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        threadA = <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; <span class="number">10</span>;i++)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;ThreadA :  A&quot;</span>);</span><br><span class="line">                LockSupport.unpark(threadB);</span><br><span class="line">                LockSupport.park();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        threadB = <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; <span class="number">10</span>;i++)&#123;</span><br><span class="line">                LockSupport.park();</span><br><span class="line">                System.out.println(<span class="string">&quot;ThreadB :  B&quot;</span>);</span><br><span class="line">                LockSupport.unpark(threadC);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        threadC = <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; <span class="number">10</span>;i++)&#123;</span><br><span class="line">                LockSupport.park();</span><br><span class="line">                System.out.println(<span class="string">&quot;ThreadC :  C&quot;</span>);</span><br><span class="line">                LockSupport.unpark(threadA);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        threadA.start();</span><br><span class="line">        threadB.start();</span><br><span class="line">        threadC.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="解决方案 2-1"><a href="# 解决方案 2-1" class="headerlink" title="解决方案 2"></a>解决方案 2</h3><p>lock&#x2F;condition 可以定义不同的 condition，即不同的线程等待队列，那么我们可以定义一个 lock，绑定其三个等待队列，在顺序唤醒即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> JUC;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PrintABC2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">        <span class="type">Condition</span> <span class="variable">conditionA</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line">        <span class="type">Condition</span> <span class="variable">conditionB</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line">        <span class="type">Condition</span> <span class="variable">conditionC</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line"></span><br><span class="line">        <span class="type">CountDownLatch</span> <span class="variable">countDownLatch1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="type">CountDownLatch</span> <span class="variable">countDownLatch2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">threadA</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; <span class="number">10</span>;i++)&#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;ThreadA :  A&quot;</span>);</span><br><span class="line">                    <span class="keyword">if</span>(i == <span class="number">0</span>)countDownLatch1.countDown();</span><br><span class="line">                    conditionB.signal();</span><br><span class="line">                    conditionA.await();</span><br><span class="line">                &#125;</span><br><span class="line">                conditionB.signal();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">threadB</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                countDownLatch1.await();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; <span class="number">10</span>;i++)&#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;ThreadB :  B&quot;</span>);</span><br><span class="line">                    <span class="keyword">if</span>(i == <span class="number">0</span>)countDownLatch2.countDown();</span><br><span class="line">                    conditionC.signal();</span><br><span class="line">                    conditionB.await();</span><br><span class="line">                &#125;</span><br><span class="line">                conditionC.signal();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">threadC</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                countDownLatch2.await();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; <span class="number">10</span>;i++)&#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;ThreadC :  C&quot;</span>);</span><br><span class="line">                    conditionA.signal();</span><br><span class="line">                    conditionC.await();</span><br><span class="line">                &#125;</span><br><span class="line">                conditionA.signal();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        threadA.start();</span><br><span class="line">        threadB.start();</span><br><span class="line">        threadC.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="生产者 - 消费者问题"><a href="# 生产者 - 消费者问题" class="headerlink" title="生产者 &#x2F; 消费者问题"></a>生产者 &#x2F; 消费者问题 </h2><h3 id="题意 -4"><a href="# 题意 -4" class="headerlink" title="题意"></a> 题意 </h3><p> 生产者消费者问题（英语：Producer-consumer problem），也称有限缓冲问题（英语：Bounded-buffer problem），是一个多线程同步问题的经典案例。该问题描述了共享固定大小缓冲区的两个线程——即所谓的“生产者”和“消费者”——在实际运行时会发生的问题。生产者的主要作用是生成一定量的数据放到缓冲区中，然后重复此过程。与此同时，消费者也在缓冲区消耗这些数据。该问题的关键就是要保证生产者不会在缓冲区满时加入数据，消费者也不会在缓冲区中空时消耗数据。</p><h3 id="解决方案 -2"><a href="# 解决方案 -2" class="headerlink" title="解决方案"></a>解决方案</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> JUC;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProducerConsumer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Storage</span> <span class="variable">storage</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Storage</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Producer</span>(storage));</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">p2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Producer</span>(storage));</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">p3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Producer</span>(storage));</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">c1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Consumer</span>(storage));</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">c2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Consumer</span>(storage));</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">c3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Consumer</span>(storage));</span><br><span class="line"></span><br><span class="line">        p1.start();</span><br><span class="line">        p2.start();</span><br><span class="line">        p3.start();</span><br><span class="line">        c1.start();</span><br><span class="line">        c2.start();</span><br><span class="line">        c3.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Producer</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Storage storage;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Producer</span><span class="params">(Storage storage)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.storage = storage;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            storage.produce();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Consumer</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Storage storage;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Consumer</span><span class="params">(Storage storage)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.storage = storage;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            storage.consume();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Storage</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_SIZE</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> LinkedList&lt;Object&gt; list = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">produce</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (list)&#123;</span><br><span class="line">            <span class="keyword">while</span>(list.size() + <span class="number">1</span> &gt; MAX_SIZE)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;The storage is full!&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    list.wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            list.add(<span class="keyword">new</span> <span class="title class_">Object</span>());</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; produces an object!&quot;</span>);</span><br><span class="line">            list.notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">consume</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (list)&#123;</span><br><span class="line">            <span class="keyword">while</span>(list.size() == <span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;The storage is empty!&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    list.wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            list.remove();</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; consumes an object!&quot;</span>);</span><br><span class="line">            list.notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解决该问题的关键在于对锁的释放上，因为调用 wait 方法会释放线程持有的锁。</p><p>在生产者生产逻辑中，当库存（队列）已满时，调用 wait 方法释放锁，此时处于等待队列中的线程争抢该锁，如果抢到锁的依旧是生产者，重复之前的逻辑（wait 释放锁），如果抢到锁的线程为消费者，则执行消费逻辑使得队列元素减少；类似的，在消费者逻辑中，当库存（队列）为空时，wait 方法释放锁，只有当生产者抢到锁时才不会进入阻塞态。而不论是消费者还是生产者，只要顺利进行消费 &#x2F; 生产后，都必须要唤醒所有其他的线程。</p><p>更加有效率的，我们可以使用 lock&#x2F;condition，定义一个 lock 对象，同时新建两个阻塞队列，其中一个统一存放生产者，另一个存放消费者。当生产者生产产品后，此时队列必不为空，所以之后应该唤醒消费者队列中的消费者线程尝试进行消费；当消费者消费产品后，此时队列必不满，所以之后应该唤醒生产者队列中的生产者线程尝试进行生产。这样做的话相当于我们每次唤醒的线程都是需要的线程，而不是像 notifyAll 唤醒所有线程争抢锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> JUC;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProducerConsumer2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Storage2</span> <span class="variable">storage</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Storage2</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Producer2</span>(storage));</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">p2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Producer2</span>(storage));</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">p3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Producer2</span>(storage));</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">c1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Consumer2</span>(storage));</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">c2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Consumer2</span>(storage));</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">c3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Consumer2</span>(storage));</span><br><span class="line"></span><br><span class="line">        p1.start();</span><br><span class="line">        p2.start();</span><br><span class="line">        p3.start();</span><br><span class="line">        c1.start();</span><br><span class="line">        c2.start();</span><br><span class="line">        c3.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Producer2</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Storage2 storage;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Producer2</span><span class="params">(Storage2 storage)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.storage = storage;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            storage.produce();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Consumer2</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Storage2 storage;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Consumer2</span><span class="params">(Storage2 storage)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.storage = storage;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            storage.consume();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Storage2</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_SIZE</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> LinkedList&lt;Object&gt; list = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Condition</span> <span class="variable">conditionConsumer</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Condition</span> <span class="variable">conditionProducer</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">produce</span><span class="params">()</span> &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (list.size() + <span class="number">1</span> &gt; MAX_SIZE) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;The storage is full!&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    conditionProducer.await();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            list.add(<span class="keyword">new</span> <span class="title class_">Object</span>());</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; produces an object!&quot;</span>);</span><br><span class="line">            conditionConsumer.signalAll();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">consume</span><span class="params">()</span> &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (list.size() == <span class="number">0</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;The storage is empty!&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    conditionConsumer.await();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            list.remove();</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; consumes an object!&quot;</span>);</span><br><span class="line">            conditionProducer.signalAll();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="总结"><a href="# 总结" class="headerlink" title="总结"></a>总结 </h2><p> 以上几个问题不过是多线程问题中的沧海一粟，在多线程处理中，最主要的就是线程之间的同步控制，所以我们必须要对线程状态之间的转换烂熟于心，而控制线程之间的同步，精髓就在于具体方法调用的时机。同时多线程的使用也需要相当谨慎，稍不注意就可能出现死锁或者程序崩溃。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Lambda 表达式学习笔记</title>
      <link href="/2022/1194f258f3.html"/>
      <url>/2022/1194f258f3.html</url>
      
        <content type="html"><![CDATA[<h2 id="Lambda 表达式"><a href="#Lambda 表达式" class="headerlink" title="Lambda 表达式"></a>Lambda 表达式</h2><hr><h4 id="基本语法"><a href="# 基本语法" class="headerlink" title="基本语法"></a>基本语法</h4><ol><li>可选的大括号</li></ol><p>函数体只包含一个语句，不需要大括号</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(String arg) -&gt; System.out.println(arg);</span><br></pre></td></tr></table></figure><ol start="2"><li>可选的参数圆括号</li></ol><p>只有一个参数，省略圆括号，同时省略类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arg -&gt; System.out.println(arg);</span><br></pre></td></tr></table></figure><ol start="3"><li>可选的返回关键字 return</li></ol><p>函数体只有一个表达式，且运算结果匹配返回类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="type">int</span> a, <span class="type">int</span> b) -&gt; a + b;</span><br></pre></td></tr></table></figure><ol start="4"><li>可选的类型声明</li></ol><p>不需要参数类型，编译器可以根据参数值进行判断</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(a, b) -&gt; a + b;</span><br></pre></td></tr></table></figure><h4 id="使用前提"><a href="# 使用前提" class="headerlink" title="使用前提"></a>使用前提 </h4><h5 id="必须有一个函数式接口"><a href="# 必须有一个函数式接口" class="headerlink" title="必须有一个函数式接口"></a> 必须有一个函数式接口 </h5><p> 有且只有一个抽象方法的接口；</p><p>@FunctionnalInterface 注解</p><h5 id="常见的函数式接口"><a href="# 常见的函数式接口" class="headerlink" title="常见的函数式接口"></a>常见的函数式接口</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">Runnable/Callable</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName());</span><br><span class="line">    &#125;).start();</span><br><span class="line"></span><br><span class="line">Supplier/Consumer</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] nums = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">8</span> , <span class="number">88</span>, <span class="number">64</span> , <span class="number">5</span>&#125;;</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> getMax(() -&gt; &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> el : nums)&#123;</span><br><span class="line">                temp = Math.max(temp, el);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> temp;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(max);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getMax</span><span class="params">(Supplier&lt;Integer&gt; sup)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sup.get();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">Comparator</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        String[] strs = &#123;<span class="string">&quot;asas&quot;</span>, <span class="string">&quot;445465&quot;</span>, <span class="string">&quot;saasa&quot;</span>, <span class="string">&quot;qwqwq&quot;</span>, <span class="string">&quot;21212&quot;</span>&#125;;</span><br><span class="line">        Arrays.sort(strs, (s1, s2) -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span>(s1.length() &lt; s2.length())<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(s1.length() &gt; s2.length())<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> s1.compareTo(s2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">for</span>(String s : strs)&#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">Predicate</span><br><span class="line">    </span><br><span class="line">Function</span><br><span class="line">    </span><br></pre></td></tr></table></figure><h4 id="Lambda 的底层实现"><a href="#Lambda 的底层实现" class="headerlink" title="Lambda 的底层实现"></a>Lambda 的底层实现</h4><p>Lambda 表达式的本质：函数式接口的匿名子类的匿名对象</p><h4 id="方法引用"><a href="# 方法引用" class="headerlink" title="方法引用"></a>方法引用 </h4><p> 引用已存在的方法，避免重复逻辑，本质上是对 Lambda 表达式的进一步化简，即如果存在某个对象中已经实现的代码逻辑和我们应该在 Lambda 表达式中编写的代码逻辑一致，那么直接调用该对象的该方法引用即可（要求为参数列表相同；返回值类型兼容）。具体使用格式为</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  通用格式 </span></span><br><span class="line"> 对象 :: 方法名 </span><br><span class="line">    </span><br><span class="line"><span class="comment">//  类方法（静态方法）</span></span><br><span class="line"> 类名 :: 静态方法 </span><br><span class="line">Integer :: parseInt</span><br><span class="line">    </span><br><span class="line"><span class="comment">//  构造方法</span></span><br><span class="line"> 类名 :: <span class="keyword">new</span></span><br><span class="line"><span class="title class_">Student</span> :: <span class="keyword">new</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//  成员方法 </span></span><br><span class="line"> 对象 :: 成员方法</span><br><span class="line"><span class="string">&quot;Hello&quot;</span> :: toUpperCase</span><br><span class="line"><span class="built_in">this</span> :: 方法名</span><br><span class="line"><span class="built_in">super</span> :: 方法名</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书笔记 </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 代理</title>
      <link href="/2022/11adf09ee.html"/>
      <url>/2022/11adf09ee.html</url>
      
        <content type="html"><![CDATA[<h1 id="Java 代理"><a href="#Java 代理" class="headerlink" title="Java 代理"></a>Java 代理</h1><hr><h3 id="基本概念："><a href="# 基本概念：" class="headerlink" title="基本概念："></a>基本概念：</h3><p>Java 的代理就是客户类不再直接和委托类打交道，而是通过一个中间层来访问，这个中间层就是代理。使用代理一方面可以隐藏委托类的实现，另一方面还可以实现客户与委托类之间的解耦，在不修改委托类代码的情况下能够做一些额外的处理。</p><p>在 Java 中我们有很多场景需要使用代理类，比如远程 RPC 调用的时候我们就是通过代理类去实现的，还有 Spring 的 AOP 切面中我们也是为切面生成了一个代理类等等。</p><p>代理类主要分为静态代理、JDK 动态代理和 CGLIB 动态代理，它们各有优缺点，没有最好的，存在就是有意义的，在不同的场景下它们会有不同的用武之地。</p><hr><p>本次实验代码已托管至 github：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3F1LXNoYW8vRmlsZXMvdHJlZS9tYWluL0phdmElRTQlQkIlQTMlRTclOTAlODY=">Files&#x2F;Java 代理 at main · qu-shao&#x2F;Files (github.com)<i class="fa fa-external-link-alt"></i></span></p><hr><h3 id="静态代理"><a href="# 静态代理" class="headerlink" title="静态代理"></a>静态代理 </h3><p> 静态代理的思想很简单，它要求委托类和代理类都实现了共同的接口，代理类中存在一个接口类型的属性，构建代理类的时候以构造方法的形式将委托类传入代理类，之后代理类对需要增强的方法进行重写，因为一般是对委托类的方法进行增强处理，所以在重写时除了增加的代码逻辑外往往会调用委托类的原方法。因为代理类和委托类都实现了相同的接口，所以代理类可以对委托类中所有的方法进行增强。</p><h5 id="接口定义"><a href="# 接口定义" class="headerlink" title="接口定义"></a>接口定义</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> DesignPattern.Proxy.Static;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Function</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">doFunction</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="委托类"><a href="# 委托类" class="headerlink" title="委托类"></a>委托类</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> DesignPattern.Proxy.Static;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Draw</span> <span class="keyword">implements</span> <span class="title class_">Function</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFunction</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Draw a picture!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="代理类"><a href="# 代理类" class="headerlink" title="代理类"></a>代理类</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> DesignPattern.Proxy.Static;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TimeProxy</span> <span class="keyword">implements</span> <span class="title class_">Function</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Function function;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TimeProxy</span><span class="params">(Function function)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.function = function;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFunction</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        function.doFunction();</span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(end - start);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="具体实现"><a href="# 具体实现" class="headerlink" title="具体实现"></a>具体实现</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> DesignPattern.Proxy.Static;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.sql.Time;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">TimeProxy</span>(<span class="keyword">new</span> <span class="title class_">Draw</span>()).doFunction();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>静态代理的优点在于实现简单，逻辑清晰；但是其缺点在于每有一个代理的需求，都必须重新定义一个代理类，虽然我们可以通过代理之间的嵌套组合完成复杂的代理需求（因为实现了相同的接口，所以某一个代理类完全可以作为另一个代理类的委托类，有点类似装饰器的模式），同时如果接口中的方法过多，那么每一个代理类都需要实现大量的方法（并不是每一个方法都需要被增强，其他方法也许仅需要保留原来的逻辑，但是仍然需要在代理类中进行实现）。</p><hr><h3 id="JDK 动态代理"><a href="#JDK 动态代理" class="headerlink" title="JDK 动态代理"></a>JDK 动态代理 </h3><p> 在上面的静态代理中，委托类和代理类的关系是在编译阶段就确定好的，而在一个 Java 程序运行过程中，我们首先需要将字节码加载到 JVM 从而形成运行时数据区，而字节码的来源有很多，可以是我们编译生成的，也可以是网络传输的，也可以是运行时计算的，最后一种就是动态代理的基础。在 Proxy 类中，就是运用了 ProxyGenerator.generateProxyClass 来为特定接口生成形式为 *$Proxy 的代理类的二进制字节流。所谓的动态代理就是想办法根据接口或者目标对象计算出代理类的字节码然后加载进 JVM 中。</p><h5 id="接口定义 -1"><a href="# 接口定义 -1" class="headerlink" title="接口定义"></a>接口定义</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> DesignPattern.Proxy.Dynamic;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Function</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">doFunction</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="委托类 -1"><a href="# 委托类 -1" class="headerlink" title="委托类"></a>委托类</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> DesignPattern.Proxy.Dynamic;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Draw</span> <span class="keyword">implements</span> <span class="title class_">Function</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFunction</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Draw a picture!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="具体实现 -1"><a href="# 具体实现 -1" class="headerlink" title="具体实现"></a>具体实现</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> DesignPattern.Proxy.Dynamic;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">         <span class="comment">//  设置保存中间生成的代理类</span></span><br><span class="line">        System.getProperties().put(<span class="string">&quot;jdk.proxy.ProxyGenerator.saveGeneratedFiles&quot;</span>, <span class="string">&quot;true&quot;</span>);</span><br><span class="line">        <span class="type">Draw</span> <span class="variable">draw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Draw</span>();</span><br><span class="line">        <span class="type">Function</span> <span class="variable">f</span> <span class="operator">=</span> (Function) Proxy.newProxyInstance(draw.getClass().getClassLoader(),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Function.class&#125;,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvocationHandler</span>() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;method: &quot;</span> + method.getName() + <span class="string">&quot; start... ...&quot;</span>);</span><br><span class="line">                        <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> method.invoke(draw, args);</span><br><span class="line">                        System.out.println(<span class="string">&quot;method: &quot;</span> + method.getName() + <span class="string">&quot; end!&quot;</span>);</span><br><span class="line">                        <span class="keyword">return</span> o;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">        f.doFunction();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先，Proxy 的 newProxyInstance 方法先通过传递的参数类加载器和类所实现的所有的接口，先从缓存获取代理类，如果没有再去生成一个代理类，然后进行一些安全校验，如果接口访问标识都是 public 的话，那生成的代理类都放到默认包下：com.sum.proxy；如果不是 puliic ，那么生成的代理类的包名和接口包名相同。我们对委托类的增强主要通过参入的第三个参数 InvocationHandler 实现。invoke 方法接受三个参数，第一个参数是代理类，第二个是通过反射获得的委托类中的方法，第三个则是具体每个方法传入的参数。</p><h5 id="Proxy-newProxyInstance- 源码阅读"><a href="#Proxy-newProxyInstance- 源码阅读" class="headerlink" title="Proxy.newProxyInstance 源码阅读"></a>Proxy.newProxyInstance 源码阅读</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">newProxyInstance</span><span class="params">(ClassLoader loader,</span></span><br><span class="line"><span class="params">                                          Class&lt;?&gt;[] interfaces,</span></span><br><span class="line"><span class="params">                                          InvocationHandler h)</span> &#123;</span><br><span class="line">    <span class="comment">// 检查空指针</span></span><br><span class="line">        Objects.requireNonNull(h);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    调用 Reflection.getCallerClass() 本地方法，返回调用此方法的调用方的类，忽略与 java.lang.reflect.Method.invoke（） 关联的框架及其实现。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">        <span class="keyword">final</span> Class&lt;?&gt; caller = System.getSecurityManager() == <span class="literal">null</span></span><br><span class="line">                                    ? <span class="literal">null</span></span><br><span class="line">                                    : Reflection.getCallerClass();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Look up or generate the designated proxy class and its constructor.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    <span class="comment">//  获取所有的构造器</span></span><br><span class="line">        Constructor&lt;?&gt; cons = getProxyConstructor(caller, loader, interfaces);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  返回生成的代理对象</span></span><br><span class="line">        <span class="keyword">return</span> newProxyInstance(caller, cons, h);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Object <span class="title function_">newProxyInstance</span><span class="params">(Class&lt;?&gt; caller, // <span class="literal">null</span> <span class="keyword">if</span> no SecurityManager</span></span><br><span class="line"><span class="params">                                           Constructor&lt;?&gt; cons,</span></span><br><span class="line"><span class="params">                                           InvocationHandler h)</span> &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Invoke its constructor with the designated invocation handler.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (caller != <span class="literal">null</span>) &#123;</span><br><span class="line">                checkNewProxyPermission(caller, cons.getDeclaringClass());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//  通过构造器返回生成的代理对象</span></span><br><span class="line">            <span class="keyword">return</span> cons.newInstance(<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;h&#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException | InstantiationException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InternalError</span>(e.toString(), e);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">            <span class="type">Throwable</span> <span class="variable">t</span> <span class="operator">=</span> e.getCause();</span><br><span class="line">            <span class="keyword">if</span> (t <span class="keyword">instanceof</span> RuntimeException) &#123;</span><br><span class="line">                <span class="keyword">throw</span> (RuntimeException) t;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InternalError</span>(t.toString(), t);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h5 id="最终生成代理类的方法（ProxyGenerator-generateProxyClass- 方法）"><a href="# 最终生成代理类的方法（ProxyGenerator-generateProxyClass- 方法）" class="headerlink" title="最终生成代理类的方法（ProxyGenerator.generateProxyClass()方法）"></a>最终生成代理类的方法（ProxyGenerator.generateProxyClass()方法）</h5><p>具体调用层次关系，Proxy.newProxyInstance() -&gt; getProxyConstructor() - &gt; new ProxyBuilder(ld, clv.key()).build() -&gt; defineProxyClass(module, interfaces) -&gt; ProxyGenerator.generateProxyClass(<br>                    proxyName, interfaces.toArray(EMPTY_CLASS_ARRAY), accessFlags) -&gt; generateClassFile()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">byte</span>[] generateProxyClass(<span class="keyword">final</span> String name,</span><br><span class="line">                                     Class&lt;?&gt;[] interfaces,</span><br><span class="line">                                     <span class="type">int</span> accessFlags)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">ProxyGenerator</span> <span class="variable">gen</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProxyGenerator</span>(name, interfaces, accessFlags);</span><br><span class="line">        <span class="keyword">final</span> <span class="type">byte</span>[] classFile = gen.generateClassFile();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (saveGeneratedFiles) &#123;</span><br><span class="line">            java.security.AccessController.doPrivileged(</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">java</span>.security.PrivilegedAction&lt;Void&gt;() &#123;</span><br><span class="line">                <span class="keyword">public</span> Void <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> name.lastIndexOf(<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">                        Path path;</span><br><span class="line">                        <span class="keyword">if</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="type">Path</span> <span class="variable">dir</span> <span class="operator">=</span> Path.of(name.substring(<span class="number">0</span>, i).replace(<span class="string">&#x27;.&#x27;</span>, File.separatorChar));</span><br><span class="line">                            Files.createDirectories(dir);</span><br><span class="line">                            path = dir.resolve(name.substring(i+<span class="number">1</span>, name.length()) + <span class="string">&quot;.class&quot;</span>);</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            path = Path.of(name + <span class="string">&quot;.class&quot;</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                        Files.write(path, classFile);</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InternalError</span>(</span><br><span class="line">                            <span class="string">&quot;I/O exception saving generated file: &quot;</span> + e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> classFile;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h5 id="生成的代理类的字节码文件（关键）"><a href="# 生成的代理类的字节码文件（关键）" class="headerlink" title="生成的代理类的字节码文件（关键）"></a>生成的代理类的字节码文件（关键）</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Source code recreated from a .class file by IntelliJ IDEA</span></span><br><span class="line"><span class="comment">// (powered by FernFlower decompiler)</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.sun.proxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> DesignPattern.Proxy.Dynamic.Function;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.UndeclaredThrowableException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">$Proxy0</span> <span class="keyword">extends</span> <span class="title class_">Proxy</span> <span class="keyword">implements</span> <span class="title class_">Function</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m1;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m3;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m2;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m0;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> $Proxy0(InvocationHandler var1) <span class="keyword">throws</span>  &#123;</span><br><span class="line">        <span class="built_in">super</span>(var1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object var1)</span> <span class="keyword">throws</span>  &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (Boolean)<span class="built_in">super</span>.h.invoke(<span class="built_in">this</span>, m1, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;var1&#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var3;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var4) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UndeclaredThrowableException</span>(var4);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">doFunction</span><span class="params">()</span> <span class="keyword">throws</span>  &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>.h.invoke(<span class="built_in">this</span>, m3, (Object[])<span class="literal">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var2;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UndeclaredThrowableException</span>(var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> String <span class="title function_">toString</span><span class="params">()</span> <span class="keyword">throws</span>  &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (String)<span class="built_in">super</span>.h.invoke(<span class="built_in">this</span>, m2, (Object[])<span class="literal">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var2;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UndeclaredThrowableException</span>(var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> <span class="keyword">throws</span>  &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (Integer)<span class="built_in">super</span>.h.invoke(<span class="built_in">this</span>, m0, (Object[])<span class="literal">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var2;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UndeclaredThrowableException</span>(var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            m1 = Class.forName(<span class="string">&quot;java.lang.Object&quot;</span>).getMethod(<span class="string">&quot;equals&quot;</span>, Class.forName(<span class="string">&quot;java.lang.Object&quot;</span>));</span><br><span class="line">            m3 = Class.forName(<span class="string">&quot;DesignPattern.Proxy.Dynamic.Function&quot;</span>).getMethod(<span class="string">&quot;doFunction&quot;</span>);</span><br><span class="line">            m2 = Class.forName(<span class="string">&quot;java.lang.Object&quot;</span>).getMethod(<span class="string">&quot;toString&quot;</span>);</span><br><span class="line">            m0 = Class.forName(<span class="string">&quot;java.lang.Object&quot;</span>).getMethod(<span class="string">&quot;hashCode&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchMethodError</span>(var2.getMessage());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoClassDefFoundError</span>(var3.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，代理类中每一个方法最后都是通过类似 super.h.invoke(this, m3, (Object[])null); 进行调用，而 super 即为 Proxy ，在 Proxy 中存在一个类型为 InvocationHandler 的属性 h ，通过调用该对象（h）的 invoke 方法实现对每一个方法的增强。所以对于 JDK 动态代理，不需要在编译阶段定义具体的代理类，而是在运行时动态地生成对应的代理类。但是，无论是静态代理还是动态代理，都要求委托类实现接口，因为两者都是对接口方法的实现增强。</p><hr><h3 id="CGLIB"><a href="#CGLIB" class="headerlink" title="CGLIB"></a>CGLIB</h3><p>CGLIB 代理是针对类来实现代理的，原理是对指定的委托类生成一个子类并重写其中业务方法来实现代理。代理类对象是由 Enhancer 类创建的。CGLIB 创建动态代理类的模式是:</p><ol><li>查找目标类上的所有非 final 的 public 类型的方法 (final 的不能被重写)。</li><li>将这些方法的定义转成字节码。</li><li>将组成的字节码转换成相应的代理的 Class 对象，然后通过反射获得代理类的实例对象。</li><li>实现 MethodInterceptor 接口，用来处理对代理类上所有方法的请求。</li></ol><h5 id="委托类 -2"><a href="# 委托类 -2" class="headerlink" title="委托类"></a>委托类</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> DesignPattern.Proxy.CGLIB;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Draw</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFunction</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Draw a picture!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="具体的 MethodInterceptor"><a href="# 具体的 MethodInterceptor" class="headerlink" title="具体的 MethodInterceptor"></a>具体的 MethodInterceptor</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> DesignPattern.Proxy.CGLIB;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodInterceptor;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodProxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TimeMethodInterceptor</span> <span class="keyword">implements</span> <span class="title class_">MethodInterceptor</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">intercept</span><span class="params">(Object o, Method method, Object[] objects, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Before&quot;</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> methodProxy.invokeSuper(o, objects);</span><br><span class="line">        System.out.println(<span class="string">&quot;After&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="具体实现 -2"><a href="# 具体实现 -2" class="headerlink" title="具体实现"></a>具体实现</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> DesignPattern.Proxy.CGLIB;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.Enhancer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Enhancer</span> <span class="variable">enhancer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Enhancer</span>();</span><br><span class="line">        enhancer.setSuperclass(Draw.class);</span><br><span class="line">        enhancer.setCallback(<span class="keyword">new</span> <span class="title class_">TimeMethodInterceptor</span>());</span><br><span class="line">        <span class="type">Draw</span> <span class="variable">draw</span> <span class="operator">=</span> (Draw) enhancer.create();</span><br><span class="line">        draw.doFunction();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于需要被代理的类，它只是动态生成一个子类以覆盖非 final 的方法，同时绑定钩子回调自定义的拦截器。它比 JDK 动态代理还要快；值得注意的是，我们传入目标类作为代理的父类。不同于 JDK 动态代理，我们不能使用目标对象来创建代理。目标对象只能被 CGLIB 创建。</p><hr><h3 id="JDK- 动态代理和 -CGLIB- 动态代理的区别"><a href="#JDK- 动态代理和 -CGLIB- 动态代理的区别" class="headerlink" title="JDK 动态代理和 CGLIB 动态代理的区别"></a>JDK 动态代理和 CGLIB 动态代理的区别</h3><p>JDK 动态代理基于 Java 反射机制实现，必须要实现了接口的业务类才能用这种方法生成代理对象。<br>CGLIB 动态代理基于 ASM 框架通过生成业务类的子类来实现。<br>JDK 动态代理的优势是最小化依赖关系，减少依赖意味着简化开发和维护并且有 JDK 自身支持，还可以平滑进行 JDK 版本升级，代码实现简单。基于 CGLIB 框架的优势是无须实现接口，达到代理类无侵入，我们只需操作我们关系的类，不必为其它相关类增加工作量，性能比较高。</p><hr><h3 id="总结"><a href="# 总结" class="headerlink" title="总结"></a>总结 </h3><p> 代理可以分为 “静态代理” 和 “动态代理”，动态代理又分为 “JDK 动态代理” 和 “CGLIB 动态代理” 实现。</p><p>静态代理：代理对象和实际对象都继承了同一个接口，在代理对象中指向的是实际对象的实例，这样对外暴露的是代理对象而真正调用的是 Real Object。</p><p>优点：可以很好的保护实际对象的业务逻辑对外暴露，从而提高安全性。</p><p>缺点：不同的接口要有不同的代理类实现，会很冗余。</p><hr><p>JDK 动态代理：<br>为了解决静态代理中，生成大量的代理类造成的冗余；<br>JDK 动态代理只需要实现 InvocationHandler 接口，重写 invoke 方法便可以完成代理的实现，</p><p>jdk 的代理是利用反射生成代理类 Proxyxx.class 代理类字节码，并生成对象<br>jdk 动态代理之所以只能代理接口是因为代理类本身已经 extends 了 Proxy，而 java 是不允许多重继承的，但是允许实现多个接口</p><p>优点：解决了静态代理中冗余的代理实现类问题。<br>缺点：JDK 动态代理是基于接口设计实现的，如果没有接口，会抛异常。</p><hr><p>CGLIB 代理：<br>由于 JDK 动态代理限制了只能基于接口设计，而对于没有接口的情况，JDK 方式解决不了；<br>CGLib 采用了非常底层的字节码技术，其原理是通过字节码技术为一个类创建子类，并在子类中采用方法拦截的技术拦截所有父类方法的调用，顺势织入横切逻辑，来完成动态代理的实现。<br>实现方式实现 MethodInterceptor 接口，重写 intercept 方法，通过 Enhancer 类的回调方法来实现。</p><p>但是 CGLib 在创建代理对象时所花费的时间却比 JDK 多得多，所以对于单例的对象，因为无需频繁创建对象，用 CGLib 合适，反之，使用 JDK 方式要更为合适一些。<br>同时，由于 CGLib 由于是采用动态创建子类的方法，对于 final 方法，无法进行代理。</p><p>优点：没有接口也能实现动态代理，而且采用字节码增强技术，性能也不错。<br>缺点：技术实现相对难理解些。</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
            <tag> 代理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MQ 学习笔记（三）——高级特性</title>
      <link href="/2022/1127cb1054.html"/>
      <url>/2022/1127cb1054.html</url>
      
        <content type="html"><![CDATA[<h2 id="MQ 学习笔记（三）——高级特性"><a href="#MQ 学习笔记（三）——高级特性" class="headerlink" title="MQ 学习笔记（三）——高级特性"></a>MQ 学习笔记（三）——高级特性</h2><hr><p>本次实验代码已托管至 github：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3F1LXNoYW8vRmlsZXMvdHJlZS9tYWluL1JhYmJpdE1RJUU5JUFCJTk4JUU3JUJBJUE3JUU3JTg5JUI5JUU2JTgwJUE3">Files&#x2F;RabbitMQ 高级特性 at main · qu-shao&#x2F;Files (github.com)<i class="fa fa-external-link-alt"></i></span></p><hr><p>RabbitMQ 消息投递的一般路径：</p><p>Producer -&gt; Broker -&gt; Exchange -&gt; Queuq -&gt; Consumer</p><p>本次实验主要学习使用 RabbitMQ 提供可靠性等高级特性的相关 API 和机制。</p><hr><h4 id="RabbitMQ 高级特性"><a href="#RabbitMQ 高级特性" class="headerlink" title="RabbitMQ 高级特性"></a>RabbitMQ 高级特性 </h4><h5 id="消息可靠性传递（生产者 - 中间件）"><a href="# 消息可靠性传递（生产者 - 中间件）" class="headerlink" title="消息可靠性传递（生产者 -&gt; 中间件）"></a> 消息可靠性传递（生产者 -&gt; 中间件）</h5><h6 id="确认模式（confirm）"><a href="# 确认模式（confirm）" class="headerlink" title="确认模式（confirm）"></a>确认模式（confirm）</h6><p>消息从 Producer 到 Exchange 则会返回一个 confirmCallback。</p><ol><li>首先需要在配置中设置 spring.rabbitmq.publisher-confirm-type 属性，分别有以下三个值</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">NONE</span><br><span class="line">SIMPLE</span><br><span class="line">CORRELATED</span><br></pre></td></tr></table></figure><p>NONE 值是禁用发布确认模式，是默认值</p><p>CORRELATED 值是发布消息成功到交换器后会触发回调方法</p><p>SIMPLE 值有两种效果，其一效果和 CORRELATED 值一样会触发回调方法，其二在发布消息成功后使用 rabbitTemplate 调用 waitForConfirms 或 waitForConfirmsOrDie 方法等待 broker 节点返回发送结果，根据返回结果来判定下一步的逻辑，要注意的点是 waitForConfirmsOrDie 方法如果返回 false 则会关闭 channel，则接下来无法发送消息到 broker。</p><ol start="2"><li><p>设置生产者</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReliabilityConfig</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">QUEUE_NAME</span> <span class="operator">=</span> <span class="string">&quot;test_reliability_queue&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">EXCHANGE_NAME</span> <span class="operator">=</span> <span class="string">&quot;test_reliability_queue&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(&quot;reliabilityQueue&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">reliabilityQueue</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> QueueBuilder.durable(QUEUE_NAME).build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(&quot;reliabilityExchange&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> DirectExchange <span class="title function_">reliabilityExchange</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ExchangeBuilder.directExchange(EXCHANGE_NAME).durable(<span class="literal">true</span>).build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(&quot;bindReliabilityExchange&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">bindReliabilityExchange</span><span class="params">(<span class="meta">@Qualifier(&quot;reliabilityQueue&quot;)</span> Queue queue, <span class="meta">@Qualifier(&quot;reliabilityExchange&quot;)</span> Exchange exchange)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(queue).to(exchange).with(<span class="string">&quot;reliability&quot;</span>).noargs();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>生产者设置 confirmCallback 方法</p></li><li><p>调用 RabbitTemplate 启动生产者</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testReliabilityConfirm</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;Reliability test: Confirm!&quot;</span>;</span><br><span class="line">    rabbitTemplate.setConfirmCallback(<span class="keyword">new</span> <span class="title class_">RabbitTemplate</span>.ConfirmCallback() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">confirm</span><span class="params">(CorrelationData correlationData, <span class="type">boolean</span> ack, String cause)</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;ConfirmBack 方法执行 &quot;</span>);</span><br><span class="line">            <span class="keyword">if</span>(ack)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot; 接收成功 &quot;</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                System.out.println(cause);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">   </span><br><span class="line">    rabbitTemplate.convertAndSend(ReliabilityConfig.EXCHANGE_NAME, <span class="string">&quot;reliability&quot;</span>, s);</span><br><span class="line">    Thread.sleep(<span class="number">0xc8</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h6 id="退回模式（return）"><a href="# 退回模式（return）" class="headerlink" title="退回模式（return）"></a>退回模式（return）</h6><p>消息从 Exchange 到 Queue 投递失败则会返回一个 returnCallback。</p><ol><li><p>开启回退模式（设置 publisher-returns 为 true）</p></li><li><p>设置 ReturnCallBack（编写回调方法处理逻辑）</p></li><li><p>设置 Exchange 处理消息的模式：</p><ol><li>如果消息没有路由到 Queue，则丢弃消息（默认）</li><li>如果消息没有路由到 Queue，返回给消息发送方（调用 setMandatory()方法）</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testReliabilityReturn</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;Reliability test: Return!&quot;</span>;</span><br><span class="line">    rabbitTemplate.setMandatory(<span class="literal">true</span>);</span><br><span class="line">    rabbitTemplate.setReturnsCallback(<span class="keyword">new</span> <span class="title class_">RabbitTemplate</span>.ReturnsCallback() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">returnedMessage</span><span class="params">(ReturnedMessage returned)</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;ReturnCallBack 方法执行了 &quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;Message: &quot;</span> + <span class="keyword">new</span> <span class="title class_">String</span>(returned.getMessage().getBody()));</span><br><span class="line">            System.out.println(<span class="string">&quot;ReplyCode: &quot;</span> + returned.getReplyCode());</span><br><span class="line">            System.out.println(<span class="string">&quot;ReplyText: &quot;</span> + returned.getReplyText());</span><br><span class="line">            System.out.println(<span class="string">&quot;Exchange: &quot;</span> + returned.getExchange());</span><br><span class="line">            System.out.println(<span class="string">&quot;RoutingKey: &quot;</span> + returned.getRoutingKey());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    rabbitTemplate.convertAndSend(ReliabilityConfig.EXCHANGE_NAME, <span class="string">&quot;wrongRoutingKey&quot;</span>, s);</span><br><span class="line">    Thread.sleep(<span class="number">0xc8</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>其中需要注意的是因为 confirmCallback 和 returnsCallback 都是异步方法，所以在实验中需要在发送消息后等待一段时间，否则 RabbitMQ 会因为关闭 channel 和 connection 导致后续接收不到回调。</p><hr><h5 id="Consumer-ACK（中间件 - 消费者）"><a href="#Consumer-ACK（中间件 - 消费者）" class="headerlink" title="Consumer ACK（中间件 -&gt; 消费者）"></a>Consumer ACK（中间件 -&gt; 消费者）</h5><p>表示消费端接收到消息后的确认方式。</p><p>三种确认方式：自动确认；手动确认；根据异常情况确认。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">acknowledge=<span class="string">&quot;none&quot;</span></span><br><span class="line">acknowledge=<span class="string">&quot;manual&quot;</span></span><br><span class="line">acknowledge=<span class="string">&quot;auto&quot;</span></span><br></pre></td></tr></table></figure><p>自动确认模式下，当消息一旦被 Consumer 接收到，则自动确认，并将消息从 RabbitMQ 的消息缓存中移除。但是实际业务中，很可能消息接收到，业务出现异常，那么就会导致该消息丢失；所以如果设置了手动确认方式，则需要在业务处理成功后，调用 channel.basicAck()，手动签收，如果出现异常，则调用 channel.basicNack()方法，让其自动重新发送消息。</p><ol><li>首先在配置文件中设置 Ack 模式为手动签收（默认为自动确认）<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.rabbitmq.listener.direct.acknowledge-mode=manual</span><br></pre></td></tr></table></figure></li><li>让监听器类实现 ChannelAwareMessageListener 接口，重写 onMessage 方法</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConsumerAckListener</span> <span class="keyword">implements</span> <span class="title class_">ChannelAwareMessageListener</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@RabbitListener(queues = &quot;test_reliability_queue&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onMessage</span><span class="params">(Message message, Channel channel)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">deliveryTag</span> <span class="operator">=</span> message.getMessageProperties().getDeliveryTag();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(message.getBody()));</span><br><span class="line">            System.out.println(<span class="string">&quot; 业务逻辑 &quot;</span>);</span><br><span class="line"><span class="comment">//            int i = 3/0;</span></span><br><span class="line">            channel.basicAck(deliveryTag, <span class="literal">true</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            channel.basicNack(deliveryTag, <span class="literal">true</span>, <span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>   其中，如果取消注释的代码行，在 try 中将抛出错误，则此时执行 catch 中的手动确认逻辑，让消息队列重新发送消息。</p><h5 id="消费端限流"><a href="# 消费端限流" class="headerlink" title="消费端限流"></a>消费端限流</h5><ol><li><p>设置消息确认方式为手动确认；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.rabbitmq.listener.simple.acknowledge-mode=manual</span><br></pre></td></tr></table></figure></li><li><p>设置 perfetch 属性为消费端在消息确认前可以拉取的消息数量；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.rabbitmq.listener.direct.consumers-per-queue=<span class="number">1</span></span><br></pre></td></tr></table></figure></li></ol><hr><h5 id="TTL（Time-To-Live）"><a href="#TTL（Time-To-Live）" class="headerlink" title="TTL（Time To Live）"></a>TTL（Time To Live）</h5><p>RabbitMQ 可以对消息设置过期时间，也可以对整个队列设置过期时间，如果同时设置了则以时间较短的为准。</p><p>队列过期后，会将队列所有消息移除；消息过期后，只有当消息在队列顶端（也即消息将要被消费的时候）判断该消息是否过期，过期则移除。</p><h6 id="对消息队列设置"><a href="# 对消息队列设置" class="headerlink" title="对消息队列设置"></a>对消息队列设置</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">QUEUE_NAME_TTL</span> <span class="operator">=</span> <span class="string">&quot;test_ttl_queue&quot;</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">EXCHANGE_NAME_TTL</span> <span class="operator">=</span> <span class="string">&quot;test_reliability_queue_ttl&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean(&quot;reliabilityQueueTTL&quot;)</span></span><br><span class="line">   <span class="keyword">public</span> Queue <span class="title function_">reliabilityQueueTTL</span><span class="params">()</span>&#123;</span><br><span class="line">       <span class="keyword">return</span> QueueBuilder.durable(QUEUE_NAME_TTL).ttl(<span class="number">5000</span>).build();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Bean(&quot;reliabilityTTLExchange&quot;)</span></span><br><span class="line">   <span class="keyword">public</span> DirectExchange <span class="title function_">reliabilityTTLExchange</span><span class="params">()</span>&#123;</span><br><span class="line">       <span class="keyword">return</span> ExchangeBuilder.directExchange(EXCHANGE_NAME_TTL).durable(<span class="literal">true</span>).build();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Bean(&quot;bindReliabilityTTLExchange&quot;)</span></span><br><span class="line">   <span class="keyword">public</span> Binding <span class="title function_">bindReliabilityTTLExchange</span><span class="params">(<span class="meta">@Qualifier(&quot;reliabilityQueueTTL&quot;)</span> Queue queue, <span class="meta">@Qualifier(&quot;reliabilityTTLExchange&quot;)</span> Exchange exchange)</span>&#123;</span><br><span class="line">       <span class="keyword">return</span> BindingBuilder.bind(queue).to(exchange).with(<span class="string">&quot;reliabilityTTL&quot;</span>).noargs();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>主要体现在创建队列的时候调用 ttl()方法设置，该方法传入参数为 int 类型，单位为毫秒。</p><h6 id="对消息设置"><a href="# 对消息设置" class="headerlink" title="对消息设置"></a>对消息设置</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testTTLMessage</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;Test TTL, Single Message!&quot;</span>;</span><br><span class="line">    rabbitTemplate.convertAndSend(ReliabilityConfig.EXCHANGE_NAME_TTL, <span class="string">&quot;reliabilityTTL&quot;</span>, s, <span class="keyword">new</span> <span class="title class_">MessagePostProcessor</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Message <span class="title function_">postProcessMessage</span><span class="params">(Message message)</span> <span class="keyword">throws</span> AmqpException &#123;</span><br><span class="line">            message.getMessageProperties().setExpiration(<span class="string">&quot;5000&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> message;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要体现在发送消息的时候传入一个消息后处理对象 MessagePostProcessor，在其中调用 setExpiration()方法设置，该方法传入参数为字符串类型，单位为毫秒。</p><hr><h5 id="死信队列"><a href="# 死信队列" class="headerlink" title="死信队列"></a>死信队列 </h5><p> 死信队列，DLX（Dead Letter Exchange），当消息成为 Dead Message 后，可以被重新发送到另一个交换机，这个交换机就是死信队列。</p><p>消息成为死信的三种情况：</p><ol><li>队列消息长度达到限制</li><li>消费者拒收消息，basicNack&#x2F;basicReject，并且把消息放入原目标队列，requeue&#x3D;false;</li><li>原队列存在消息过期设置，消息到达超时时间未被消费</li></ol><p>具体实现为分别设置正常队列和正常交换机、死信队列和死信交换机，将正常队列和死信交换机通过设置参数的方式绑定：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">EXCHANGE_NAME_NORMAL</span> <span class="operator">=</span> <span class="string">&quot;test_reliability_queue_normal&quot;</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">EXCHANGE_NAME_DLX</span> <span class="operator">=</span> <span class="string">&quot;test_reliability_queue_dlx&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">QUEUE_NAME_NORMAL</span> <span class="operator">=</span> <span class="string">&quot;test_reliability_queue_normal&quot;</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">QUEUE_NAME_DLX</span> <span class="operator">=</span> <span class="string">&quot;test_dlx_queue&quot;</span>;</span><br><span class="line">  </span><br><span class="line"><span class="comment">// 声明死信队列</span></span><br><span class="line">   <span class="meta">@Bean(&quot;reliabilityQueueDLX&quot;)</span></span><br><span class="line">   <span class="keyword">public</span> Queue <span class="title function_">reliabilityQueueDLX</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> QueueBuilder.durable(QUEUE_NAME_DLX).build();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 声明死信交换机</span></span><br><span class="line">   <span class="meta">@Bean(&quot;reliabilityExchangeDLX&quot;)</span></span><br><span class="line">   <span class="keyword">public</span> DirectExchange <span class="title function_">reliabilityExchangeDLX</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> ExchangeBuilder.directExchange(EXCHANGE_NAME_DLX).durable(<span class="literal">true</span>).build();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 死信队列绑定死信交换机</span></span><br><span class="line">   <span class="meta">@Bean(&quot;bindReliabilityExchangeDLX&quot;)</span></span><br><span class="line">   <span class="keyword">public</span> Binding <span class="title function_">bindReliabilityExchangeDLX</span><span class="params">(<span class="meta">@Qualifier(&quot;reliabilityQueueDLX&quot;)</span> Queue queue, <span class="meta">@Qualifier(&quot;reliabilityExchangeDLX&quot;)</span> Exchange exchange)</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> BindingBuilder.bind(queue).to(exchange).with(<span class="string">&quot;reliabilityDLX&quot;</span>).noargs();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 声明正常队列</span></span><br><span class="line">   <span class="meta">@Bean(&quot;reliabilityQueueNormal&quot;)</span></span><br><span class="line">   <span class="keyword">public</span> Queue <span class="title function_">reliabilityQueueNormal</span><span class="params">()</span> &#123;</span><br><span class="line">       Map&lt;String, Object&gt; arguments = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(<span class="number">2</span>);</span><br><span class="line">       <span class="comment">// 设置参数绑定该队列到死信交换机</span></span><br><span class="line">       arguments.put(<span class="string">&quot;x-dead-letter-exchange&quot;</span>, EXCHANGE_NAME_DLX);</span><br><span class="line">       arguments.put(<span class="string">&quot;x-dead-letter-routing-key&quot;</span>, <span class="string">&quot;reliabilityDLX&quot;</span>);</span><br><span class="line">       <span class="keyword">return</span> QueueBuilder.durable(QUEUE_NAME_NORMAL).ttl(<span class="number">5000</span>).withArguments(arguments).build();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 声明正常交换机</span></span><br><span class="line">   <span class="meta">@Bean(&quot;reliabilityExchangeNormal&quot;)</span></span><br><span class="line">   <span class="keyword">public</span> DirectExchange <span class="title function_">reliabilityExchangeNormal</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> ExchangeBuilder.directExchange(EXCHANGE_NAME_NORMAL).durable(<span class="literal">true</span>).build();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 正常队列绑定正常交换机</span></span><br><span class="line">   <span class="meta">@Bean(&quot;bindReliabilityExchangeNormal&quot;)</span></span><br><span class="line">   <span class="keyword">public</span> Binding <span class="title function_">bindReliabilityExchangeNormal</span><span class="params">(<span class="meta">@Qualifier(&quot;reliabilityQueueNormal&quot;)</span> Queue queue, <span class="meta">@Qualifier(&quot;reliabilityExchangeNormal&quot;)</span> Exchange exchange)</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> BindingBuilder.bind(queue).to(exchange).with(<span class="string">&quot;reliabilitynormal&quot;</span>).noargs();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>实际测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testDLX</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;Test DLX, Message!&quot;</span>;</span><br><span class="line">        rabbitTemplate.convertAndSend(ReliabilityConfig.EXCHANGE_NAME_NORMAL, <span class="string">&quot;reliabilitynormal&quot;</span>, s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中将正常队列同死信交换机绑定并且设置正常队列过期时间为 5 秒钟，过期后消息便会通过死信交换机发送到死信队列。</p><hr><h5 id="延迟队列"><a href="# 延迟队列" class="headerlink" title="延迟队列"></a>延迟队列 </h5><p> 延迟队列，即消息进入队列后不会被立即消费，只有到达指定时间后，才会被消费。</p><p>虽然 RabbitMQ 中没有提供延迟队列的功能，但是可以通过 TTL 和死信队列组合实现延迟队列的效果。</p><hr><h5 id="日志与监控"><a href="# 日志与监控" class="headerlink" title="日志与监控"></a>日志与监控</h5><p>RabbitMQ 默认日志存放路径： &#x2F;var&#x2F;log&#x2F;rabbitmq&#x2F;<span class="exturl" data-url="bWFpbHRvOiYjeDcyOyYjeDYxOyYjOTg7JiN4NjI7JiN4Njk7JiN4NzQ7JiM2NDsmIzEyMDsmIzEyMDsmI3g3ODsmIzQ2OyYjMTA4OyYjMTExOyYjeDY3Ow==">&#x72;&#x61;&#98;&#x62;&#x69;&#x74;&#64;&#120;&#120;&#x78;&#46;&#108;&#111;&#x67;<i class="fa fa-external-link-alt"></i></span></p><p>rabbitmqctl 管理和监控命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">查看队列 </span><br><span class="line">rabbitmqctl list_queues</span><br><span class="line"></span><br><span class="line"> 查看 exchanges</span><br><span class="line">rabbitmqctl list_exchanges</span><br><span class="line"></span><br><span class="line">查看用户 </span><br><span class="line">rabbitmqctl list_users</span><br><span class="line"></span><br><span class="line"> 查看连接 </span><br><span class="line">rabbitmqctl list_connections</span><br><span class="line"></span><br><span class="line"> 查看消费者信息 </span><br><span class="line">rabbitmqctl list_consumers</span><br><span class="line"></span><br><span class="line"> 查看环境变量 </span><br><span class="line">rabbitmqctl environment</span><br><span class="line"></span><br><span class="line"> 查看未被确认的队列 </span><br><span class="line">rabbitmqctl list_queues name messages_unacknowlegded</span><br><span class="line"></span><br><span class="line"> 查看单个队列的内存使用情况 </span><br><span class="line">rabbitmqctl list_queues name memory</span><br><span class="line"></span><br><span class="line"> 查看准备就绪的队列</span><br><span class="line">rabbitmqctl list_queues name messages_ready</span><br></pre></td></tr></table></figure><hr><h5 id="消息可靠性分析与追踪"><a href="# 消息可靠性分析与追踪" class="headerlink" title="消息可靠性分析与追踪"></a>消息可靠性分析与追踪 </h5><p> 在 RabbitMQ 中可以使用 Firehose 和 rabbitmq_tracing 插件功能来实现消息追踪</p><p>Firehose</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl trace_on</span><br><span class="line"></span><br><span class="line">rabbitmqctl trace_off</span><br></pre></td></tr></table></figure><p>开启后 rabbitmq 会自动生成一个默认的交换机 amq.rabbitmq.trace ，它是一个 topic 类型的 exchange，发送到这个 exchange 上的消息的 routingKey 为 publish.exchangename 和 deliver.queuename ，其中 exchangename  和 queuename 为实际 exchange 和 queue 的名称，分别对应生产者投递到 exchange 的消息，和消费者从 queue 上获取的消息。 但是打开 trace 功能会影响消息写入。</p><hr><h4 id="RabbitMQ 应用"><a href="#RabbitMQ 应用" class="headerlink" title="RabbitMQ 应用"></a>RabbitMQ 应用 </h4><h5 id="消息可靠性保障（消息补偿机制）"><a href="# 消息可靠性保障（消息补偿机制）" class="headerlink" title="消息可靠性保障（消息补偿机制）"></a> 消息可靠性保障（消息补偿机制）</h5><p>主要是一种冗余和延时确认的设计思路：</p><ol><li>生产者在发送消息前先对消息进行本地的入库</li><li>生产者正常发送一条消息</li><li>在 2 的基础之上生产者将延迟发送同一条消息至另一个队列</li><li>正常情况下消费者监听队列并进行 2 中发送的消息的消费</li><li>消费者处理完业务逻辑后临时充当生产者的角色向一个中间队列发送一条确认消费的消息</li><li>中间队列将消费者发送来的消息进行回调检查处理</li><li>如果消息之前未被消费，则将消息写入统计消息情况的数据库中</li><li>在 3 中收到的延迟消息，回调检查同样进行监听，如果延迟消息之前未被记录在统计消息情况的数据库中，则此时消息的发送出现了丢失，这是需要调用生产者重新发送一遍相同的消息；如果已经被记录，则之前的消息发送一切正常，此时消费掉延迟队列中的该消息即可（有点类似两阶段提交）</li><li>但以上解决方案存在一个问题，就是延迟队列中判断补偿的消息也有可能发生丢失，所以系统会定时检查 1 中本地入库的消息和统计消息情况的数据库的情况，将其中缺失的消息进行重新发送（一定是本地消息的数量大于统计消息消费情况的数据库中的数量）</li></ol><p><img data-src="/images/MQ(%E4%B8%89).png"></p><hr><h5 id="消息幂等性处理（乐观锁解决方案）"><a href="# 消息幂等性处理（乐观锁解决方案）" class="headerlink" title="消息幂等性处理（乐观锁解决方案）"></a>消息幂等性处理（乐观锁解决方案）</h5><p>幂等性指的是一次和多次请求某一个资源，对于资源本身应该具有同样的结果。也就是说，其任意多次执行对资源本身所产生的影响均和一次执行的影响相同。通过需要保障幂等性的消息一般是修改操作。（常见于 http 请求 get&#x2F;post）</p><p>在 MQ 中，消费多条相同的消息，应该得到消费该条消息一次的结果一致。</p><p>具体的解决方案有很多种，可以通过在数据库中添加版本机制，丢弃掉重复修改的消息；或者对于每一条消息，设置全局唯一的 ID，在消息数据库中（redis 或者其他结构）进行记录，以此判断消息是否已经被执行。</p><hr>]]></content>
      
      
      <categories>
          
          <category> RabbitMQ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RabbitMQ </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MQ 学习笔记（二）——SpringBoot 使用 RabbitMQ</title>
      <link href="/2022/10d4a12321.html"/>
      <url>/2022/10d4a12321.html</url>
      
        <content type="html"><![CDATA[<h2 id="MQ 学习笔记（二）——SpringBoot 使用 RabbitMQ"><a href="#MQ 学习笔记（二）——SpringBoot 使用 RabbitMQ" class="headerlink" title="MQ 学习笔记（二）——SpringBoot 使用 RabbitMQ"></a>MQ 学习笔记（二）——SpringBoot 使用 RabbitMQ</h2><hr><p>本次实验代码已托管至 github：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3F1LXNoYW8vRmlsZXMvdHJlZS9tYWluL1NwcmluZ0Jvb3QlRTQlQkQlQkYlRTclOTQlQThSYWJiaXRNUQ==">Files&#x2F;SpringBoot 使用 RabbitMQ at main · qu-shao&#x2F;Files (github.com)<i class="fa fa-external-link-alt"></i></span></p><p>具体运行方式为运行测试类 SpringbootRabbitmqApplicationTests，生产者生产消息</p><p>运行 SpringBoot 启动类 SpringbootRabbitmqApplication 注册消费者监听队列</p><hr><p>SpringBoot 整合 RabbitMQ 主要步骤：</p><ol><li><p>引入 SpringBoot 依赖</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li><li><p>编写 yml 配置，主要是端口、host、用户、密码、虚拟机等配置</p></li><li><p>定义交换机、队列以及绑定关系的配置类</p></li><li><p>注入 RabbitTemplate，调用方法，完成消息发送（生产者）</p></li><li><p>定义监听类，使用 @RabbitListener 注解完成队列监听</p><hr></li></ol><h5 id="简单模式（经典模式）："><a href="# 简单模式（经典模式）：" class="headerlink" title="简单模式（经典模式）："></a>简单模式（经典模式）：</h5><h6 id="生产者："><a href="# 生产者：" class="headerlink" title="生产者："></a>生产者：</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleRabbitMQConfig</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">QUEUE_NAME</span> <span class="operator">=</span> <span class="string">&quot;boot_simple_queue&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(&quot;bootSimpleQueue&quot;)</span></span><br><span class="line">    Queue <span class="title function_">bootSimpleQueue</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> QueueBuilder.durable(QUEUE_NAME).build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="消费者"><a href="# 消费者" class="headerlink" title="消费者"></a>消费者</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(queues = &quot;boot_simple_queue&quot;)</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">SimpleListener</span><span class="params">(Message message)</span> &#123;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="type">BufferedWriter</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(<span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;result.txt&quot;</span>, <span class="literal">true</span>));</span><br><span class="line">           out.write(<span class="string">&quot;Simple mode : &quot;</span> + <span class="keyword">new</span> <span class="title class_">String</span>(message.getBody()) + <span class="string">&quot;\n&quot;</span>);</span><br><span class="line">           out.close();</span><br><span class="line">       &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><hr><h5 id="Work-Queue 工作队列模式"><a href="#Work-Queue 工作队列模式" class="headerlink" title="Work Queue 工作队列模式"></a>Work Queue 工作队列模式 </h5><h6 id="生产者"><a href="# 生产者" class="headerlink" title="生产者"></a> 生产者</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WorkRabbitMQConfig</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">QUEUE_NAME</span> <span class="operator">=</span> <span class="string">&quot;boot_work_queue&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(&quot;bootWorkQueueOne&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">bootWorkQueueOne</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> QueueBuilder.durable(QUEUE_NAME).build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="消费者 -1"><a href="# 消费者 -1" class="headerlink" title="消费者"></a>消费者</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(queues = &quot;boot_work_queue&quot;)</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">WorkListenerOne</span><span class="params">(Message message)</span> &#123;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="type">BufferedWriter</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(<span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;result.txt&quot;</span>, <span class="literal">true</span>));</span><br><span class="line">           out.write(<span class="string">&quot;Work mode, by consumer one : &quot;</span> + <span class="keyword">new</span> <span class="title class_">String</span>(message.getBody()) + <span class="string">&quot;\n&quot;</span>);</span><br><span class="line">           out.close();</span><br><span class="line">       &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@RabbitListener(queues = &quot;boot_work_queue&quot;)</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">WorkListenerTwo</span><span class="params">(Message message)</span> &#123;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="type">BufferedWriter</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(<span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;result.txt&quot;</span>, <span class="literal">true</span>));</span><br><span class="line">           out.write(<span class="string">&quot;Work mode, by consumer two : &quot;</span> + <span class="keyword">new</span> <span class="title class_">String</span>(message.getBody()) + <span class="string">&quot;\n&quot;</span>);</span><br><span class="line">           out.close();</span><br><span class="line">       &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><hr><h5 id="Pub-Sub- 发布 - 订阅模式（Fanout 分发）"><a href="#Pub-Sub- 发布 - 订阅模式（Fanout 分发）" class="headerlink" title="Pub&#x2F;Sub 发布 &#x2F; 订阅模式（Fanout 分发）"></a>Pub&#x2F;Sub 发布 &#x2F; 订阅模式（Fanout 分发）</h5><h6 id="生产者 -1"><a href="# 生产者 -1" class="headerlink" title="生产者"></a>生产者</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PubSubRabbitMQConfig</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">EXCHANGE_NAME</span> <span class="operator">=</span> <span class="string">&quot;boot_pubsub_exchange&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">QUEUE_NAME_ONE</span> <span class="operator">=</span> <span class="string">&quot;boot_pubsub_queue_one&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">QUEUE_NAME_TWO</span> <span class="operator">=</span> <span class="string">&quot;boot_pubsub_queue_two&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(&quot;bootPubSubExchange&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Exchange <span class="title function_">bootPubSubExchange</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ExchangeBuilder.fanoutExchange(EXCHANGE_NAME).durable(<span class="literal">true</span>).build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(&quot;bootPubSubQueueOne&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">bootPubSubQueueOne</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> QueueBuilder.durable(QUEUE_NAME_ONE).build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(&quot;bootPubSubQueueTwo&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">bootPubSubQueueTwo</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> QueueBuilder.durable(QUEUE_NAME_TWO).build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(&quot;bindPubSubQueueOne&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">bindPubSubQueueOne</span><span class="params">(<span class="meta">@Qualifier(&quot;bootPubSubQueueOne&quot;)</span> Queue queue, <span class="meta">@Qualifier(&quot;bootPubSubExchange&quot;)</span> Exchange exchange)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(queue).to(exchange).with(<span class="string">&quot;&quot;</span>).noargs();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(&quot;bindPubSubQueueTwo&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">bindPubSubQueueTwo</span><span class="params">(<span class="meta">@Qualifier(&quot;bootPubSubQueueTwo&quot;)</span> Queue queue, <span class="meta">@Qualifier(&quot;bootPubSubExchange&quot;)</span> Exchange exchange)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(queue).to(exchange).with(<span class="string">&quot;&quot;</span>).noargs();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="消费者 -2"><a href="# 消费者 -2" class="headerlink" title="消费者"></a>消费者</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(queues = &quot;boot_pubsub_queue_one&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">PubSubListenerOne</span><span class="params">(Message message)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">BufferedWriter</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(<span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;result.txt&quot;</span>, <span class="literal">true</span>));</span><br><span class="line">        out.write(<span class="string">&quot;PubSub mode, by consumer one : &quot;</span> + <span class="keyword">new</span> <span class="title class_">String</span>(message.getBody()) + <span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        out.close();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RabbitListener(queues = &quot;boot_pubsub_queue_two&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">PubSubListenerTwo</span><span class="params">(Message message)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">BufferedWriter</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(<span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;result.txt&quot;</span>, <span class="literal">true</span>));</span><br><span class="line">        out.write(<span class="string">&quot;PubSub mode, by consumer two : &quot;</span> + <span class="keyword">new</span> <span class="title class_">String</span>(message.getBody()) + <span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        out.close();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h5 id="Routing（路由模式）"><a href="#Routing（路由模式）" class="headerlink" title="Routing（路由模式）"></a>Routing（路由模式）</h5><h6 id="生产者 -2"><a href="# 生产者 -2" class="headerlink" title="生产者"></a>生产者</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RoutingRabbitMQConfig</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">EXCHANGE_NAME</span> <span class="operator">=</span> <span class="string">&quot;boot_routing_exchange&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">QUEUE_NAME_ONE</span> <span class="operator">=</span> <span class="string">&quot;boot_routing_queue_one&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">QUEUE_NAME_TWO</span> <span class="operator">=</span> <span class="string">&quot;boot_routing_queue_two&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(&quot;bootRoutingExchange&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Exchange <span class="title function_">bootRoutingExchange</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ExchangeBuilder.directExchange(EXCHANGE_NAME).durable(<span class="literal">true</span>).build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(&quot;bootRoutingQueueOne&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">bootRoutingQueueOne</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> QueueBuilder.durable(QUEUE_NAME_ONE).build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(&quot;bootRoutingQueueTwo&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">bootRoutingQueueTwo</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> QueueBuilder.durable(QUEUE_NAME_TWO).build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(&quot;bindRoutingExchangeErrorToOne&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">bindRoutingExchangeErrorToOne</span><span class="params">(<span class="meta">@Qualifier(&quot;bootRoutingQueueOne&quot;)</span> Queue queue, <span class="meta">@Qualifier(&quot;bootRoutingExchange&quot;)</span> Exchange exchange)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(queue).to(exchange).with(<span class="string">&quot;error&quot;</span>).noargs();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(&quot;bindRoutingExchangeInfoToTwo&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">bindRoutingExchangeInfoToTwo</span><span class="params">(<span class="meta">@Qualifier(&quot;bootRoutingQueueTwo&quot;)</span> Queue queue, <span class="meta">@Qualifier(&quot;bootRoutingExchange&quot;)</span> Exchange exchange)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(queue).to(exchange).with(<span class="string">&quot;info&quot;</span>).noargs();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(&quot;bindRoutingExchangeErrorToTwo&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">bindRoutingExchangeErrorToTwo</span><span class="params">(<span class="meta">@Qualifier(&quot;bootRoutingQueueTwo&quot;)</span> Queue queue, <span class="meta">@Qualifier(&quot;bootRoutingExchange&quot;)</span> Exchange exchange)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(queue).to(exchange).with(<span class="string">&quot;error&quot;</span>).noargs();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(&quot;bindRoutingExchangeWarningToTwo&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">bindRoutingExchangeWarningToTwo</span><span class="params">(<span class="meta">@Qualifier(&quot;bootRoutingQueueTwo&quot;)</span> Queue queue, <span class="meta">@Qualifier(&quot;bootRoutingExchange&quot;)</span> Exchange exchange)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(queue).to(exchange).with(<span class="string">&quot;warning&quot;</span>).noargs();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="消费者 -3"><a href="# 消费者 -3" class="headerlink" title="消费者"></a>消费者</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(queues = &quot;boot_routing_queue_one&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">RoutingListenerOne</span><span class="params">(Message message)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">BufferedWriter</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(<span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;result.txt&quot;</span>, <span class="literal">true</span>));</span><br><span class="line">        out.write(<span class="string">&quot;Routing mode, by consumer one : &quot;</span> + <span class="keyword">new</span> <span class="title class_">String</span>(message.getBody()) + <span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        out.close();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RabbitListener(queues = &quot;boot_routing_queue_two&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">RoutingListenerTwo</span><span class="params">(Message message)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">BufferedWriter</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(<span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;result.txt&quot;</span>, <span class="literal">true</span>));</span><br><span class="line">        out.write(<span class="string">&quot;Routing mode, by consumer two : &quot;</span> + <span class="keyword">new</span> <span class="title class_">String</span>(message.getBody()) + <span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        out.close();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h5 id="Topics 通配符模式（主题模式）"><a href="#Topics 通配符模式（主题模式）" class="headerlink" title="Topics 通配符模式（主题模式）"></a>Topics 通配符模式（主题模式）</h5><h6 id="生产者 -3"><a href="# 生产者 -3" class="headerlink" title="生产者"></a>生产者</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TopicsRabbitMQConfig</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">EXCHANGE_NAME</span> <span class="operator">=</span> <span class="string">&quot;boot_topic_exchange&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">QUEUE_NAME_ONE</span> <span class="operator">=</span> <span class="string">&quot;boot_topic_queue_one&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">QUEUE_NAME_TWO</span> <span class="operator">=</span> <span class="string">&quot;boot_topic_queue_two&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(&quot;bootTopicExchange&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Exchange <span class="title function_">bootTopicExchange</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ExchangeBuilder.topicExchange(EXCHANGE_NAME).durable(<span class="literal">true</span>).build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(&quot;bootTopicQueueOne&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">bootTopicQueueOne</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> QueueBuilder.durable(QUEUE_NAME_ONE).build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(&quot;bootTopicQueueTwo&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">bootTopicQueueTwo</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> QueueBuilder.durable(QUEUE_NAME_TWO).build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(&quot;bindTopicExchangeOne&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">bindTopicExchangeOne</span><span class="params">(<span class="meta">@Qualifier(&quot;bootTopicQueueOne&quot;)</span> Queue queue, <span class="meta">@Qualifier(&quot;bootTopicExchange&quot;)</span> Exchange exchange)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(queue).to(exchange).with(<span class="string">&quot;*.orange.*&quot;</span>).noargs();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(&quot;bindTopicExchangeTwo&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">bindTopicExchangeTwo</span><span class="params">(<span class="meta">@Qualifier(&quot;bootTopicQueueTwo&quot;)</span> Queue queue, <span class="meta">@Qualifier(&quot;bootTopicExchange&quot;)</span> Exchange exchange)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(queue).to(exchange).with(<span class="string">&quot;*.*.rabbit&quot;</span>).noargs();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(&quot;bindTopicExchangeThree&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">bindTopicExchangeThree</span><span class="params">(<span class="meta">@Qualifier(&quot;bootTopicQueueTwo&quot;)</span> Queue queue, <span class="meta">@Qualifier(&quot;bootTopicExchange&quot;)</span> Exchange exchange)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(queue).to(exchange).with(<span class="string">&quot;lazy.#&quot;</span>).noargs();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="消费者 -4"><a href="# 消费者 -4" class="headerlink" title="消费者"></a>消费者</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(queues = &quot;boot_topic_queue_one&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">TopicsListenerOne</span><span class="params">(Message message)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">BufferedWriter</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(<span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;result.txt&quot;</span>, <span class="literal">true</span>));</span><br><span class="line">        out.write(<span class="string">&quot;Topic mode, by consumer one : &quot;</span> + <span class="keyword">new</span> <span class="title class_">String</span>(message.getBody()) + <span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        out.close();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RabbitListener(queues = &quot;boot_topic_queue_two&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">TopicsListenerTwo</span><span class="params">(Message message)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">BufferedWriter</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(<span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;result.txt&quot;</span>, <span class="literal">true</span>));</span><br><span class="line">        out.write(<span class="string">&quot;Topic mode, by consumer two : &quot;</span> + <span class="keyword">new</span> <span class="title class_">String</span>(message.getBody()) + <span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        out.close();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><strong>总结：</strong>同原生的 Java 使用方式相比，SpringBoot 首先是使用配置以及注入的方式去创建 connection。</p><p>对于生产者，主要是通过提供的各个 “Builder” 类中的静态方法创建交换机、队列等 Bean 对象并进行具体的绑定（通过调用方法设置），在需要使用时通过 RabbitTemplate 模板类的 convertAndSend 方法进行消息的生产发送；对于消费者，只需要使用 @RabbitListener 注解，并在其中设置 queues 属性进行队列监听的绑定即可。</p>]]></content>
      
      
      <categories>
          
          <category> RabbitMQ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RabbitMQ </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MQ 学习笔记（一）——原生 Java 使用 RabbitMQ</title>
      <link href="/2022/107d1b5fb3.html"/>
      <url>/2022/107d1b5fb3.html</url>
      
        <content type="html"><![CDATA[<h2 id="MQ 学习笔记（一）——原生 Java 使用 RabbitMQ"><a href="#MQ 学习笔记（一）——原生 Java 使用 RabbitMQ" class="headerlink" title="MQ 学习笔记（一）——原生 Java 使用 RabbitMQ"></a>MQ 学习笔记（一）——原生 Java 使用 RabbitMQ</h2><hr><h5 id="基本概念："><a href="# 基本概念：" class="headerlink" title="基本概念："></a> 基本概念：</h5><p>MQ 的优点：应用解耦；异步加速；削峰填谷 </p><p>MQ 的缺点：系统可用性降低；系统复杂性提高；数据一致性问题 </p><p> 使用 MQ 的条件：生产者不需要从消费者处获得反馈，引入消息队列之前的直接调用，其接口的返回值应该为空，明明下层的动作还没做，上层却可以继续往后执行，即满足异步的条件；允许短暂的数据不一致；使用前后效果确实变得更好了。</p><p>RabbitMQ 六种工作模式：简单模式；work queues；发布 &#x2F; 订阅模式；路由模式；主题模式；远程调用模式。</p><p> 以下是使用 Java 原生方式进行不同模式的消息队列的使用方式，其中对于连接的获取以及 channel 的创建各种模式下都是通用的，各种模式的区别主要体现在对消息的分发策略上。</p><hr><p>RabbitMQ 在腾讯云上部署，博客中以本地回送地址代替服务器 IP，本次实验代码已托管至 github：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3F1LXNoYW8vRmlsZXMvdHJlZS9tYWluL1JhYmJpdE1RJUU1JThFJTlGJUU3JTk0JTlGSmF2YSVFNCVCRCVCRiVFNyU5NCVBOA==">Files&#x2F;RabbitMQ 原生 Java 使用 at main · qu-shao&#x2F;Files (github.com)<i class="fa fa-external-link-alt"></i></span></p><hr><p><img data-src="/images/MQ%EF%BC%88%E4%B8%80%EF%BC%89%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84.png"></p><h5 id="简单模式（经典模式）："><a href="# 简单模式（经典模式）：" class="headerlink" title="简单模式（经典模式）："></a> 简单模式（经典模式）：</h5><p><img data-src="/images/MQ%EF%BC%88%E4%B8%80%EF%BC%89%E7%BB%8F%E5%85%B8%E6%A8%A1%E5%BC%8F.png"></p><h6 id="生产者："><a href="# 生产者：" class="headerlink" title="生产者："></a> 生产者：</h6><ol><li><p> 创建连接工厂 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ConnectionFactory</span> <span class="variable">connectionFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionFactory</span>();</span><br></pre></td></tr></table></figure></li><li><p> 设置参数 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">connectionFactory.setHost(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line">connectionFactory.setPort(<span class="number">5672</span>);</span><br><span class="line">connectionFactory.setVirtualHost(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">connectionFactory.setUsername(<span class="string">&quot;admin&quot;</span>);</span><br><span class="line">connectionFactory.setPassword(<span class="string">&quot;admin&quot;</span>);</span><br></pre></td></tr></table></figure></li><li><p> 创建连接 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> connectionFactory.newConnection();</span><br></pre></td></tr></table></figure></li><li><p> 创建 channel</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br></pre></td></tr></table></figure></li><li><p> 创建队列 Queue</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">channel.queueDeclare(<span class="string">&quot;helloWorld&quot;</span>, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> AMQP.Queue.DeclareOk <span class="title function_">queueDeclare</span><span class="params">(String queue, <span class="type">boolean</span> durable, <span class="type">boolean</span> exclusive, <span class="type">boolean</span> autoDelete, Map&lt;String, Object&gt; arguments)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        AMQP.Queue.<span class="type">DeclareOk</span> <span class="variable">ok</span> <span class="operator">=</span> <span class="built_in">this</span>.delegate.queueDeclare(queue, durable, exclusive, autoDelete, arguments);</span><br><span class="line">        <span class="built_in">this</span>.recordQueue(ok, queue, durable, exclusive, autoDelete, arguments);</span><br><span class="line">        <span class="keyword">return</span> ok;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p> 其中，由源码可以看到每个参数的含义：</p><ol><li>queue：队列名称，如果已经存在则不会创建 </li><li>durable：是否持久化 </li><li>exclusive：是否独占，只能有一个消费者监听这个队列，当 Connection 关闭时，是否删除队列 </li><li>autoDelete：当没有 Consumer 时，是否自动删除 </li><li>arguments：其他配置参数 </li></ol></li><li><p> 发送（生产）消息 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">body</span> <span class="operator">=</span> <span class="string">&quot; 我生产了一条消息 &quot;</span>;</span><br><span class="line">channel.basicPublish(<span class="string">&quot;&quot;</span>, <span class="string">&quot;helloWorld&quot;</span>, <span class="literal">null</span>, body.getBytes());</span><br></pre></td></tr></table></figure></li><li><p> 关闭资源 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">channel.close();</span><br><span class="line">connection.close();</span><br></pre></td></tr></table></figure></li></ol><h6 id="消费者"><a href="# 消费者" class="headerlink" title="消费者"></a> 消费者 </h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException &#123;</span><br><span class="line">        <span class="type">ConnectionFactory</span> <span class="variable">connectionFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionFactory</span>();</span><br><span class="line">        connectionFactory.setHost(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line">        connectionFactory.setPort(<span class="number">5672</span>);</span><br><span class="line">        connectionFactory.setVirtualHost(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">        connectionFactory.setUsername(<span class="string">&quot;admin&quot;</span>);</span><br><span class="line">        connectionFactory.setPassword(<span class="string">&quot;admin&quot;</span>);</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> connectionFactory.newConnection();</span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line">        channel.queueDeclare(<span class="string">&quot;helloWorld&quot;</span>, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line">        <span class="type">Consumer</span> <span class="variable">consumer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultConsumer</span>(channel)&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="type">byte</span>[] body)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;consumerTag :&quot;</span> + consumerTag);</span><br><span class="line">                System.out.println(<span class="string">&quot;body :&quot;</span> + <span class="keyword">new</span> <span class="title class_">String</span>(body));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        channel.basicConsume(<span class="string">&quot;helloWorld&quot;</span>, <span class="literal">true</span>, consumer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 消费者整体逻辑和生产者类似，但是需要注意的是一般消费者是以监听的形式访问队列，所以不需要在消费后释放资源，具体情况需要看实际业务场景。</p><hr><h5 id="Work-Queue 工作队列模式"><a href="#Work-Queue 工作队列模式" class="headerlink" title="Work Queue 工作队列模式"></a>Work Queue 工作队列模式 </h5><p><img data-src="/images/MQ%EF%BC%88%E4%B8%80%EF%BC%89%E5%B7%A5%E4%BD%9C%E9%98%9F%E5%88%97.png"></p><h6 id="生产者"><a href="# 生产者" class="headerlink" title="生产者"></a> 生产者 </h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException &#123;</span><br><span class="line">        <span class="type">ConnectionFactory</span> <span class="variable">connectionFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionFactory</span>();</span><br><span class="line">        connectionFactory.setHost(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line">        connectionFactory.setPort(<span class="number">5672</span>);</span><br><span class="line">        connectionFactory.setVirtualHost(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">        connectionFactory.setUsername(<span class="string">&quot;admin&quot;</span>);</span><br><span class="line">        connectionFactory.setPassword(<span class="string">&quot;admin&quot;</span>);</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> connectionFactory.newConnection();</span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line">        channel.queueDeclare(<span class="string">&quot;workQueue&quot;</span>, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">body</span> <span class="operator">=</span> i + <span class="string">&quot; Work Queue!&quot;</span>;</span><br><span class="line">            channel.basicPublish(<span class="string">&quot;&quot;</span>, <span class="string">&quot;workQueue&quot;</span>, <span class="literal">null</span>, body.getBytes());</span><br><span class="line">        &#125;</span><br><span class="line">        channel.close();</span><br><span class="line">        connection.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 整体逻辑和经典模式基本一致。</p><h6 id="消费者 -1"><a href="# 消费者 -1" class="headerlink" title="消费者"></a> 消费者 </h6><p>consumer1</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Consumer_WorkQueue1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException &#123;</span><br><span class="line">        <span class="type">ConnectionFactory</span> <span class="variable">connectionFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionFactory</span>();</span><br><span class="line">        connectionFactory.setHost(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line">        connectionFactory.setPort(<span class="number">5672</span>);</span><br><span class="line">        connectionFactory.setVirtualHost(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">        connectionFactory.setUsername(<span class="string">&quot;admin&quot;</span>);</span><br><span class="line">        connectionFactory.setPassword(<span class="string">&quot;admin&quot;</span>);</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> connectionFactory.newConnection();</span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line">        channel.queueDeclare(<span class="string">&quot;workQueue&quot;</span>, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line">        <span class="type">Consumer</span> <span class="variable">consumer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultConsumer</span>(channel)&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="type">byte</span>[] body)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Work Queue 1 :&quot;</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;consumerTag :&quot;</span> + consumerTag);</span><br><span class="line">                System.out.println(<span class="string">&quot;body :&quot;</span> + <span class="keyword">new</span> <span class="title class_">String</span>(body));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        channel.basicConsume(<span class="string">&quot;workQueue&quot;</span>, <span class="literal">true</span>, consumer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>consumer2</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Consumer_WorkQueue2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException &#123;</span><br><span class="line">        <span class="type">ConnectionFactory</span> <span class="variable">connectionFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionFactory</span>();</span><br><span class="line">        connectionFactory.setHost(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line">        connectionFactory.setPort(<span class="number">5672</span>);</span><br><span class="line">        connectionFactory.setVirtualHost(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">        connectionFactory.setUsername(<span class="string">&quot;admin&quot;</span>);</span><br><span class="line">        connectionFactory.setPassword(<span class="string">&quot;admin&quot;</span>);</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> connectionFactory.newConnection();</span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line">        channel.queueDeclare(<span class="string">&quot;workQueue&quot;</span>, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line">        <span class="type">Consumer</span> <span class="variable">consumer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultConsumer</span>(channel)&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="type">byte</span>[] body)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Work Queue 2 :&quot;</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;consumerTag :&quot;</span> + consumerTag);</span><br><span class="line">                System.out.println(<span class="string">&quot;body :&quot;</span> + <span class="keyword">new</span> <span class="title class_">String</span>(body));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        channel.basicConsume(<span class="string">&quot;workQueue&quot;</span>, <span class="literal">true</span>, consumer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 多个消费者对于同一个消息之间是竞争关系，也即同一条消息只能被一个 consumer 消费。</p><hr><h5 id="Pub-Sub- 发布 - 订阅模式（Fanout 分发）"><a href="#Pub-Sub- 发布 - 订阅模式（Fanout 分发）" class="headerlink" title="Pub&#x2F;Sub 发布 &#x2F; 订阅模式（Fanout 分发）"></a>Pub&#x2F;Sub 发布 &#x2F; 订阅模式（Fanout 分发）</h5><p><img data-src="/images/MQ%EF%BC%88%E4%B8%80%EF%BC%89%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85.png"></p><h6 id="生产者 -1"><a href="# 生产者 -1" class="headerlink" title="生产者"></a> 生产者 </h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Producer_PubSub</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException &#123;</span><br><span class="line">        <span class="comment">//  1. 创建连接工厂 </span></span><br><span class="line">        <span class="type">ConnectionFactory</span> <span class="variable">connectionFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionFactory</span>();</span><br><span class="line">        <span class="comment">//  2. 设置参数 </span></span><br><span class="line">        connectionFactory.setHost(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line">        connectionFactory.setPort(<span class="number">5672</span>);</span><br><span class="line">        connectionFactory.setVirtualHost(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">        connectionFactory.setUsername(<span class="string">&quot;admin&quot;</span>);</span><br><span class="line">        connectionFactory.setPassword(<span class="string">&quot;admin&quot;</span>);</span><br><span class="line">        <span class="comment">//  3. 创建连接 </span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> connectionFactory.newConnection();</span><br><span class="line">        <span class="comment">//  4. 创建 channel</span></span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line">        <span class="comment">//  5. 创建交换机 </span></span><br><span class="line">        <span class="type">String</span> <span class="variable">exchangeName</span> <span class="operator">=</span> <span class="string">&quot;test_fanout&quot;</span>;</span><br><span class="line">        channel.exchangeDeclare(exchangeName, BuiltinExchangeType.FANOUT, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line">        <span class="comment">//  6. 创建队列 </span></span><br><span class="line">        <span class="type">String</span> <span class="variable">queue1Name</span> <span class="operator">=</span> <span class="string">&quot;test_fanout_queue1&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">queue2Name</span> <span class="operator">=</span> <span class="string">&quot;test_fanout_queue2&quot;</span>;</span><br><span class="line">        channel.queueDeclare(queue1Name, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line">        channel.queueDeclare(queue2Name, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line">        <span class="comment">//  7. 绑定交换机和队列 </span></span><br><span class="line">        channel.queueBind(queue1Name, exchangeName,<span class="string">&quot;&quot;</span>);</span><br><span class="line">        channel.queueBind(queue2Name, exchangeName,<span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="comment">//  8. 发送消息 </span></span><br><span class="line">        <span class="type">String</span> <span class="variable">body</span> <span class="operator">=</span> <span class="string">&quot;Pub Sub Model!&quot;</span>;</span><br><span class="line">        channel.basicPublish(exchangeName, <span class="string">&quot;&quot;</span>, <span class="literal">null</span>, body.getBytes());</span><br><span class="line">        <span class="comment">//  9. 释放资源 </span></span><br><span class="line">        channel.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 交换机参数说明：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> AMQP.Exchange.DeclareOk <span class="title function_">exchangeDeclare</span><span class="params">(String exchange, BuiltinExchangeType type, <span class="type">boolean</span> durable, <span class="type">boolean</span> autoDelete, <span class="type">boolean</span> internal, Map&lt;String, Object&gt; arguments)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.exchangeDeclare(exchange, type.getType(), durable, autoDelete, internal, arguments);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>exchange：交换机名称 </p></li><li><p>type：交换机类型，枚举类型 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">DIRECT(<span class="string">&quot;direct&quot;</span>),</span><br><span class="line">FANOUT(<span class="string">&quot;fanout&quot;</span>),</span><br><span class="line">TOPIC(<span class="string">&quot;topic&quot;</span>),</span><br><span class="line">HEADERS(<span class="string">&quot;headers&quot;</span>);</span><br></pre></td></tr></table></figure></li><li><p>durable：是否持久化 </p></li><li><p>autoDelete：自动删除 </p></li><li><p>internal：内部使用，一般设置为 false</p></li><li><p>arguments：参数列表 </p></li></ol><p>queueBind 参数说明：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> AMQP.Queue.BindOk <span class="title function_">queueBind</span><span class="params">(String queue, String exchange, String routingKey)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.queueBind(queue, exchange, routingKey, (Map)<span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>queue：队列名称 </li><li>exchange：交换机名称 </li><li>routingKey：路由规则 </li></ol><h6 id="消费者 -2"><a href="# 消费者 -2" class="headerlink" title="消费者"></a> 消费者 </h6><p>sub1</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Consumer_PubSub1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException &#123;</span><br><span class="line">        <span class="type">ConnectionFactory</span> <span class="variable">connectionFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionFactory</span>();</span><br><span class="line">        connectionFactory.setHost(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line">        connectionFactory.setPort(<span class="number">5672</span>);</span><br><span class="line">        connectionFactory.setVirtualHost(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">        connectionFactory.setUsername(<span class="string">&quot;admin&quot;</span>);</span><br><span class="line">        connectionFactory.setPassword(<span class="string">&quot;admin&quot;</span>);</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> connectionFactory.newConnection();</span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line">        <span class="type">Consumer</span> <span class="variable">consumer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultConsumer</span>(channel)&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="type">byte</span>[] body)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Pub Sub 1 :&quot;</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;consumerTag :&quot;</span> + consumerTag);</span><br><span class="line">                System.out.println(<span class="string">&quot;body :&quot;</span> + <span class="keyword">new</span> <span class="title class_">String</span>(body));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="type">String</span> <span class="variable">queueName</span> <span class="operator">=</span> <span class="string">&quot;test_fanout_queue1&quot;</span>;</span><br><span class="line">        channel.basicConsume(queueName, <span class="literal">true</span>, consumer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>sub2</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Consumer_PubSub2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException &#123;</span><br><span class="line">        <span class="type">ConnectionFactory</span> <span class="variable">connectionFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionFactory</span>();</span><br><span class="line">        connectionFactory.setHost(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line">        connectionFactory.setPort(<span class="number">5672</span>);</span><br><span class="line">        connectionFactory.setVirtualHost(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">        connectionFactory.setUsername(<span class="string">&quot;admin&quot;</span>);</span><br><span class="line">        connectionFactory.setPassword(<span class="string">&quot;admin&quot;</span>);</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> connectionFactory.newConnection();</span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line">        <span class="type">Consumer</span> <span class="variable">consumer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultConsumer</span>(channel)&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="type">byte</span>[] body)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Pub Sub 2 :&quot;</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;consumerTag :&quot;</span> + consumerTag);</span><br><span class="line">                System.out.println(<span class="string">&quot;body :&quot;</span> + <span class="keyword">new</span> <span class="title class_">String</span>(body));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="type">String</span> <span class="variable">queueName</span> <span class="operator">=</span> <span class="string">&quot;test_fanout_queue2&quot;</span>;</span><br><span class="line">        channel.basicConsume(queueName, <span class="literal">true</span>, consumer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 发布订阅模式交换机本身不存储消息，只进行消息的路由，因为使用的是 Fanout 模式（扇形 &#x2F; 广播），调用 queueBind() 方法的时候设置 routingKey 为空字符串，相当于对绑定该交换机的每一个队列都进行了消息的发送，使得每一个队列的消费者都可以重复消费一条消息。</p><hr><h5 id="Routing（路由模式）"><a href="#Routing（路由模式）" class="headerlink" title="Routing（路由模式）"></a>Routing（路由模式）</h5><p><img data-src="/images/MQ%EF%BC%88%E4%B8%80%EF%BC%89%E8%B7%AF%E7%94%B1.png"></p><h6 id="生产者 -2"><a href="# 生产者 -2" class="headerlink" title="生产者"></a> 生产者 </h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Producer_Routing</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException &#123;</span><br><span class="line">        <span class="comment">//  1. 创建连接工厂 </span></span><br><span class="line">        <span class="type">ConnectionFactory</span> <span class="variable">connectionFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionFactory</span>();</span><br><span class="line">        <span class="comment">//  2. 设置参数 </span></span><br><span class="line">        connectionFactory.setHost(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line">        connectionFactory.setPort(<span class="number">5672</span>);</span><br><span class="line">        connectionFactory.setVirtualHost(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">        connectionFactory.setUsername(<span class="string">&quot;admin&quot;</span>);</span><br><span class="line">        connectionFactory.setPassword(<span class="string">&quot;admin&quot;</span>);</span><br><span class="line">        <span class="comment">//  3. 创建连接 </span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> connectionFactory.newConnection();</span><br><span class="line">        <span class="comment">//  4. 创建 channel</span></span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line">        <span class="comment">//  5. 创建交换机 </span></span><br><span class="line">        <span class="type">String</span> <span class="variable">exchangeName</span> <span class="operator">=</span> <span class="string">&quot;test_direct&quot;</span>;</span><br><span class="line">        channel.exchangeDeclare(exchangeName, BuiltinExchangeType.DIRECT, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line">        <span class="comment">//  6. 创建队列 </span></span><br><span class="line">        <span class="type">String</span> <span class="variable">queue1Name</span> <span class="operator">=</span> <span class="string">&quot;test_direct_queue1&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">queue2Name</span> <span class="operator">=</span> <span class="string">&quot;test_direct_queue2&quot;</span>;</span><br><span class="line">        channel.queueDeclare(queue1Name, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line">        channel.queueDeclare(queue2Name, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line">        <span class="comment">//  7. 绑定交换机和队列 </span></span><br><span class="line">        channel.queueBind(queue1Name, exchangeName,<span class="string">&quot;typeOne&quot;</span>);</span><br><span class="line">        channel.queueBind(queue2Name, exchangeName,<span class="string">&quot;typeTwo&quot;</span>);</span><br><span class="line">        channel.queueBind(queue2Name, exchangeName,<span class="string">&quot;typeThree&quot;</span>);</span><br><span class="line">        <span class="comment">//  8. 发送消息 </span></span><br><span class="line">        <span class="type">String</span> <span class="variable">body1</span> <span class="operator">=</span> <span class="string">&quot;Routing Model - Type One!&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">body2</span> <span class="operator">=</span> <span class="string">&quot;Routing Model - Type Two!&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">body3</span> <span class="operator">=</span> <span class="string">&quot;Routing Model - Type Three!&quot;</span>;</span><br><span class="line">        channel.basicPublish(exchangeName, <span class="string">&quot;typeOne&quot;</span>, <span class="literal">null</span>, body1.getBytes());</span><br><span class="line">        channel.basicPublish(exchangeName, <span class="string">&quot;typeTwo&quot;</span>, <span class="literal">null</span>, body2.getBytes());</span><br><span class="line">        channel.basicPublish(exchangeName, <span class="string">&quot;typeThree&quot;</span>, <span class="literal">null</span>, body3.getBytes());</span><br><span class="line">        <span class="comment">//  9. 释放资源 </span></span><br><span class="line">        channel.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="消费者 -3"><a href="# 消费者 -3" class="headerlink" title="消费者"></a> 消费者 </h6><p>routing1</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Consumer_Routing1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException &#123;</span><br><span class="line">        <span class="type">ConnectionFactory</span> <span class="variable">connectionFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionFactory</span>();</span><br><span class="line">        connectionFactory.setHost(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line">        connectionFactory.setPort(<span class="number">5672</span>);</span><br><span class="line">        connectionFactory.setVirtualHost(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">        connectionFactory.setUsername(<span class="string">&quot;admin&quot;</span>);</span><br><span class="line">        connectionFactory.setPassword(<span class="string">&quot;admin&quot;</span>);</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> connectionFactory.newConnection();</span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line">        <span class="type">Consumer</span> <span class="variable">consumer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultConsumer</span>(channel)&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="type">byte</span>[] body)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Routing 1 :&quot;</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;consumerTag :&quot;</span> + consumerTag);</span><br><span class="line">                System.out.println(<span class="string">&quot;body :&quot;</span> + <span class="keyword">new</span> <span class="title class_">String</span>(body));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="type">String</span> <span class="variable">queueName</span> <span class="operator">=</span> <span class="string">&quot;test_direct_queue1&quot;</span>;</span><br><span class="line">        channel.basicConsume(queueName, <span class="literal">true</span>, consumer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>routing2</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Consumer_Routing2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException &#123;</span><br><span class="line">        <span class="type">ConnectionFactory</span> <span class="variable">connectionFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionFactory</span>();</span><br><span class="line">        connectionFactory.setHost(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line">        connectionFactory.setPort(<span class="number">5672</span>);</span><br><span class="line">        connectionFactory.setVirtualHost(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">        connectionFactory.setUsername(<span class="string">&quot;admin&quot;</span>);</span><br><span class="line">        connectionFactory.setPassword(<span class="string">&quot;admin&quot;</span>);</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> connectionFactory.newConnection();</span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line">        <span class="type">Consumer</span> <span class="variable">consumer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultConsumer</span>(channel)&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="type">byte</span>[] body)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Routing 2 :&quot;</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;consumerTag :&quot;</span> + consumerTag);</span><br><span class="line">                System.out.println(<span class="string">&quot;body :&quot;</span> + <span class="keyword">new</span> <span class="title class_">String</span>(body));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="type">String</span> <span class="variable">queueName</span> <span class="operator">=</span> <span class="string">&quot;test_direct_queue2&quot;</span>;</span><br><span class="line">        channel.basicConsume(queueName, <span class="literal">true</span>, consumer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Routing 模式相较于发布订阅模式的不同之处在于一条消息必须根据 routingKey 进行路由，也即根据 routingKey 发送到对应的队列中。一个队列可以绑定多个 routingKey，使用该种模式的时候，要求生产者发送的消息也必须携带 routingKey，否则会导致消息丢失。也可以将广播视为 routing 的一种特殊情况。</p><hr><h5 id="Topics 通配符模式（主题模式）"><a href="#Topics 通配符模式（主题模式）" class="headerlink" title="Topics 通配符模式（主题模式）"></a>Topics 通配符模式（主题模式）</h5><p><img data-src="/images/MQ%EF%BC%88%E4%B8%80%EF%BC%89%E4%B8%BB%E9%A2%98.png"></p><h6 id="生产者 -3"><a href="# 生产者 -3" class="headerlink" title="生产者"></a> 生产者 </h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Producer_Topics</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException &#123;</span><br><span class="line">        <span class="comment">//  1. 创建连接工厂 </span></span><br><span class="line">        <span class="type">ConnectionFactory</span> <span class="variable">connectionFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionFactory</span>();</span><br><span class="line">        <span class="comment">//  2. 设置参数 </span></span><br><span class="line">        connectionFactory.setHost(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line">        connectionFactory.setPort(<span class="number">5672</span>);</span><br><span class="line">        connectionFactory.setVirtualHost(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">        connectionFactory.setUsername(<span class="string">&quot;admin&quot;</span>);</span><br><span class="line">        connectionFactory.setPassword(<span class="string">&quot;admin&quot;</span>);</span><br><span class="line">        <span class="comment">//  3. 创建连接 </span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> connectionFactory.newConnection();</span><br><span class="line">        <span class="comment">//  4. 创建 channel</span></span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line">        <span class="comment">//  5. 创建交换机 </span></span><br><span class="line">        <span class="type">String</span> <span class="variable">exchangeName</span> <span class="operator">=</span> <span class="string">&quot;test_topic&quot;</span>;</span><br><span class="line">        channel.exchangeDeclare(exchangeName, BuiltinExchangeType.TOPIC, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line">        <span class="comment">//  6. 创建队列 </span></span><br><span class="line">        <span class="type">String</span> <span class="variable">queue1Name</span> <span class="operator">=</span> <span class="string">&quot;test_topic_queue1&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">queue2Name</span> <span class="operator">=</span> <span class="string">&quot;test_topic_queue2&quot;</span>;</span><br><span class="line">        channel.queueDeclare(queue1Name, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line">        channel.queueDeclare(queue2Name, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line">        <span class="comment">//  7. 绑定交换机和队列 </span></span><br><span class="line">        channel.queueBind(queue1Name, exchangeName,<span class="string">&quot;#.typeOne&quot;</span>);</span><br><span class="line">        channel.queueBind(queue2Name, exchangeName,<span class="string">&quot;my.*&quot;</span>);</span><br><span class="line">        channel.queueBind(queue2Name, exchangeName,<span class="string">&quot;*.*&quot;</span>);</span><br><span class="line">        <span class="comment">//  8. 发送消息 </span></span><br><span class="line">        <span class="type">String</span> <span class="variable">body1</span> <span class="operator">=</span> <span class="string">&quot;Topics Model - Type One!&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">body2</span> <span class="operator">=</span> <span class="string">&quot;Topics Model - Type Two!&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">body3</span> <span class="operator">=</span> <span class="string">&quot;Topics Model - Type Three!&quot;</span>;</span><br><span class="line">        channel.basicPublish(exchangeName, <span class="string">&quot;my.typeOne&quot;</span>, <span class="literal">null</span>, body1.getBytes());</span><br><span class="line">        channel.basicPublish(exchangeName, <span class="string">&quot;others.typeTwo&quot;</span>, <span class="literal">null</span>, body2.getBytes());</span><br><span class="line">        channel.basicPublish(exchangeName, <span class="string">&quot;my.typeThree&quot;</span>, <span class="literal">null</span>, body3.getBytes());</span><br><span class="line">        <span class="comment">//  9. 释放资源 </span></span><br><span class="line">        channel.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="消费者 -4"><a href="# 消费者 -4" class="headerlink" title="消费者"></a> 消费者 </h6><p>topic1</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Consumer_Topic1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException &#123;</span><br><span class="line">        <span class="type">ConnectionFactory</span> <span class="variable">connectionFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionFactory</span>();</span><br><span class="line">        connectionFactory.setHost(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line">        connectionFactory.setPort(<span class="number">5672</span>);</span><br><span class="line">        connectionFactory.setVirtualHost(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">        connectionFactory.setUsername(<span class="string">&quot;admin&quot;</span>);</span><br><span class="line">        connectionFactory.setPassword(<span class="string">&quot;admin&quot;</span>);</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> connectionFactory.newConnection();</span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line">        <span class="type">Consumer</span> <span class="variable">consumer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultConsumer</span>(channel)&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="type">byte</span>[] body)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Topic 1 :&quot;</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;consumerTag :&quot;</span> + consumerTag);</span><br><span class="line">                System.out.println(<span class="string">&quot;body :&quot;</span> + <span class="keyword">new</span> <span class="title class_">String</span>(body));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="type">String</span> <span class="variable">queueName</span> <span class="operator">=</span> <span class="string">&quot;test_topic_queue1&quot;</span>;</span><br><span class="line">        channel.basicConsume(queueName, <span class="literal">true</span>, consumer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>topic2</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Consumer_Topic2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException &#123;</span><br><span class="line">        <span class="type">ConnectionFactory</span> <span class="variable">connectionFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionFactory</span>();</span><br><span class="line">        connectionFactory.setHost(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line">        connectionFactory.setPort(<span class="number">5672</span>);</span><br><span class="line">        connectionFactory.setVirtualHost(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">        connectionFactory.setUsername(<span class="string">&quot;admin&quot;</span>);</span><br><span class="line">        connectionFactory.setPassword(<span class="string">&quot;admin&quot;</span>);</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> connectionFactory.newConnection();</span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line">        <span class="type">Consumer</span> <span class="variable">consumer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultConsumer</span>(channel)&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="type">byte</span>[] body)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Topic 2 :&quot;</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;consumerTag :&quot;</span> + consumerTag);</span><br><span class="line">                System.out.println(<span class="string">&quot;body :&quot;</span> + <span class="keyword">new</span> <span class="title class_">String</span>(body));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="type">String</span> <span class="variable">queueName</span> <span class="operator">=</span> <span class="string">&quot;test_topic_queue2&quot;</span>;</span><br><span class="line">        channel.basicConsume(queueName, <span class="literal">true</span>, consumer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 可以看到，对于消费者来说，逻辑大多一致，最主要的区别在于确定消费者消费的具体队列名称；对于生产者而言，不同模式下的主要区别在于对交换机的设置以及绑定消息队列和交换机路由关键字之间的关系。</p>]]></content>
      
      
      <categories>
          
          <category> RabbitMQ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RabbitMQ </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>腾讯云服务器安装 RabbitMQ</title>
      <link href="/2022/102ac2789e.html"/>
      <url>/2022/102ac2789e.html</url>
      
        <content type="html"><![CDATA[<h1 id="腾讯云服务器安装 RabbitMQ"><a href="# 腾讯云服务器安装 RabbitMQ" class="headerlink" title="腾讯云服务器安装 RabbitMQ"></a>腾讯云服务器安装 RabbitMQ</h1><p>  最近在学习消息队列中间件的相关知识，实际在腾讯云服务器上进行实操验证，记录下安装流程。</p><hr><p>在具体安装之前可以更新下所有的软件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum update</span><br></pre></td></tr></table></figure><p>整个安装过程使用到的网站：</p><p>RabbitMQ 和 Erlang 版本要求：<span class="exturl" data-url="aHR0cHM6Ly93d3cucmFiYml0bXEuY29tL3doaWNoLWVybGFuZy5odG1s">RabbitMQ Erlang Version Requirements — RabbitMQ<i class="fa fa-external-link-alt"></i></span></p><p>Erlang 下载链接：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3JhYmJpdG1xL2VybGFuZy1ycG0vcmVsZWFzZXM=">Releases · rabbitmq&#x2F;erlang-rpm (github.com)<i class="fa fa-external-link-alt"></i></span></p><p>RabbitMQ 下载链接：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3JhYmJpdG1xL3JhYmJpdG1xLXNlcnZlci9yZWxlYXNlcw==">Releases · rabbitmq&#x2F;rabbitmq-server (github.com)<i class="fa fa-external-link-alt"></i></span></p><p>Socat 下载链接：<span class="exturl" data-url="aHR0cDovL3d3dy5ycG1maW5kLm5ldC9saW51eC9ycG0yaHRtbC9zZWFyY2gucGhwP3F1ZXJ5PXNvY2F0KHg4Ni02NCk=">RPM resource socat(x86-64) (rpmfind.net)<i class="fa fa-external-link-alt"></i></span></p><p>本次实验所用安装包下载：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3F1LXNoYW8vRmlsZXMvdHJlZS9tYWluL1JhYmJpdE1RJUU1JUFFJTg5JUU4JUEzJTg1">https://github.com/qu-shao/Files/tree/main/RabbitMQ%E5%AE%89%E8%A3%85<i class="fa fa-external-link-alt"></i></span></p><p><img data-src="/images/RabbitMQ-%E5%87%86%E5%A4%87%E5%AE%89%E8%A3%85%E5%8C%85.png"></p><h4 id="1- 安装依赖环境"><a href="#1- 安装依赖环境" class="headerlink" title="1. 安装依赖环境"></a>1. 安装依赖环境</h4><p>RabbitMQ 是用 Erlang 编写的，在安装 RabbitMQ 之前必须安装 Erlang 编译所需的依赖软件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install gcc glibc-devel make ncurses-devel openssl-devel xmlto perl wget</span><br></pre></td></tr></table></figure><h4 id="2- 下载准备所需安装包"><a href="#2- 下载准备所需安装包" class="headerlink" title="2. 下载准备所需安装包"></a>2. 下载准备所需安装包</h4><p>RabbitMQ 官网提供了版本和 Erlang 之间的关系如下图，选择相应的版本下载即可</p><p><img data-src="/images/RabbitMQ%E7%89%88%E6%9C%AC%E5%85%B3%E7%B3%BB.png"></p><h4 id="3- 顺序安装软件"><a href="#3- 顺序安装软件" class="headerlink" title="3. 顺序安装软件"></a>3. 顺序安装软件</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rpm -ivh erlang-25.1.1-1.el8.x86_64.rpm</span><br><span class="line">rpm -ivh socat-1.7.4.1-1.el8.x86_64.rpm</span><br><span class="line">rpm -ivh rabbitmq-server-3.11.2-1.el8.noarch.rpm</span><br></pre></td></tr></table></figure><p><img data-src="/images/RabbitMQ%E5%AE%89%E8%A3%85%E8%BD%AF%E4%BB%B6%E5%8C%85.png"></p><h4 id="4- 启动服务"><a href="#4- 启动服务" class="headerlink" title="4. 启动服务"></a>4. 启动服务</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl start rabbitmq-server</span><br></pre></td></tr></table></figure><h4 id="5- 设置开机自启动"><a href="#5- 设置开机自启动" class="headerlink" title="5. 设置开机自启动"></a>5. 设置开机自启动</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl enable rabbitmq-server</span><br></pre></td></tr></table></figure><h4 id="6- 查看状态"><a href="#6- 查看状态" class="headerlink" title="6. 查看状态"></a>6. 查看状态</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl status rabbitmq-server</span><br></pre></td></tr></table></figure><p><img data-src="/images/RabbitMQ%E5%90%AF%E5%8A%A8.png"></p><h4 id="7- 开启 web 管理插件"><a href="#7- 开启 web 管理插件" class="headerlink" title="7. 开启 web 管理插件"></a>7. 开启 web 管理插件</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmq-plugins enable rabbitmq_management</span><br></pre></td></tr></table></figure><h4 id="8- 添加用户设置权限"><a href="#8- 添加用户设置权限" class="headerlink" title="8. 添加用户设置权限"></a>8. 添加用户设置权限</h4><p>RabbitMQ 有一个默认的 guest 用户，但只能通过 localhost 访问，所以需要添加一个能够远程访问的用户。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl add_user admin admin</span><br><span class="line">rabbitmqctl set_user_tags admin administrator</span><br><span class="line">rabbitmqctl set_permissions -p / admin &quot;.*&quot; &quot;.*&quot; &quot;.*&quot;</span><br></pre></td></tr></table></figure><h4 id="9- 修改防火墙"><a href="#9- 修改防火墙" class="headerlink" title="9. 修改防火墙"></a>9. 修改防火墙 </h4><p> 因为使用的是腾讯云服务器，所以需要添加相应端口的过滤规则，也可以在自己本机服务器上添加防火墙规则</p><p><img data-src="/images/RabbitMQ%E9%98%B2%E7%81%AB%E5%A2%99%E8%AE%BE%E7%BD%AE.png"></p><hr><p>至此，基础的安装完成，同时也能够远程管理 RabbitMQ 了，浏览器访问 <span class="exturl" data-url="aHR0cDovL2lwOjE1NjcyLw==">http://IP:15672<i class="fa fa-external-link-alt"></i></span> 即可，后续会对具体的参数进行学习配置。</p><p><img data-src="/images/RabbitMQ%E8%BF%9C%E7%A8%8B%E7%AE%A1%E7%90%86%E6%B5%8B%E8%AF%95.png"></p>]]></content>
      
      
      <categories>
          
          <category> RabbitMQ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RabbitMQ </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM 学习笔记</title>
      <link href="/2022/0728becffb.html"/>
      <url>/2022/0728becffb.html</url>
      
        <content type="html"><![CDATA[<h1 id="JVM 学习笔记"><a href="#JVM 学习笔记" class="headerlink" title="JVM 学习笔记"></a>JVM 学习笔记 </h1><h2 id="类加载子系统（Class-Loader-Subsystem）"><a href="# 类加载子系统（Class-Loader-Subsystem）" class="headerlink" title="类加载子系统（Class Loader Subsystem）"></a> 类加载子系统（Class Loader Subsystem）</h2><ol><li><p>类加载过程分为三个阶段：加载、链接、初始化。其中加载是指获取字节码文件的二进制字节流并转化为方法区的运行时数据结构，在内存中生成一个代表该类的 java.lang.Class 对象，作为方法区这个类的各种数据的访问入口；链接又分为验证、准备、解析三个阶段，其中验证在于确保 Class 文件的字节流中包含信息符合当前虚拟机要求，保证被加载类的正确性，比如所有的字节码文件都是以“cafebabe”4 个字节开头，准备阶段为类变量分配内存并设置默认值，注意这里不会为实例变量分配初始化，实例变量会随着对象一起分配到 Java 堆中，解析阶段将常量池内的符号引用转换为直接引用；初始化阶段就是执行类构造器方法 <clinit>() 的过程。</p></li><li><p>类构造器方法 <clinit>() 是 javac 编译器自动收集类中所有类变量（静态变量）的赋值动作和静态代码块中的语句合并而来，如果类中不存在以上情况，则在方法区中也不会存在该方法。</p></li><li><p>如果一个类存在父类，则 JVM 会保证在子类的 <clinit>() 执行前，父类的 <clinit>() 已经执行完毕。</p></li><li><p>类加载器的分类：引导类加载器（c&#x2F;c++ 语言编写）和自定义类加载器。这里的自定义类加载器不是指程序员自己定义的，而是指所有派生于抽象类 ClassLoader 的类加载器，是广义上的自定义。细分为三种加载器：引导类加载器、扩展类加载器、系统类加载器。</p></li><li><p>对于用户自定义类来说，默认使用系统类加载器进行加载。</p></li><li><p>系统的核心类库（比如 String 类）使用引导类加载器进行加载。</p></li><li><p>需要用户去自定义类加载器的情况：隔离加载类；修改类加载的方式；扩展加载源；防止源码泄漏。</p></li><li><p>用户如何自定义类加载器：一般通过继承 ClassLoader 类并重写 findClass()方法；也可以直接继承 URLClassLoader 类，这样可以避免重写 findClass()方法及其获取字节码流的方式。</p></li><li><p>双亲委派机制：如果一个类加载器收到了类加载请求，并不会直接加载，而是将这个请求委托给父类的加载器去执行，如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器，如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CustomClassLoader -&gt; ApplicationClassLoader -&gt; ExtensionClassLoader -&gt; BootstrapClassLoader</span><br></pre></td></tr></table></figure></li><li><p>双亲委派机制的优势：避免类的重复加载；保护程序安全，防止核心 API 被随意篡改。</p></li><li><p>在 JVM 中表示两个 class 对象是否为同一个类的两个必要条件：类的完整类名必须一致（包括包名）；加载这个类的 ClassLoader 必须相同。</p></li></ol><h2 id="运行时数据区（Runtime-Data-Area）"><a href="# 运行时数据区（Runtime-Data-Area）" class="headerlink" title="运行时数据区（Runtime Data Area）"></a>运行时数据区（Runtime Data Area）</h2><ol><li><p>PC 寄存器既没有 GC 也没有 OOM。</p></li><li><p>Java 虚拟机栈是线程私有的，主管 Java 程序的运行，它保存方法的局部变量、部分结果，并参与方法的调用和返回。</p></li><li><p>我们可以使用参数 -Xss 选项来设置线程的最大栈空间，栈的大小直接决定了函数调用的最大可达深度。</p></li><li><p>线程中每个方法和栈帧一一对应。</p></li><li><p>栈帧中有五部分：局部变量表；操作数栈；动态链接；方法返回地址；一些附加信息。</p></li><li><p>局部变量表定义为一个数组，主要用于存储方法参数和定义在方法体内的局部变量，具体包括各类基本数据类型、对象引用以及 returnAddress 类型。</p></li><li><p>在字节码文件中，LineNumberTable 中存储了字节码代码和源代码在行号上的对应关系；LocalVariableTable 中存储了每一个变量在字节码代码中的生效行数和作用范围域以及描述符等其他信息。</p></li><li><p>局部变量表最基本的存储单元是 Slot（变量槽），在局部变量表里，32 位以内的类型只占用一个 slot，64 位的类型占用两个 slot。</p></li><li><p>构造器和实例方法中，this 变量被放置于索引为 0 的 slot 处，这也解释了为什么静态方法不可以调用 this，因为在静态方法的局部变量表中不存在 this 变量。</p></li><li><p>动态链接的作用是将符号引用转换为调用方法的直接引用。</p></li><li><p>在面向对象的编程中，会很频繁地使用到动态分派，如果在每次动态分派的过程中都要重新在类的方法元数据中搜索合适的目标的话就可能影响到执行效率。因此，为了提高性能，JVM 采用在类的方法区建立一个虚方法表（非虚方法不会出现在表中）来实现，使用索引表来代替查找。虚方法表在类加载的链接阶段被创建并开始初始化。</p></li><li><p>本地方法栈，也是线程私有的。</p></li><li><p>-Xms 用于表示堆区的起始内存，等价于 -XX:InitialHeapSize；-Xmx 用于表示堆区的最大内存，等价于 -XX:MaxHeapSize。通常会将这两个参数配置相同的值，其目的是为了能够在 java 垃圾回收机制清理完堆区后不需要重新分隔计算堆区的大小，从而提高性能。</p></li><li><p>垃圾回收分为三种：Minor GC、Major GC、Full GC。Minor GC 回收新生代的对象，发生频率最高；Major GC 回收老年代的对象；Full GC 收集整个 Java 堆和方法区的垃圾。其中后两者所需要的时间更久，也是 GC 调优的主要目标和目的。</p></li><li><p>常用参数：</p><p>（1）-XX:+PrintFlagsInitial ：查看所有的参数的默认初始值</p><p>（2）-XX:+PrintFlagsFinal ：查看所有的参数的最终值</p><p>（3）-XX:NewRatio ：配置新生代与老年代在堆结构的占比</p><p>（4）-Xms ：初始化堆空间内存（默认为物理内存的 1&#x2F;64）</p><p>（5）-Xmx ：最大堆空间内存（默认为物理内存的 1&#x2F;4）</p><p>（6）-Xmn ：设置新生代的大小（初始值以及最大值）</p><p>（7）-XX:SurvivorRatio ：设置新生代中 Eden 和 S0&#x2F;S1 空间的比例</p><p>（8）-XX:MaxTenuringThreshold ：设置新生代垃圾的最大年龄</p><p>（9）-XX:+PrintGCDetails ：输出详细的 GC 日志</p><p>（10）-XX:HandlePromotionFailure ：是否设置空间分配担保</p></li><li><p>对象实例化的步骤：判断对象对用的类是否加载、链接、初始化；为对象分配内存；处理并发安全问题；初始化分配到的空间（所有属性设置默认值）；设置对象的对象头；执行 init 方法进行初始化。</p></li><li><p>对象在内存中分为对象头、实例数据、对齐填充（非必须）几部分。</p></li><li><p>对象头中包含两部分，一部分是运行时元数据，具体包括对象哈希值、GC 分代年龄、锁状态标志、线程持有的锁、偏向线程 ID、偏向时间戳；另一部分为类型指针，指向类元数据 InstanceKlass，确定该对象所属的类型。</p></li></ol><h2 id="垃圾回收（Garbage-Collection）"><a href="# 垃圾回收（Garbage-Collection）" class="headerlink" title="垃圾回收（Garbage Collection）"></a>垃圾回收（Garbage Collection）</h2><ol><li>JDK8 开始，设置 StringTableSize 的最小值为 1009。</li><li>字符串常量的拼接结果存放在常量池中，原理是编译期优化。</li><li>字符串拼接只要有一个是变量，结果存放在堆中，变量拼接的原理是 StringBuilder。</li><li>如果拼接的结果调用 intern()方法，则主动将常量池中还没有的字符串对象放入池中，并返回此对象地址。</li><li>intern()方法在 JDK1.6 和 JDK1.7 之后的版本的不同在于如果 intern()方法调用的字符串在常量字符串中不存在，在 JDK1.6 中会将此对象复制一份放入串池并返回串池中的对象地址；在 JDK1.7 以及之后的版本则会将对象的引用地址复制一份放入串池中并返回串池中的引用地址。</li><li>标记阶段主要算法：引用计数算法；可达性分析算法（根搜索算法）。</li><li>清除阶段主要算法：标记 - 清除算法；复制算法；标记 - 压缩算法。</li><li>引用计数算法的优点：实现简单，垃圾对象便于辨识；判定效率高，回收没有延迟性。</li><li>引用计数算法的缺点：需要单独的字段存储计数器，增加了空间的开销；每次赋值都需要更新计数器，增加了时间开销；无法处理循环引用的情况。</li><li>GC Roots 包括以下几类元素：虚拟机栈中引用的对象；本地方法栈内 JNI 引用的对象；方法区中类静态属性引用的对象；方法区中常量引用的对象；所有被同步锁 synchronized 持有的对象；Java 虚拟机内部的引用等。</li><li>永远不要主动调用某个对象的 finalize()方法，应该交给垃圾回收机制调用。</li><li>因为 finalize()方法的存在，虚拟机中的对象可能处于三种状态：可触及的（从根节点开始，可以到达这个对象）；可复活的（对象的所有引用都被释放，但是对象可能在 finalize()中复活）；不可触及的（对象的 finalize()被调用并且没有被复活）。</li><li>finalize()方法允许在子类中被重写，用于在对象被回收时进行资源释放，比如关闭文件、套接字和数据库连接等。</li><li>复制算法的优点：没有标记和清除过程，实现简单，运行高效；复制保证了空间的连续性，不会出现“碎片”问题。</li><li>复制算法的缺点：需要两倍的内存空间；对于 G1 这种分拆为大量的 region 的 GC，复制而不是移动，意味着 GC 需要维护 region 之间对象引用关系，不管是内存占用或者时间开销也不小。</li><li>特别的，如果系统中的垃圾对象很多，复制算法需要复制的存活对象数量并不太大。（垃圾对象越多，复制算法越好）在新生代中，一次通常可以回收 70% - 99% 的内存空间，回收性价比很高，老年代则反之。</li><li>分代收集算法是基于这样一个事实：不同的对象的生命周期是不一样的，因此，不同生命周期的对象可以采取不同的收集方式，以便提高回收效率。（一般是针对新生代和老年代）</li><li>System.gc()（底层实现为 Runtime.getRuntime().gc()）只是提醒 jvm 的垃圾回收器执行 gc，但是不确定是否马上执行 gc。</li><li>System.runFinalization()会强制调用没有引用的对象的 finalization 方法。</li><li>内存泄漏的例子：单例的生命周期和应用程序一样长，如果单例程序中持有外部对象的引用，这个外部对象无法被回收；一些提供 close 的资源未关闭导致内存泄漏（比如数据库连接 dataSourse.getConnection，网络连接，IO 连接）。</li><li>强引用；软引用（内存不足时回收）；弱引用（GC 时发现就回收，比如 WeakHashMap）；虚引用（唯一目的在于跟踪垃圾回收过程，在对象被收集器回收时收到一个系统通知）。</li><li>串行回收器：Serial、Serial Old</li><li>并行回收器：ParNew、Parallel Scavenge、Parallel Old</li><li>并发回收器：CMS、G1</li><li>新生代回收器：Serial、Parallel Scavenge、ParNew</li><li>老年代回收器：Serial Old、Parallel Old、CMS</li><li>整堆收集器：G1</li><li>垃圾回收器组合关系：Serial 和 Serial Old；Parallel Scavenge 和 Parallel Old；CMS 和 ParNew。</li><li>Serial 使用复制算法；Serial Old 使用标记 - 压缩算法。</li><li>CMS 垃圾回收器使用标记 - 清除算法。</li><li>CMS 分为四个阶段：初始标记（仅仅只标记出 GC Roots 能直接关联到的对象）；并发标记（从上一个阶段直接关联的对象开始遍历整个对象图的过程）；重新标记（由于并发标记工作线程和垃圾收集线程同时或者交叉运行，在这一个阶段修正因为用户程序继续运作而导致标记产生变动的那一部分对象的标记记录）；并发清理。</li><li>G1 垃圾回收器 region 之间是复制算法，但整体上实际可以看作是标记 - 压缩算法，两种方式都可以解决碎片化的问题。</li></ol>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
            <tag> 求职 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 面试八股文</title>
      <link href="/2022/07f59bdc6f.html"/>
      <url>/2022/07f59bdc6f.html</url>
      
        <content type="html"><![CDATA[<h1 id="Java 面试八股文"><a href="#Java 面试八股文" class="headerlink" title="Java 面试八股文"></a>Java 面试八股文</h1><hr><ol><li><p>&#x3D;&#x3D; 和 equals 的区别<br>&#x3D;&#x3D; 对比的是栈中的值，基本数据类型是变量值，引用类型是堆中内存对象的地址；equals 在默认中也是采用 &#x3D;&#x3D; 比较，通常会进行重写。</p></li><li><p>面向对象的三个基本特征 <br> 继承：让某个类型的对象获得另一个类型的对象的属性的方法。继承就是子类继承父类的特征和行为，使得子类对象（实例）具有父类的实例域和方法，或子类从父类继承方法，使得子类具有父类相同的行为。<br>封装：隐藏部分对象的属性和实现细节，对数据的访问只能通过外公开的接口。通过这种方式，对象对内部数据提供了不同级别的保护，以防止程序中无关的部分意外的改变或错误的使用了对象的私有部分。<br>多态：对于同一个行为，不同的子类对象具有不同的表现形式。多态存在的 3 个条件：1）继承；2）重写；3）父类引用指向子类对象。</p></li><li><p>访问修饰符 public，private，protected，以及不写时的区别</p><table><thead><tr><th>修饰符</th><th>当前类</th><th>同包</th><th>子类</th><th>其他包</th></tr></thead><tbody><tr><td>public</td><td>√</td><td>√</td><td>√</td><td>√</td></tr><tr><td>protected</td><td>√</td><td>√</td><td>√</td><td></td></tr><tr><td>默认</td><td>√</td><td>√</td><td></td><td></td></tr><tr><td>private</td><td>√</td><td></td><td></td><td></td></tr></tbody></table></li><li><p>简述 final 作用<br>final 修饰类：表示类不可被继承。<br>final 修饰方法：表示方法不可以被子类覆盖（重写），但是可以重载。<br>final 修饰变量：表示变量一旦被赋值就不可以更改它的值。<br>final 修饰成员变量：<br>（1） 如果 final 修饰的是类变量（静态变量），只能在静态初始化块中指定初始值或者声明该类变量时指定初始值。<br>（2）如果 final 修饰的是成员变量，可以在非静态初始化块、声明该变量或者构造器中执行初始值。<br>final 修饰局部变量：系统不会为局部变量进行初始化，局部变量必须由程序员显式初始化，因此在 final 修饰局部变量时，可以在定义时指定默认值且之后不能对变量再赋值，也可以不指定默认值，在后面的代码中对 final 变量赋初值（仅一次）。</p></li><li><p>为什么局部内部类和匿名内部类只能访问局部 final 变量？<br>内部类和外部类是处于同一级别的，内部类不会因为定义在方法中就会随着方法的执行完毕就被销毁。那么如果说内部类在方法执行完毕的前提还未结束且仍需要访问局部变量，这时候就会造成内部类可能会访问一个不存在的变量，为了解决这一问题，实际上内部类访问的是局部变量的一份拷贝（将局部变量作为内部类的成员变量），这样处理又必须保证两者的一致性，故妥协的做法就要求将局部变量设置为 final，使其初始化后不再去修改这一变量。</p></li><li><p>String、StringBuffer、StringBuilder 的区别 <br>String 是 final 修饰的，不可变的，每次操作都会产生新的 String 对象。<br>StringBuffer 和 StringBuilder 都是在原对象上操作。<br>StringBuffer 是线程安全的，StringBuilder 线程不安全。<br>StringBuffer 方法都是 synchronized 修饰的。<br> 性能方面：StringBuilder &gt; StringBuffer &gt; String。</p></li><li><p>&amp; 和 &amp;&amp; 的区别 <br>&amp;&amp;：逻辑与运算符。当运算符左右两边的表达式都为 true，才返回 true。同时具有短路性，如果第一个表达式为 false，则直接返回 false。<br>&amp;：逻辑与运算符、按位与运算符。<br> 按位与运算符：用于二进制的计算，只有对应的两个二进位均为 1 时，结果位才为 1 ，否则为 0。<br>逻辑与运算符：&amp; 在用于逻辑与时，和 &amp;&amp; 的区别是不具有短路性。所在通常使用逻辑与运算符都会使用 &amp;&amp;，而 &amp; 更多的适用于位运算。</p></li><li><p>重载和重写的区别 <br> 重载：发生在同一个类中，方法名必须相同，参数类型不同，发生在编译时。<br>重写：发生在父子类中，方法名、参数列表必须相同，返回值范围小于等于父类，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类；如果父类方法访问修饰符为 private 则子类不能重写该方法。</p></li><li><p>接口和抽象类的区别 <br> 抽象类可以存在普通成员函数，接口中只能存在 public abstract 方法。<br>抽象类中的成员变量可以是各种类型的，接口中的成员变量只能是 public static final 类型的。<br>抽象类只能继承一个，接口可以实现多个。<br>接口的设计目的，是对类的行为进行约束，不过它只约束了行为的有无，但不对如何实现行为进行约束，体现的是一种 like a 的关系。<br>抽象类是对类本质的抽象，表达的是一种 is a 的关系，其设计目的是代码复用。当不同的类具有某些相同的行为，且一部分行为的实现方式一致时，可以让这些类都派生于一个抽象类，所以从逻辑上看，是先有了子类，再从中抽象出父类。</p></li><li><p>什么是反射<br>   反射是指在运行状态中，对于任意一个类都能够知道这个类所有的属性和方法；并且对于任意一个对象，都能够调用它的任意一个方法；这种动态获取信息以及动态调用对象方法的功能称为反射机制。</p></li><li><p>深拷贝和浅拷贝区别是什么 <br> 数据分为基本数据类型和引用数据类型。基本数据类型：数据直接存储在栈中；引用数据类型：存储在栈中的是对象的引用地址，真实的对象数据存放在堆内存里。<br>浅拷贝：对于基础数据类型：直接复制数据值；对于引用数据类型：只是复制了对象的引用地址，新旧对象指向同一个内存地址，修改其中一个对象的值，另一个对象的值随之改变。<br>深拷贝：对于基础数据类型：直接复制数据值；对于引用数据类型：开辟新的内存空间，在新的内存空间里复制一个一模一样的对象，新老对象不共享内存，修改其中一个对象的值，不会影响另一个对象。<br>深拷贝相比于浅拷贝速度较慢并且花销较大。</p></li><li><p>List 和 Set 的区别<br>   List 是有序的，按对象进入的顺序保存对象，可重复，且允许多个 Null 元素对象，可以使用 Iterator 取出所有元素，也可以通过下标随机访问。<br>   Set 是无序的，不可重复，最多允许一个 Null 元素对象。</p></li><li><p>Error 和 Exception 有什么区别<br>Error 和 Exception 都是 Throwable 的子类，用于表示程序出现了不正常的情况。区别在于：<br>Error 表示系统级的错误和程序不必处理的异常，是恢复不是不可能但很困难的情况下的一种严重问题，比如内存溢出，不可能指望程序能处理这样的情况。<br>Exception 表示需要捕捉或者需要程序进行处理的异常，是一种设计或实现问题，也就是说，它表示如果程序运行正常，从不会发生的情况。</p></li><li><p>hashCode 与 equals<br>如果两个对象相等，则 hashCode 一定也是相同的；<br>如果两个对象相等，分别调用 equals 方法都返回 True；<br>但是如果两个对象有相同的 hashCode，他们也不一定是相等的；<br>如果 equals 方法被重写，则 hashCode 方法也必须重写。</p></li><li><p>ArrayList 和 LinkedList 的区别 <br>   ArrayList 基于动态数组，连续内存存储，适合随机访问，但是因为在数组中间插入元素时需要涉及到大量的元素移动，所以不适合频繁插入、删除元素的场景。<br>   LinkedList 基于链表，可以分散存储，适合做数据的插入及删除操作，但是因为查询需要逐一遍历链表，所以不适合频繁查询的场景。遍历 LinkedList 时最好使用 iterator 而不使用 for 循环，因为 for 循环体内通过下标 get(i) 取得某一元素时都需要对 list 进行重新遍历，开销极大。</p></li><li><p>HashMap 和 HashTable 的区别<br>HashMap 允许 key 和 value 为 null，HashTable 不允许。<br>HashMap 方法没有 synchronized 修饰，线程不安全，HashTable 线程安全。</p><p>HashMap 初始大小 16，扩容两倍；HashTable 初始大小 11，扩容两倍 +1.</p></li><li><p>ConcurrentHashMap<br>ConcurrentHashMap 是 HashMap 的升级版，HashMap 是线程不安全的，而 ConcurrentHashMap 是线程安全。而其他功能和实现原理和 HashMap 类似<br>Hashtable 也是线程安全的，但每次要锁住整个结构，并发性低。相比之下，ConcurrentHashMap 获取 size 时才锁整个对象。<br>Hashtable 对 get&#x2F;put&#x2F;remove 都使用了同步操作。ConcurrentHashMap 只对 put&#x2F;remove 同步。<br>Hashtable 是快速失败的，遍历时改变结构会报错 ConcurrentModificationException。ConcurrentHashMap 是安全失败，允许并发检索和更新。<br>JDK8 的 ConcurrentHashMap 和 JDK7 的 ConcurrentHashMap 有什么区别？<br> JDK8 中新增了红黑树<br> JDK7 中使用的是头插法，JDK8 中使用的是尾插法<br> JDK7 中使用了分段锁，而 JDK8 中没有使用分段锁了<br> JDK7 中使用了 ReentrantLock，JDK8 中没有使用 ReentrantLock 了，而使用了 Synchronized<br> JDK7 中的扩容是每个 Segment 内部进行扩容，不会影响其他 Segment，而 JDK8 中的扩容和 HashMap 的扩容类似，只不过支持了多线程扩容，并且保证了线程安全。</p></li><li><p>ConcurrentHashMap 插入元素流程：<br>判断传入的 key 和 value 是否为 null，如果是则抛出空指针异常；<br>调用 spread()方法重新计算哈希值；<br>如果 ConcurrentHashMap 的 table 为 null，即未初始化，则调用 initTable()方法初始化；<br>将哈希表的长度 n - 1 和重新计算的哈希值进行与操作作为插入键值对在 table 中的下标；<br>调用原子操作 tabAt()方法取出当前下标的元素，如果为 null，此时没有哈希冲突，则调用原子操作 casTabAt()进行插入；<br>如果存在哈希冲突，进一步判断当前节点位置是否正在进行扩容（通过该节点此时的哈希值），如果为 -1 则调用 helpTransfer()方法帮助其进行扩容；<br>如果此时该节点没有处于扩容状态，对该下标的首个节点加锁，如果当前节点为链表结构（fh &gt;&#x3D; 0），依次访问链表节点，判断链表节点是否等于插入的 key，如果等于并且参数 onlyIfAbsent 为 false，则替换为新值；如果访问到链表表尾依旧没有碰到和 key 相等的节点，则直接将节点插入表尾，在这一整个过程，通过一个死循环进行，同时每一步用 binCount 记录节点个数；<br>如果此时节点为红黑树根节点（f instanceof TreeBin），则调用 putTreeVal()进行节点插入；<br>在节点插入之后，通过 binCount 判断当前节点的链表结构节点数量是否达到转化为红黑树的要求；<br>调用 addCount()方法将哈希表整体 size 加 1。</p></li><li><p>并发的三大特性 <br> 原子性；可见性；有序性。</p></li><li><p>线程安全的理解 <br> 当多个线程访问一个对象时，如果不用进行额外的同步控制或其他的协调操作，调用这个对象的行为都可以获得正确的结果，则认为这个对象时线程安全的。</p></li><li><p>为什么用线程池？线程池的参数？<br>降低资源消耗，提高线程利用率，降低创建和销毁线程的消耗；<br>提高响应速度，任务来了直接分配可用线程执行而不需要先创建线程再执行；<br>提高线程的可管理性，利用线程池可以统一分配调优监控；<br>corePoolSiz：代表核心线程数，也就是正常情况下创建工作的线程数。<br>maxinumPoolSize：代表的是最大线程数，与核心线程数相对应，表示最大允许被创建的线程数，当任务数量大于核心线程数时，会创建临时的线程，该参数用于控制总的最大线程数。<br>keepAliveTime：表示超出核心线程数之外的线程的空闲存活时间。<br>workQueue：用来存放待执行的任务。<br>ThreadFactory：用来生产线程执行任务。<br>Handler：任务拒绝策略。两种情况，第一种是当任务数超过了最大线程数且任务队列已满时获取到新任务时拒绝；第二种时当我们调用 shutdown 关闭线程池时（此时不再执行新获取到的任务，只完成线程池内部还未执行完的任务）。</p></li><li><p>简述线程池处理流程 <br> 创建线程池，判断核心线程是否已满？未满则创建核心线程执行；已满则判断任务队列是否已满？未满则将任务放入任务队列当中；已满则判断是否达到最大线程数？未达到则创建临时线程执行；达到则根据拒绝策略处理。</p></li><li><p>线程池的底层工作原理 <br> 线程池内部是通过队列 + 线程实现的，当利用线程池执行任务时：<br>如果此时线程池中的线程数量小于核心线程数，即使此时线程池中的所有线程都处于空闲状态，也要创建新的线程处理被添加的线程（优先让线程池中的线程数量达到核心线程数）；<br>如果此时线程数等于核心线程数，但是任务队列未满，任务放入任务队列中；<br>如果此时线程池中的线程数量大于等于核心线程数，且任务队列已满，但是线程数量小于最大线程数，则创建临时线程处理任务；<br>如果此时线程池中的线程数量等于最大线程数，且任务队列已满，则根据拒绝策略处理任务。<br>当线程池中的线程数量大于核心线程数时，如果线程池中存在空闲线程且空闲时间超过 keepAliveTime，线程被终止，以此动态地控制线程池中的线程数量。</p></li><li><p>线程池中线程的复用原理 <br> 线程池将线程和任务进行解耦，摆脱了之前通过 Thread 创建线程时一个线程必须对应一个任务的限制。在线程池中，同一个线程可以从任务队列中不断获取新任务执行，其核心原理在于线程池对 Thread 进行了一个封装，并不是每次执行任务都会调用 Thread.start()来创建新线程，而是让每个线程去执行一个“循环任务”，在这个循环任务中不断地检查是否有任务需要被执行，如果有就执行任务中的 run 方法，通过这种方法只使用固定的线程就将所有任务的 run 方法串联起来。</p></li><li><p>线程的生命周期 <br> 五种状态：创建；就绪；运行；阻塞；死亡。其中阻塞又可以分为三种：第一种等待阻塞，运行的线程执行 wait 方法，该线程会释放占用的所有资源，JVM 会把该线程放入“等待池”中，且进入这种状态后线程是不能自动唤醒的，必须依靠其他线程调用 notify 或者 notifyAll 方法才能被唤醒，wait 是 object 类的方法；第二种同步阻塞，线程再获取对象的同步锁时，若该同步锁被别的线程占用，则 JVM 会把该线程放入“锁池”中；第三种其它阻塞，运行的线程执行 sleep 方法或者 join 方法，或者发出了 I&#x2F;O 请求时线程进入阻塞状态，但是当上述处理结束后线程会自动回到就绪态，sleep 是 Thread 类的方法。</p></li><li><p>Java 对象实例化时的顺序 <br> 父类的静态方法，子类的静态方法，父类的代码块，父类的构造方法，子类的代码块，子类的构造方法。其中需要注意的是如果父类的构造方法中调用自己未实现的抽象方法时，可以在子类还未实例化前调用子类的实现方法。</p></li><li><p>wait() 和 sleep() 方法的区别 <br> 来源不同：sleep() 来自 Thread 类，wait() 来自 Object 类。<br>对于同步锁的影响不同：sleep() 不会释放锁资源，如果当前线程持有同步锁，那么 sleep 是不会让线程释放同步锁的。wait() 会释放同步锁，让其他线程进入 synchronized 代码块执行。<br>使用范围不同：sleep() 可以在任何地方使用。wait() 只能在同步控制方法或者同步控制块里面使用，否则会抛 IllegalMonitorStateException。<br>恢复方式不同：两者会暂停当前线程，但是在恢复上不太一样。sleep() 在时间到了之后会重新恢复；wait() 则需要其他线程调用同一对象的 notify()&#x2F;nofityAll() 才能重新恢复。</p></li><li><p>线程的 sleep() 方法和 yield() 方法有什么区别 <br> 线程执行 sleep() 方法后进入超时等待（TIMED_WAITING）状态，而执行 yield() 方法后进入就绪（READY）状态。<br>sleep() 方法给其他线程运行机会时不考虑线程的优先级，因此会给低优先级的线程运行的机会；yield() 方法只会给相同优先级或更高优先级的线程以运行的机会。</p></li><li><p>编写多线程程序有几种实现方式 <br> 通常来说，可以认为有三种方式：1）继承 Thread 类；2）实现 Runnable 接口；3）实现 Callable 接口。<br>其中，Thread 其实也是实现了 Runnable 接口。Runnable 和 Callable 的主要区别在于是否有返回值。</p></li><li><p>Thread 调用 start() 方法和调用 run() 方法的区别<br>run()：普通的方法调用，在主线程中执行，不会新建一个线程来执行。<br>start()：新启动一个线程，这时此线程处于就绪（可运行）状态，并没有运行，一旦得到 CPU 时间片，就开始执行 run() 方法。</p></li><li><p>线程的状态流转 <br> 一个线程可以处于以下状态之一：<br>NEW：新建但是尚未启动的线程处于此状态，没有调用 start() 方法。<br>RUNNABLE：包含就绪（READY）和运行中（RUNNING）两种状态。线程调用 start() 方法会会进入就绪（READY）状态，等待获取 CPU 时间片。如果成功获取到 CPU 时间片，则会进入运行中（RUNNING）状态。<br>BLOCKED：线程在进入同步方法 &#x2F; 同步块（synchronized）时被阻塞，等待同步锁的线程处于此状态。<br>WAITING：无限期等待另一个线程执行特定操作的线程处于此状态，需要被显示的唤醒，否则会一直等待下去。例如对于 Object.wait()，需要等待另一个线程执行 Object.notify() 或 Object.notifyAll()；对于 Thread.join()，则需要等待指定的线程终止。<br>TIMED_WAITING：在指定的时间内等待另一个线程执行某项操作的线程处于此状态。跟 WAITING 类似，区别在于该状态有超时时间参数，在超时时间到了后会自动唤醒，避免了无期限的等待。<br>TERMINATED：执行完毕已经退出的线程处于此状态。<br>线程在给定的时间点只能处于一种状态。这些状态是虚拟机状态，不反映任何操作系统线程状态。</p></li><li><p>synchronized 各种加锁场景的作用范围<br>1. 作用于非静态方法，锁住的是对象实例（this），每一个对象实例有一个锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;&#125;</span><br></pre></td></tr></table></figure><p>2. 作用于静态方法，锁住的是类的 Class 对象，因为 Class 的相关数据存储在永久代元空间，元空间是全局共享的，因此静态方法锁相当于类的一个全局锁，会锁所有调用该方法的线程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;&#125;</span><br></pre></td></tr></table></figure><p>3. 作用于 Lock.class，锁住的是 Lock 的 Class 对象，也是全局只有一个。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (Lock.class) &#123;&#125;</span><br></pre></td></tr></table></figure><p>4. 作用于 this，锁住的是对象实例，每一个对象实例有一个锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;&#125;</span><br></pre></td></tr></table></figure><p>5. 作用于静态成员变量，锁住的是该静态成员变量对象，由于是静态变量，因此全局只有一个。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">Object</span> <span class="variable">monitor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>(); <span class="keyword">synchronized</span> (monitor) &#123;&#125;</span><br></pre></td></tr></table></figure></li><li><p>如何检测死锁 <br> 死锁的四个必要条件：<br>1）互斥条件：进程对所分配到的资源进行排他性控制，即在一段时间内某资源仅为一个进程所占有。此时若有其他进程请求该资源，则请求进程只能等待。<br>2）请求和保持条件：进程已经获得了至少一个资源，但又对其他资源发出请求，而该资源已被其他进程占有，此时该进程的请求被阻塞，但又对自己获得的资源保持不放。<br>3）不可剥夺条件：进程已获得的资源在未使用完毕之前，不可被其他进程强行剥夺，只能由自己释放。<br>4）环路等待条件：存在一种进程资源的循环等待链，链中每一个进程已获得的资源同时被链中下一个进程所请求。即存在一个处于等待状态的进程集合{Pl, P2, …, pn}，其中 Pi 等待的资源被 P(i+1) 占有（i&#x3D;0, 1, …, n-1)，Pn 等待的资源被 P0 占有。</p></li><li><p>线程池的核心属性有哪些<br>threadFactory（线程工厂）：用于创建工作线程的工厂。<br>corePoolSize（核心线程数）：当线程池运行的线程少于 corePoolSize 时，将创建一个新线程来处理请求，即使其他工作线程处于空闲状态。<br>workQueue（队列）：用于保留任务并移交给工作线程的阻塞队列。<br>maximumPoolSize（最大线程数）：线程池允许开启的最大线程数。<br>handler（拒绝策略）：往线程池添加任务时，将在下面两种情况触发拒绝策略：1）线程池运行状态不是 RUNNING；2）线程池已经达到最大线程数，并且阻塞队列已满时。<br>keepAliveTime（保持存活时间）：如果线程池当前线程数超过 corePoolSize，则多余的线程空闲时间超过 keepAliveTime 时会被终止。</p></li><li><p>线程池有哪些拒绝策略<br>AbortPolicy：中止策略。默认的拒绝策略，直接抛出 RejectedExecutionException。调用者可以捕获这个异常，然后根据需求编写自己的处理代码。<br>DiscardPolicy：抛弃策略。什么都不做，直接抛弃被拒绝的任务。<br>DiscardOldestPolicy：抛弃最老策略。抛弃阻塞队列中最老的任务，相当于就是队列中下一个将要被执行的任务，然后重新提交被拒绝的任务。如果阻塞队列是一个优先队列，那么“抛弃最旧的”策略将导致抛弃优先级最高的任务，因此最好不要将该策略和优先级队列放在一起使用。<br>CallerRunsPolicy：调用者运行策略。在调用者线程中执行该任务。该策略实现了一种调节机制，该策略既不会抛弃任务，也不会抛出异常，而是将任务回退到调用者（调用线程池执行任务的主线程），由于执行任务需要一定时间，因此主线程至少在一段时间内不能提交任务，从而使得线程池有时间来处理完正在执行的任务。</p></li><li><p>Lock 和 synchronized 的不同之处 <br>1）Lock 是一个接口，而 synchronized 是 Java 中的关键字，synchronized 是内置的语言实现；<br>2）synchronized 在发生异常时，会自动释放线程占有的锁，因此不会导致死锁现象发生；而 Lock 在发生异常时，如果没有主动通过 unLock() 去释放锁，则很可能造成死锁现象，因此使用 Lock 时需要在 finally 块中释放锁；<br>3）Lock 可以让等待锁的线程响应中断，而 synchronized 却不行，使用 synchronized 时，等待的线程会一直等待下去，不能够响应中断；（I&#x2F;O 和 Synchronized 都能相应中断，即不需要处理 interruptionException 异常）<br>4）通过 Lock 可以知道有没有成功获取锁，而 synchronized 却无法办到；<br>5）Lock 可以提高多个线程进行读操作的效率。<br>在性能上来说，如果竞争资源不激烈，两者的性能是差不多的，而当竞争资源非常激烈时（即有大量线程同时竞争），此时 Lock 的性能要远远优于 synchronized。所以说，在具体使用时要根据适当情况选择。</p></li><li><p>锁的分类</p><p>可重入锁、不可重入锁；可中断锁、不可中断锁；公平锁、非公平锁；读写锁。</p></li><li><p>线程安全的 List<br>使用 Vector 容器 <br> 使用 Collections 的静态方法 synchronizedList(List<T> list)<br>采用 CopyOnWriteArrayList 容器</p></li><li><p>Http 常见字段：Host、Content-Length、Connection、Content-Type、Accept、Content-Encoding、Accept-Encoding</p></li><li><p>公钥加密，私钥解密。这个目的是为了保证内容传输的安全，因为被公钥加密的内容，其他人是无法解密的，只有持有私钥的人，才能解密出实际的内容；<br>私钥加密，公钥解密。这个目的是为了保证消息不会被冒充，因为私钥是不可泄露的，如果公钥能正常解密出私钥加密的内容，就能证明这个消息是来源于持有私钥身份的人发送的。</p></li><li><p>静态和非静态的嵌套类的区别 <br> 静态嵌套类使用时并不需要引用外部类。但非静态嵌套类 (内部类) 则必须引用外部类。<br>非静态嵌套类 (内部类) 可以访问外部类的静态和非静态成员。但静态嵌套类只能访问到外部类的静态成员，不可以访问外部类的非静态成员（实例成员）。<br> 非静态嵌套类(内部类) 不能单独实例化。必须先实例化外部类，才能实例化内部类。内部类可以引用外部类的数据和方法。因此，我们并不需要将外部类的引用传递给内部类的构造方法。这种机制，使得内部类更加简单明了。</p></li><li><p>TCP 和 UDP 区别：</p><ol><li>连接<br> TCP 是面向连接的传输层协议，传输数据前先要建立连接。<br> UDP 是不需要连接，即刻传输数据。</li><li>服务对象<br> TCP 是一对一的两点服务，即一条连接只有两个端点。<br> UDP 支持一对一、一对多、多对多的交互通信</li><li>可靠性<br> TCP 是可靠交付数据的，数据可以无差错、不丢失、不重复、按需到达。<br> UDP 是尽最大努力交付，不保证可靠交付数据。</li><li>拥塞控制、流量控制<br> TCP 有拥塞控制和流量控制机制，保证数据传输的安全性。<br> UDP 则没有，即使网络非常拥堵了，也不会影响 UDP 的发送速率。</li><li>首部开销<br> TCP 首部长度较长，会有一定的开销，首部在没有使用「选项」字段时是 20 个字节，如果使用了「选项」字段则会变长的。<br> UDP 首部只有 8 个字节，并且是固定不变的，开销较小。</li><li>传输方式<br> TCP 是流式传输，没有边界，但保证顺序和可靠。<br> UDP 是一个包一个包的发送，是有边界的，但可能会丢包和乱序。</li><li>分片不同<br> TCP 的数据大小如果大于 MSS 大小，则会在传输层进行分片，目标主机收到后，也同样在传输层组装 TCP 数据包，如果中途丢失了一个分片，只需要传输丢失的这个分片。<br> UDP 的数据大小如果大于 MTU 大小，则会在 IP 层进行分片，目标主机收到后，在 IP 层组装完数据，接着再传给传输层。</li></ol></li><li><p>进程间通信方式：匿名管道；命名管道；消息队列；共享内存；信号量；信号；套接字。</p></li><li><p>操作系统进程调度算法: 先来先服务算法；最短作业优先算法；高响应比优先调度算法；时间片轮转算法；优先级调度算法；多级反馈队列算法。</p></li><li><p>内存页面置换算法：最佳页面置换算法；先进先出置换算法；最近最久未使用的置换算法（LRU）；时钟页面置换算法；最不常用置换算法（LFU）。</p></li><li><p>磁盘调度算法：先来先服务；最短寻道时间；扫描算法（电梯算法）；循环扫描算法（只向一个方向处理，到达另一端后立即返回且中途不处理）。</p></li><li><p>信号初始化为 1，就代表着是互斥信号量，它可以保证共享内存在任何时刻只有一个进程在访问，这就很好的保护了共享内存；信号初始化为 0，就代表着是同步信号量，它可以保证进程 A 应在进程 B 之前执行。</p></li><li><p>非受检查异常，常见的有：<br>NullPointerException(空指针错误)<br>IllegalArgumentException(参数错误比如方法入参类型错误)<br>NumberFormatException（字符串转换为数字格式错误，IllegalArgumentException 的子类）<br>ArrayIndexOutOfBoundsException（数组越界错误）<br>ClassCastException（类型转换错误）<br>ArithmeticException（算术错误）<br>SecurityException （安全错误比如权限不够）<br>UnsupportedOperationException(不支持的操作错误比如重复创建同一用户)</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 求职 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL 学习笔记</title>
      <link href="/2022/06f12cbde5.html"/>
      <url>/2022/06f12cbde5.html</url>
      
        <content type="html"><![CDATA[<h2 id="MySQL 学习笔记"><a href="#MySQL 学习笔记" class="headerlink" title="MySQL 学习笔记"></a>MySQL 学习笔记 </h2><hr><h4 id="基础篇"><a href="# 基础篇" class="headerlink" title="基础篇"></a> 基础篇 </h4><ol><li><p>ORM 思想：数据库中的一个表 &lt;——&gt;Java 或其他语言中的一个类；表中的一条数据 &lt;——&gt; 类中的一个对象（或实体）；表中的一列 &lt;——&gt; 类中的一个字段（field）、属性。</p></li><li><p>E-R 模型中的三个主要概念：实体集；属性；联系集。</p></li><li><p> 表的关联关系：一对一；一对多；多对多；自我引用。</p></li><li><p>DDL（数据定义语言）：这些语句定义了不同的数据库、表、视图、索引等数据库对象，还可以用来创建、删除、修改数据库和数据表的结构，主要的语句关键字包括 CREATE、DROP、ALTER 等。</p></li><li><p>DML（数据操作语言）：用于添加、删除、更新和查询数据库记录，并检查数据完整性，主要的语句关键字包括 INSERT、DELETE、UPDATE、SELECT 等。</p></li><li><p>DCL（数据控制语言）：用于定义数据库、表、字段、用户的访问权限和安全级别，主要的关键字包括 GRANT、REVOKE、COMMIT、ROLLBACK、SAVEPOINT 等。</p></li><li><p> 空值（NULL）参与运算结果一定为 NULL。</p></li><li><p> 过滤条件，WHERE 必须声明在 FROM 结构的后面。</p></li><li><p> 在 SQL 中，+ 没有连接的作用，仅表示加法运算，当字符串参与运算时会将字符串隐式转换为数值。</p></li><li><p> 除法结果无论是否可以除尽，结果都是浮点数型。</p></li><li><p> 取模运算结果的正负和被模的数一致。</p></li><li><p>“%”作为占位符代表了 0~ 任意数量 的任意字符。</p></li><li><p>“_”作为占位符代表了一个不确定的字符。</p></li><li><p>ASC（升序）；DESC（降序）。</p></li><li><p> 列的别名可以在 ORDER BY 中使用，不可以在 WHERE 中使用。</p></li><li><p> 如果给表起了别名，后续在 SELECT 或 FROM 中一定要使用别名。</p></li><li><p>UNION ALL 不执行去重操作（也就是说两表重复部分会有两份数据），UNION 执行去重操作，但是 UNION ALL 效率比 UNION 更高。</p></li><li><p>USING 必须指定同名字段。</p></li><li><p>COUNT 函数不计算值为 NULL。</p></li><li><p> 如果过滤条件中使用了聚合函数，则必须使用 HAVING 来替换 WHERE，否则会报错。</p></li><li><p>HAVING 必须声明在 GROUP BY 后面，通常也和 GROUP BY 一起使用。</p></li><li><p>HAVING 的优点：使用范围比 WHERE 广，可以用于分组筛选。</p></li><li><p>WHERE 的优点：如果查询中涉及到关联表的查询，则 WHERE 的效率更高，因为 WHERE 是先筛选再关联，HAVING 是先关联再筛选，则 WHERE 可以用一个筛选后的小数据集进行关联。</p></li><li><p>SQL99 基本语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SELECT ...,...,...（存在聚合函数）</span><br><span class="line">FROM ... JOIN ... ON（多表的连接条件）</span><br><span class="line">WHERE （不包含聚合函数的过滤条件）</span><br><span class="line">GROUP BY ..., ...</span><br><span class="line">HAVING （包含聚合函数的过滤条件）</span><br><span class="line">ORDER BY</span><br><span class="line">LIMIT</span><br></pre></td></tr></table></figure></li><li><p>SQL 语句执行过程：FROM -&gt; ON -&gt; (LEFT&#x2F;RIGHT JOIN) -&gt; WHERE -&gt; GROUP BY -&gt; HAVING -&gt; SELECT -&gt; DISTINCT -&gt; ORDER BY -&gt; LIMIT</p></li><li><p> 使用子查询时一定要注意子查询时多行子查询还是单行子查询。</p></li><li><p> 多行比较操作符（IN, ANY, ALL, SOME）。</p></li><li><p> 聚合函数不允许嵌套。</p></li><li><p> 关联子查询（通常情况下因为子查询中的表用到了外部的表，并进行了条件关联）。</p></li><li><p>CREATE TABLE … AS SELECT … …将查询的结果作为新建的表。</p></li><li><p>TRUNCATE TABLE 和 DELETE FROM 都可以实现表的清空功能并且保留表的结构。但是 TRUNCATE 不执行回滚；DELETE FROM 删除数据后可以实现回滚（通过在执行前执行 SET autocommit &#x3D; FALSE）。</p></li><li><p> 向表插入数据：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO ...(字段名)</span><br><span class="line">VALUES();</span><br></pre></td></tr></table></figure></li><li><p> 修改数据：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UPDATE ... SET ... WHERE...</span><br></pre></td></tr></table></figure></li><li><p> 删除外键约束后，必须手动删除索引。</p></li><li><p> 为什么需要使用视图：视图一方面可以帮助我们使用表的一部分而不是所有的表，另一方面也可以针对不同的用户制定不同的查询视图。</p></li><li><p> 视图的不足：维护的问题。</p></li><li><p> 存储过程的好处：简化操作，提高了 SQL 的重用性；减少网络传输量；减少了 SQL 暴露在网络上的风险。</p></li><li><p> 存储过程一般用于更新数据；存储函数一般用于查询数据并返回值。</p></li><li><p> 存储过程调用：CALL 过程名；存储函数调用：SELECT 函数名。</p></li><li><p> 存储过程不可以放在查询语句中，存储函数可以。</p><hr></li></ol><h4 id="高级篇"><a href="# 高级篇" class="headerlink" title="高级篇"></a> 高级篇 </h4><ol><li><p>MySQL5.7 之前，InnoDB 存储引擎表结构文件以.frm 文件格式，表数据以.ibd 文件格式分别存储；MySQL8.0 之后表结构和表数据统一放在.ibd 文件格式下。</p></li><li><p>MyISAM 存储引擎表结构文件以.frm 文件格式，表数据和索引分开存放，表数据存放于.MYD 下，表索引存放于.MYI 下。</p></li><li><p>GRANT 权限 1、权限 2 ON 数据库名称. 表名称 TO 用户名 @用户地址 </p></li><li><p>REVOKE 权限 1、权限 2 ON 数据库名称. 表名称 FROM 用户名 @用户地址 </p></li><li><table><thead><tr><th align="center"> 对比项 </th><th align="center">MyISAM</th><th align="center">InnoDB</th></tr></thead><tbody><tr><td align="center"> 外键 </td><td align="center"> 不支持 </td><td align="center"> 支持 </td></tr><tr><td align="center"> 事务 </td><td align="center"> 不支持 </td><td align="center"> 支持 </td></tr><tr><td align="center"> 行表锁 </td><td align="center"> 表锁；即使操作一条记录也会锁住整个表，不适合高并发的操作 </td><td align="center"> 行锁，操作时只锁住某一行，不对其他行有影响，适合高并发的操作 </td></tr><tr><td align="center"> 缓存 </td><td align="center"> 只缓存索引，不缓存真实数据 </td><td align="center"> 不仅缓存索引，还缓存真实数据，对内存要求较高 </td></tr><tr><td align="center"> 自带系统表使用 </td><td align="center">Y</td><td align="center">N</td></tr><tr><td align="center"> 关注点 </td><td align="center"> 性能；节省资源，消耗少，简单业务 </td><td align="center"> 事务：并发写、事务、更大资源 </td></tr><tr><td align="center"> 默认安装 </td><td align="center">Y</td><td align="center">Y</td></tr><tr><td align="center"> 默认使用 </td><td align="center">Y</td><td align="center">Y</td></tr></tbody></table></li><li><p>MySQL5.5 之前的默认存储引擎是 MyISAM，5.5 之后改成了 InnoDB。InnoDB 提供了良好的事务管理、崩溃修复能力和并发控制，所以对于要求事务完整性的场合需要选择 InnoDB，比如数据操作除了插入和查询之外还包含有很多更新、删除操作，像财务系统等对数据准确性要求更高的系统。缺点是其读写效率稍差，占用的数据空间相对比较大。MyISAM 存储引擎的优势在于占用空间小，处理速度更快；缺点是不支持事务的完整性和并发性，适用于以读操作和插入操作为主的小型应用。</p></li><li><p>Archive 存储引擎仅仅支持插入和查询两种功能，拥有很好的压缩机制，采用了行级锁，适合日志和数据采集（档案）类应用，适合存储大量的独立的作为历史记录的数据，拥有很高的插入效率，但是对查询的支持较差。</p></li><li><p>Memory 引擎采用的逻辑介质是内存，响应速度很快，但是当 mysqld 守护进程崩溃的时候数据会丢失，另外，要求存储的数据是数据长度不变的格式，比如 Blob 和 Text 类型的数据不可用。Memory 同时支持哈希索引和 B+ 数索引。使用 Memory 引擎的场景：数据量比较少，而且非常频繁地进行访问，如果数据是临时的，而且必须立即可用得到，那么就可以放在内存中，存储在 Memory 表中的数据如果突然间丢失的话也没有太大的关系。</p></li><li><p> 索引的优点：提高数据检索效率，降低数据库的 IO 成本；通过创建唯一索引，可以保证数据库表中每一行数据的唯一性；在实现数据的参考完整性方面，可以加速表和表之间的连接；在使用分组和排序子句进行数据查询时，可以显著减少查询中分组和排序的时间。</p></li><li><p> 索引的缺点：创建索引和维护索引需要耗费时间；索引需要占用磁盘空间；降低了更新表的速度。</p></li><li><p> 聚簇索引是一种数据存储方式，所有的用户记录都存储在了叶子节点。页内的记录按照主键的大小顺序排成一个单向链表；各个存放用户记录的页根据页中用户记录的主键大小顺序排成一个双向链表。这种索引数据访问更快，因为索引和数据保存在同一个 B+ 树中；适合范围查找。但是插入速度严重依赖于插入顺序，更新主键的代价很高。</p></li><li><p> 二级索引也保存了主键值，目的是为了保证内节点目录项记录的唯一性。</p></li><li><p>MyISAM 索引存的是数据的地址，InnoDB 根据聚簇索引和非聚簇索引区分。</p></li><li><p> 在 InnoDB 引擎中，不建议主键使用过长的字段，因为在索引结构中每一个二级索引节点都需要包含主键信息。</p></li><li><p> 哈希索引的局限性：只能够处理精确值，不能处理范围查找；数据存储没有顺序，在 ORDER BY 的情况下，使用哈希索引还需要对数据重新排序；对于联合索引的情况，hash 值是将联合索引键合并后一起计算的，无法对单独的一个键或者几个索引键进行查询；如果等值太多，会造成哈希冲突，此时哈希的优势无法体现。</p></li><li><p>B+ 树相比于 B 树的优势：查询效率更稳定，所有的数据都存放在叶子节点上；查询效率更高，中间节点可以存放更多的关键字，比 B 树阶数更高，深度更低；叶子节点上的数据之间用单链表连接，适合范围查找。</p></li><li><p> 页结构：文件头部；页头；最大最小记录；用户记录；空闲空间；页目录；文件尾部。</p></li><li><p> 文件头部主要描述了各种页的通用信息（比如页的编号；上一页；下一页），其中文件头部的校验和和文件尾部的校验和共同作用以判断页是否完整地从磁盘中读取或者写入磁盘（同步）。</p></li><li><p> 目录页主要是为了对页进行进一步分组，加速查找过程。最小记录自成一组，最后一组 4-8 条记录。</p></li><li><p> 添加索引 </p>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CREATE INDEX ... ... ON ... ...</span><br><span class="line">ALTER TABLE ... ... ADD INDEX ... ...</span><br></pre></td></tr></table></figure></li><li><p> 删除索引 </p>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DROP INDEX ... ... ON ... ...</span><br><span class="line">ALTER TABLE ... ... DROP INDEX ... ...</span><br></pre></td></tr></table></figure></li><li><p> 适合作为索引的情况：</p><p>   （1）字段的数值有唯一性的限制 <br>   （2）频繁作为 WHERE 查询条件的字段 <br>   （3）经常 GROUP BY 和 ORDER BY 的列 <br>   （4）UPDATE、DELETE 的 WHERE 条件列 <br>   （5）DISTINCT 字段 <br>   （6）使用列的类型小的字段创建索引 <br>   （7）使用字符串前缀创建索引 <br>   （8）区分度高的、散列性高的列适合作为索引 <br>   （9）使用最频繁的列放到联合索引的左侧 </p></li><li><p> 不适合作为索引的情况：</p><p>   （1）在 WHERE 中使用不到的字段 <br>   （2）数据量小的表最好不设置索引 <br>   （3）大量重复数据的列 <br>   （4）经常更新的表 <br>   （5）不建议使用无序的值作为索引 </p></li><li><p>EXPLAIN 语句输出的各个列的作用：</p><table><thead><tr><th align="left"> 列名 </th><th align="left"> 描述 </th></tr></thead><tbody><tr><td align="left">id</td><td align="left"></td></tr><tr><td align="left">select_type</td><td align="left"></td></tr><tr><td align="left">table</td><td align="left"> 表名 </td></tr><tr><td align="left">partitions</td><td align="left"> 匹配的分区信息 </td></tr><tr><td align="left">type</td><td align="left"> 针对单表的访问方法：system;const;eq_ref;ref;fulltext;ref_or_null;index_merge;unique_subquery;index_subquery;range;index;ALL</td></tr><tr><td align="left">possible_keys</td><td align="left"> 可能用到的索引 </td></tr><tr><td align="left">key</td><td align="left"> 实际使用的索引 </td></tr><tr><td align="left">key_len</td><td align="left"> 实际使用到的索引长度 </td></tr><tr><td align="left">ref</td><td align="left"> 当使用索引列等值查询时，与索引列进行等值匹配的对象信息 </td></tr><tr><td align="left">rows</td><td align="left"> 预估的需要读取的记录条数 </td></tr><tr><td align="left">filtered</td><td align="left"> 某个表经过搜索条件过滤后剩余记录条数的百分比 </td></tr><tr><td align="left">Extra</td><td align="left"> 一些额外的信息 </td></tr></tbody></table></li><li><p>EXPLAIN 四种输出模式：传统格式；JSON 格式；TREE 格式；可视化输出。</p></li><li><p>1NF(第一范式)<br>   属性（对应于表中的字段）不能再被分割，也就是这个字段只能是一个值，不能再分为多个其他的字段了。1NF 是所有关系型数据库的最基本要求 ，也就是说关系型数据库中创建的表一定满足第一范式。<br>   2NF(第二范式)<br>   2NF 在 1NF 的基础之上，消除了非主属性对于码的部分函数依赖。第二范式在第一范式的基础上增加了一个列，这个列称为主键，非主属性都依赖于主键。<br>   3NF(第三范式)<br>   3NF 在 2NF 的基础之上，消除了非主属性对于码的传递函数依赖 。符合 3NF 要求的数据库设计，基本上解决了数据冗余过大，插入异常，修改异常，删除异常的问题。比如在关系 R(学号 , 姓名, 系名，系主任) 中，学号 → 系名，系名 → 系主任，存在非主属性系主任对于学号的传递函数依赖，所以该表的设计，不符合 3NF 的要求。</p></li><li><p> 不满足第二范式可能存在的问题：数据冗余；插入异常；删除异常；更新异常。</p></li><li><p> 范式的优点：消除了数据的冗余。范式的缺点：降低了查询效率。</p></li><li><p> 脏读：如果一个事务「读到」了另一个「未提交事务修改过的数据」，就意味着发生了「脏读」现象。</p></li><li><p> 不可重复读：在一个事务内多次读取同一个数据，如果出现前后两次读到的数据不一样的情况，就意味着发生了「不可重复读」现象。</p></li><li><p> 幻读：在一个事务内多次查询某个符合查询条件的「记录数量」，如果出现前后两次查询到的记录数量不一样的情况，就意味着发生了「幻读」现象。</p></li><li><p> 在「读未提交」隔离级别下，可能发生脏读、不可重复读和幻读现象；<br>   在「读提交」隔离级别下，可能发生不可重复读和幻读现象，但是不可能发生脏读现象；<br>   在「可重复读」隔离级别下，可能发生幻读现象，但是不可能脏读和不可重复读现象；<br>   在「串行化」隔离级别下，脏读、不可重复读和幻读现象都不可能会发生。</p></li><li><p>InnoDB 引擎的默认隔离级别虽然是「可重复读」，但是它通过 next-key lock 锁（行锁和间隙锁的组合）来锁住记录之间的“间隙”和记录本身，防止其他事务在这个记录之间插入新的记录，这样就避免了幻读现象。</p></li><li><p> 当我们用唯一索引进行等值查询的时候，查询的记录存不存在，加锁的规则也会不同：<br>  当查询的记录是存在的，在用「唯一索引进行等值查询」时，next-key lock 会退化成「记录锁」；<br>  当查询的记录是不存在的，在用「唯一索引进行等值查询」时，next-key lock 会退化成「间隙锁」。</p></li><li><p> 当我们用非唯一索引进行等值查询的时候，查询的记录存不存在，加锁的规则也会不同：<br> 当查询的记录存在时，除了会加 next-key lock 外，还额外加间隙锁，也就是会加两把锁；<br> 当查询的记录不存在时，只会加 next-key lock，然后会退化为间隙锁，也就是只会加一把锁。</p></li><li><p>binlog 有 3 种格式类型，分别是 STATEMENT（默认格式）、ROW、 MIXED，区别如下：<br>  STATEMENT：每一条修改数据的 SQL 都会被记录到 binlog 中（相当于记录了逻辑操作，所以针对这种格式， binlog 可以称为逻辑日志），主从复制中 slave 端再根据 SQL 语句重现。但 STATEMENT 有动态函数的问题，比如你用了 uuid 或者 now 这些函数，你在主库上执行的结果并不是你在从库执行的结果，这种随时在变的函数会导致复制的数据不一致；<br>  ROW：记录行数据最终被修改成什么样了（这种格式的日志，就不能称为逻辑日志了），不会出现 STATEMENT 下动态函数的问题。但 ROW 的缺点是每行数据的变化结果都会被记录，比如执行批量 update 语句，更新多少行数据就会产生多少条记录，使 binlog 文件过大，而在 STATEMENT 格式下只会记录一个 update 语句而已；<br>  MIXED：包含了 STATEMENT 和 ROW 模式，它会根据不同的情况自动使用 ROW 模式和 STATEMENT 模式。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 求职 </tag>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CNN（卷积神经网络）学习笔记</title>
      <link href="/2022/04831f11ff.html"/>
      <url>/2022/04831f11ff.html</url>
      
        <content type="html"><![CDATA[<h1 id="CNN- 卷积神经网络 - 学习笔记"><a href="#CNN- 卷积神经网络 - 学习笔记" class="headerlink" title="CNN(卷积神经网络)学习笔记"></a>CNN(卷积神经网络)学习笔记</h1><hr><h3 id="基本概念"><a href="# 基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p><img data-src="/images/CNN.png"></p><p>​神经网络的基本组成为输入层、隐藏层和输出层。而卷积神经网络和一般的神经网络的区别在于将隐藏层细分为了卷积层、池化层和激活层，其中卷积层通过卷积核在原始图像上平移提取特征；池化层（一般为最大池化和平均池化）压缩数据和参数的量，减小过拟合，降低网路的复杂程度；激活层用来增加非线性分割的能力。</p><p>​为什么需要卷积神经网络：图片数据由很多的像素点组成，每个像素点在不同通道（一般为 RGB，3 种通道）的值共同表征一张图片。因此一般来说，一张图片数据的输入为 N*N*C（其中 N*N 为图片的像素点个数，C 为通道数），而在现实中，N 一般可以达到上千，对于一般的神经网络，假设一层隐藏层的神经元个数为 M，对于该层隐藏层，需要的参数个数为 N*N*M，这会导致神经网络的参数过多了。我们知道，神经网络的学习能力一般是与神经网络的参数个数正相关的，过多的参数会导致最终模型的学习能力过强，过拟合，同时，过多的参数也会增加计算的复杂度。</p><p>​而卷积神经网络可以大大减少神经网络所需要的参数。卷积神经网络的核心就是卷积核，而卷积核的本质就是一个大小很小的矩阵（三维输入的神经元，长度 * 宽度 * 通道），我们通过将这个矩阵在图像上平移运算提取图像的某种特征。卷积核不同，提取的特征也就不同。</p><p>​对于卷积核，我们必须明确，卷积核的深度应该和输入数据的深度一致（比如 3 通道的图像，则处理的卷积核深度也为 3，因为这一特性，在使用一些 api 的时候不需要人工地指定该值），其次，卷积核的数量等价于经卷积核运算输出的维度，池化层其实也可以看做特殊的一种卷积核，因为一般经过池化后输出数据的大小会小于输入数据的大小（通过设置步长），为保证不损失太多的信息，通常会选择在池化层增加“卷积核”的数量从而产生更多维度的数据。</p><h5 id="图片卷积输出大小公式："><a href="# 图片卷积输出大小公式：" class="headerlink" title="图片卷积输出大小公式："></a>图片卷积输出大小公式：</h5><p>输入图片大小——W*W</p><p>卷积核大小——F*F</p><p>步长——S</p><p>padding 的大小——P<br>$$<br>N&#x3D;(W-F+2<em>P)&#x2F;S+1<br>$$<br>输出图片大小为 N</em>N</p><p>PS: 对这些超参数，常见的设置是 F&#x3D;3，S&#x3D;1，P&#x3D;1</p><h5 id="卷积层参数个数计算公式："><a href="# 卷积层参数个数计算公式：" class="headerlink" title="卷积层参数个数计算公式："></a>卷积层参数个数计算公式：</h5><p>存在 bias：<br>$$<br>Count&#x3D;C_{out}*(k_{weight}*k_{height}*C_{in}+1)<br>$$</p><hr><p>​卷积和池化相当于做特征工程，最后的全连接层在整个卷积神经网络中起到“分类器”的作用（如果 FC 层作为最后一层，再加上 softmax 或者 wx+b，则可以分别作为分类或回归的作用，即“分类器”或“回归器”的作用）；如果作为倒数第 2，3 层的话，FC 层的作用是信息融合，增强信息表达。</p><hr><h3 id="经典案例"><a href="# 经典案例" class="headerlink" title="经典案例"></a>经典案例 </h3><h5 id="LeNet"><a href="#LeNet" class="headerlink" title="LeNet"></a>LeNet</h5><p>LeNet 神经网络由深度学习三巨头之一的 Yan LeCun 提出，他同时也是卷积神经网络 (CNN，Convolutional Neural Networks) 之父。LeNet 主要用来进行手写字符的识别与分类，并在美国的银行中投入了使用。LeNet 的实现确立了 CNN 的结构，现在神经网络中的许多内容在 LeNet 的网络结构中都能看到，例如卷积层，Pooling 层，ReLU 层。虽然 LeNet 早在 20 世纪 90 年代就已经提出了，但由于当时缺乏大规模的训练数据，计算机硬件的性能也较低，因此 LeNet 神经网络在处理复杂问题时效果并不理想。LeNet 的设计较为简单，其处理复杂数据的能力有限；此外，在近年来的研究中许多学者已经发现全连接层的计算代价过大，而使用全部由卷积层组成的神经网络。</p><h6 id="模型结构："><a href="# 模型结构：" class="headerlink" title="模型结构："></a>模型结构：</h6><p><img data-src="/images/LeNet.jpeg"></p><p>LeNet-5 包含七层，不包括输入，每一层都包含可训练参数（权重)，当时使用的输入数据是 32*32 像素的图像。下面逐层介绍 LeNet-5 的结构，并且，卷积层将用 Cx 表示，子采样层则被标记为 Sx，完全连接层被标记为 Fx，其中 x 是层索引。</p><p>层 C1 是具有六个 5*5 的卷积核的卷积层（convolution），特征映射的大小为 28*28，这样可以防止输入图像的信息掉出卷积核边界。C1 包含 156 个可训练参数和 122304 个连接。</p><p>层 S2 是输出 6 个大小为 14*14 的特征图的子采样层（subsampling&#x2F;pooling）。每个特征图中的每个单元连接到 C1 中的对应特征图中的 2*2 个邻域。S2 中单位的四个输入相加，然后乘以可训练系数（权重），然后加到可训练偏差（bias）。结果通过 S 形函数传递。由于 2*2 个感受域不重叠，因此 S2 中的特征图只有 C1 中的特征图的一半行数和列数。S2 层有 12 个可训练参数和 5880 个连接。</p><p>层 C3 是具有 16 个 5*5 的卷积核的卷积层。前六个特征图的输入是 S2 中的三个特征图的每个连续子集，接下来的六个特征图的输入则来自四个连续子集的输入，接下来的三个特征图的输入来自不连续的四个子集。最后一个特征图的输入来自 S2 所有特征图。C3 层有 1516 个可训练参数和 151600 个连接。</p><p>层 S4 是与 S2 类似，大小为 2*2，输出为 16 个 5*5 的特征图。S4 层有 32 个可训练参数和 2000 个连接。</p><p>层 C5 是具有 120 个大小为 5*5 的卷积核的卷积层。每个单元连接到 S4 的所有 16 个特征图上的 5*5 邻域。这里，因为 S4 的特征图大小也是 5*5，所以 C5 的输出大小是 1*1。因此 S4 和 C5 之间是完全连接的。C5 被标记为卷积层，而不是完全连接的层，是因为如果 LeNet-5 输入变得更大而其结构保持不变，则其输出大小会大于 1*1，即不是完全连接的层了。C5 层有 48120 个可训练连接。</p><p>F6 层完全连接到 C5，输出 84 张特征图。它有 10164 个可训练参数。这里 84 与输出层的设计有关。</p><h6 id="各层参数变化："><a href="# 各层参数变化：" class="headerlink" title="各层参数变化："></a>各层参数变化：</h6><p>C1<br> 输入大小：32*32<br> 核大小：5*5<br> 核数目：6<br> 输出大小：28*28*6<br> 训练参数数目：(5*5+1)*6&#x3D;156<br> 连接数：(5*5+1)*6*(32-2-2)*(32-2-2)&#x3D;122304</p><p>S2<br> 输入大小：28*28*6<br> 核大小：2*2<br> 核数目：1<br> 输出大小：14*14*6<br> 训练参数数目：2*6&#x3D;12，2&#x3D;(w,b)<br> 连接数：(2*2+1)*1*14*14*6 &#x3D; 5880</p><p>C3<br> 输入大小：14*14*6<br> 核大小：5*5<br> 核数目：16<br> 输出大小：10*10*16<br> 训练参数数目：6*(3*5*5+1) + 6*(4*5*5+1) + 3*(4*5*5+1) + 1*(6*5*5+1)&#x3D;1516<br> 连接数：(6*(3*5*5+1) + 6*(4*5*5+1) + 3*(4*5*5+1) + 1*(6*5*5+1))*10*10&#x3D;151600</p><p>S4<br> 输入大小：10*10*16<br> 核大小：2*2<br> 核数目：1<br> 输出大小：5*5*16<br> 训练参数数目：2*16&#x3D;32<br> 连接数：(2*2+1)*1*5*5*16&#x3D;2000</p><p>C5<br> 输入大小：5*5*16<br> 核大小：5*5<br> 核数目：120<br> 输出大小：120*1*1<br> 训练参数数目：(5*5*16+1)*120*1*1&#x3D;48120（因为是全连接）<br> 连接数：(5*5*16+1)*120*1*1&#x3D;48120</p><p>F6<br> 输入大小：120<br> 输出大小：84<br> 训练参数数目：(120+1)*84&#x3D;10164<br> 连接数：(120+1)*84&#x3D;10164</p><h6 id="实验代码："><a href="# 实验代码：" class="headerlink" title="实验代码："></a>实验代码：</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 导入数据</span></span><br><span class="line">mnist = tf.keras.datasets.mnist</span><br><span class="line">(x_train, y_train), (x_test, y_test) = mnist.load_data()</span><br><span class="line"><span class="comment"># 将图片从 28*28 扩展成 32*32</span></span><br><span class="line">X_train = np.pad(x_train, ((<span class="number">0</span>, <span class="number">0</span>), (<span class="number">2</span>, <span class="number">2</span>), (<span class="number">2</span>, <span class="number">2</span>)), <span class="string">&#x27;constant&#x27;</span>, constant_values=<span class="number">0</span>)</span><br><span class="line">X_test = np.pad(x_test, ((<span class="number">0</span>, <span class="number">0</span>), (<span class="number">2</span>, <span class="number">2</span>), (<span class="number">2</span>, <span class="number">2</span>)), <span class="string">&#x27;constant&#x27;</span>, constant_values=<span class="number">0</span>)</span><br><span class="line">X_train = X_train.astype(<span class="string">&#x27;float32&#x27;</span>)</span><br><span class="line">X_test = X_test.astype(<span class="string">&#x27;float32&#x27;</span>)</span><br><span class="line"><span class="comment"># 数据正则化</span></span><br><span class="line">X_train /= <span class="number">255</span></span><br><span class="line">X_test /= <span class="number">255</span></span><br><span class="line"><span class="comment"># 数据维度转换</span></span><br><span class="line">X_train = X_train.reshape(X_train.shape[<span class="number">0</span>], <span class="number">32</span>, <span class="number">32</span>, <span class="number">1</span>)</span><br><span class="line">X_test = X_test.reshape(X_test.shape[<span class="number">0</span>], <span class="number">32</span>, <span class="number">32</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">model = tf.keras.Sequential()</span><br><span class="line"><span class="comment"># 卷积层，6 个 5x5 卷积核，步长为 1，relu 激活，第一层需指定 input_shape</span></span><br><span class="line">model.add(tf.keras.layers.Conv2D(filters=<span class="number">6</span>, kernel_size=(<span class="number">5</span>, <span class="number">5</span>), strides=(<span class="number">1</span>, <span class="number">1</span>),</span><br><span class="line">                                 activation=<span class="string">&#x27;relu&#x27;</span>, input_shape=(<span class="number">32</span>, <span class="number">32</span>, <span class="number">1</span>)))</span><br><span class="line"><span class="comment"># 平均池化，池化窗口默认为 2</span></span><br><span class="line">model.add(tf.keras.layers.AveragePooling2D(pool_size=(<span class="number">2</span>, <span class="number">2</span>), strides=<span class="number">2</span>))</span><br><span class="line"><span class="comment"># 卷积层，16 个 5x5 卷积核，步为 1，relu 激活</span></span><br><span class="line">model.add(tf.keras.layers.Conv2D(filters=<span class="number">16</span>, kernel_size=(</span><br><span class="line">    <span class="number">5</span>, <span class="number">5</span>), strides=(<span class="number">1</span>, <span class="number">1</span>), activation=<span class="string">&#x27;relu&#x27;</span>))</span><br><span class="line"><span class="comment"># 平均池化，池化窗口默认为 2</span></span><br><span class="line">model.add(tf.keras.layers.AveragePooling2D(pool_size=(<span class="number">2</span>, <span class="number">2</span>), strides=<span class="number">2</span>))</span><br><span class="line"><span class="comment"># 需展平后才能与全连接层相连</span></span><br><span class="line">model.add(tf.keras.layers.Flatten())</span><br><span class="line"><span class="comment"># 全连接层，输出为 120，relu 激活</span></span><br><span class="line">model.add(tf.keras.layers.Dense(units=<span class="number">120</span>, activation=<span class="string">&#x27;relu&#x27;</span>))</span><br><span class="line"><span class="comment"># 全连接层，输出为 84，relu 激活</span></span><br><span class="line">model.add(tf.keras.layers.Dense(units=<span class="number">84</span>, activation=<span class="string">&#x27;relu&#x27;</span>))</span><br><span class="line"><span class="comment"># 全连接层，输出为 10，Softmax 激活</span></span><br><span class="line">model.add(tf.keras.layers.Dense(units=<span class="number">10</span>, activation=<span class="string">&#x27;softmax&#x27;</span>))</span><br><span class="line"><span class="comment"># 查看网络结构</span></span><br><span class="line">model.summary()</span><br><span class="line"><span class="comment"># 超参数设置</span></span><br><span class="line">num_epochs = <span class="number">10</span></span><br><span class="line">batch_size = <span class="number">64</span></span><br><span class="line">learning_rate = <span class="number">0.01</span></span><br><span class="line"><span class="comment"># 优化器</span></span><br><span class="line">adam_optimizer = tf.keras.optimizers.Adam(learning_rate)</span><br><span class="line"><span class="comment"># 编译</span></span><br><span class="line">model.<span class="built_in">compile</span>(optimizer=adam_optimizer,</span><br><span class="line">              loss=tf.keras.losses.sparse_categorical_crossentropy,</span><br><span class="line">              metrics=[<span class="string">&#x27;accuracy&#x27;</span>])</span><br><span class="line">training = model.fit(x=X_train,</span><br><span class="line">                     y=y_train,</span><br><span class="line">                     batch_size=batch_size,</span><br><span class="line">                     epochs=num_epochs,</span><br><span class="line">                     validation_split=<span class="number">0.20</span>)</span><br><span class="line"><span class="built_in">print</span>(model.evaluate(X_test, y_test))</span><br><span class="line"><span class="comment"># 保存模型</span></span><br><span class="line">model.save(<span class="string">&quot;LeNet_model&quot;</span>, save_format=<span class="string">&quot;tf&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示训练过程</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show_process</span>(<span class="params">training, train, validation</span>):</span><br><span class="line">    plt.plot(training.history[train], linestyle=<span class="string">&quot;-&quot;</span>, color=<span class="string">&quot;b&quot;</span>)</span><br><span class="line">    plt.plot(training.history[validation], linestyle=<span class="string">&quot;--&quot;</span>, color=<span class="string">&quot;r&quot;</span>)</span><br><span class="line">    plt.title(<span class="string">&quot;training_history&quot;</span>)</span><br><span class="line">    plt.xlabel(<span class="string">&quot;epoch&quot;</span>)</span><br><span class="line">    plt.ylabel(train)</span><br><span class="line">    plt.legend([<span class="string">&quot;train&quot;</span>, <span class="string">&quot;validation&quot;</span>], loc=<span class="string">&quot;lower right&quot;</span>)</span><br><span class="line">    plt.show()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">show_process(training, <span class="string">&quot;accuracy&quot;</span>, <span class="string">&quot;val_accuracy&quot;</span>)</span><br><span class="line">show_process(training, <span class="string">&quot;loss&quot;</span>, <span class="string">&quot;val_loss&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用模型</span></span><br><span class="line">predict_x = model.predict(X_test)</span><br><span class="line">prediction = np.argmax(predict_x, axis=<span class="number">1</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">    index = np.random.randint(<span class="number">0</span>, <span class="number">10000</span>)</span><br><span class="line">    plt.subplot(<span class="number">1</span>, <span class="number">4</span>, i + <span class="number">1</span>)</span><br><span class="line">    plt.axis(<span class="string">&quot;off&quot;</span>)</span><br><span class="line">    plt.imshow(x_test[index], cmap=<span class="string">&quot;gray&quot;</span>)</span><br><span class="line">    plt.title(<span class="string">&quot;y=&quot;</span> + <span class="built_in">str</span>(y_test[index]) + <span class="string">&quot;\ny_pred=&quot;</span> + <span class="built_in">str</span>(prediction[index]))</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><h6 id="实验结果："><a href="# 实验结果：" class="headerlink" title="实验结果："></a>实验结果：</h6><p><img data-src="/images/LeNet_acc.png"></p><p><img data-src="/images/LeNet_loss.png"></p><p><img data-src="/images/LeNet_res.png"></p><hr><h5 id="AlexNet"><a href="#AlexNet" class="headerlink" title="AlexNet"></a>AlexNet</h5><p>AlexNet 由 Geoffrey 和他的学生 Alex 提出，并在 2012 年的 ILSVRC 竞赛中获得了第一名。Alexnet 共有 8 层结构，前 5 层为卷积层，后三层为全连接层。AlexNet 网络结构具有如下特点：</p><ol><li>AlexNet 在激活函数上选取了非线性非饱和的 relu 函数，在训练阶段梯度衰减快慢方面，relu 函数比传统神经网络所选取的非线性饱和函数（如 sigmoid 函数，tanh 函数）要快许多。</li><li>AlexNet 在双 gpu 上运行，每个 gpu 负责一半网络的运算。</li><li>采用局部响应归一化（LRN）。对于非饱和函数 relu 来说，不需要对其输入进行标准化，但 Alex 等人发现，在 relu 层加入 LRN，可形成某种形式的横向抑制，从而提高网络的泛华能力。</li><li>池化方式采用 overlapping pooling。即池化窗口的大小大于步长，使得每次池化都有重叠的部分。（ps: 这种重叠的池化方式比传统无重叠的池化方式有着更好的效果，且可以避免过拟合现象的发生）</li><li>使用随机丢弃技术（dropout）选择性地忽略训练中的单个神经元，避免模型的过拟合。</li></ol><h6 id="模型结构：-1"><a href="# 模型结构：-1" class="headerlink" title="模型结构："></a>模型结构：</h6><p><img data-src="/images/AlexNet.png"></p><p>AlexNet 一共有 8 层</p><p>第一层：卷积层 1，输入为 224 × 224 × 3 的图像，卷积核的数量为 96，论文中两片 GPU 分别计算 48 个核; 卷积核的大小为 11 × 11 × 3，stride &#x3D; 4，padding &#x3D; 2。然后进行 (Local Response Normalized), 后面跟着池化 pool_size &#x3D; (3, 3), stride &#x3D; 2, padding &#x3D; 0 最终获得第一层卷积的 feature map，最终第一层卷积的输出为 96×55×55；</p><p>第二层：卷积层 2，输入为上一层卷积的 feature map， 卷积核的个数为 256 个，论文中的两个 GPU 分别有 128 个卷积核。卷积核的大小为：5 × 5 × 48, padding &#x3D; 2, stride &#x3D; 1; 然后做 LRN， 最后 max_pooling, pool_size &#x3D; (3, 3), stride &#x3D; 2；</p><p>第三层：卷积层 3，输入为第二层的输出，卷积核个数为 384, kernel_size &#x3D; (3 × 3 × 256)， padding &#x3D; 1，第三层没有做 LRN 和 Pool；</p><p>第四层：卷积层 4，输入为第三层的输出，卷积核个数为 384, kernel_size &#x3D; (3 × 3), padding &#x3D; 1，和第三层一样，没有 LRN 和 Pool；</p><p>第五层：卷积层 5，输入为第四层的输出，卷积核个数为 256, kernel_size &#x3D; (3 × 3), padding &#x3D; 1。然后直接进行 max_pooling, pool_size &#x3D; (3, 3), stride &#x3D; 2；</p><p>第 6，7，8 层是全连接层，每一层的神经元的个数为 4096，最终输出 softmax 为 1000（ImageNet 这个比赛的分类个数为 1000）。全连接层中使用了 RELU 和 Dropout。</p><h6 id="实验代码：-1"><a href="# 实验代码：-1" class="headerlink" title="实验代码："></a>实验代码：</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> keras.datasets <span class="keyword">import</span> mnist</span><br><span class="line"><span class="keyword">from</span> keras.utils <span class="keyword">import</span> np_utils</span><br><span class="line"><span class="keyword">from</span> keras.layers <span class="keyword">import</span> Dense, Dropout, Flatten, Conv2D, MaxPool2D, BatchNormalization</span><br><span class="line"><span class="keyword">from</span> keras.models <span class="keyword">import</span> Sequential</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line">os.environ[<span class="string">&#x27;KMP_DUPLICATE_LIB_OK&#x27;</span>] = <span class="string">&#x27;True&#x27;</span></span><br><span class="line">(X_train, Y_train), (X_test, Y_test) = mnist.load_data()</span><br><span class="line">X_test1 = X_test</span><br><span class="line">Y_test1 = Y_test</span><br><span class="line"></span><br><span class="line"><span class="comment"># 处理图像特征 </span></span><br><span class="line">X_train = X_train.reshape(-<span class="number">1</span>, <span class="number">28</span>, <span class="number">28</span>, <span class="number">1</span>).astype(<span class="string">&quot;float32&quot;</span>) / <span class="number">255.0</span></span><br><span class="line">X_test = X_test.reshape(-<span class="number">1</span>, <span class="number">28</span>, <span class="number">28</span>, <span class="number">1</span>).astype(<span class="string">&quot;float32&quot;</span>) / <span class="number">255.0</span></span><br><span class="line"><span class="comment"># 处理标签</span></span><br><span class="line">Y_train = np_utils.to_categorical(Y_train, <span class="number">10</span>)</span><br><span class="line">Y_test = np_utils.to_categorical(Y_test, <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 搭建 AlexNet 网络模型</span></span><br><span class="line"><span class="comment"># 建立第一层卷积</span></span><br><span class="line">model = Sequential()</span><br><span class="line">model.add(Conv2D(</span><br><span class="line">    filters=<span class="number">96</span>,</span><br><span class="line">    kernel_size=(<span class="number">11</span>, <span class="number">11</span>),</span><br><span class="line">    strides=<span class="number">4</span>,</span><br><span class="line">    padding=<span class="string">&quot;same&quot;</span>,</span><br><span class="line">    input_shape=(<span class="number">28</span>, <span class="number">28</span>, <span class="number">1</span>),</span><br><span class="line">    activation=<span class="string">&quot;relu&quot;</span></span><br><span class="line">))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 搭建 BN 层</span></span><br><span class="line">model.add(BatchNormalization())</span><br><span class="line"><span class="comment"># 搭建第一层重叠最大池化层</span></span><br><span class="line">model.add(MaxPool2D(</span><br><span class="line">    pool_size=(<span class="number">3</span>, <span class="number">3</span>),</span><br><span class="line">    strides=<span class="number">2</span>,</span><br><span class="line">    padding=<span class="string">&quot;same&quot;</span></span><br><span class="line">))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 建立第二层卷积</span></span><br><span class="line">model.add(Conv2D(</span><br><span class="line">    filters=<span class="number">256</span>,</span><br><span class="line">    kernel_size=(<span class="number">5</span>, <span class="number">5</span>),</span><br><span class="line">    strides=<span class="number">1</span>,</span><br><span class="line">    padding=<span class="string">&quot;same&quot;</span>,</span><br><span class="line">    activation=<span class="string">&quot;relu&quot;</span></span><br><span class="line">))</span><br><span class="line"><span class="comment"># 搭建 BN 层</span></span><br><span class="line">model.add(BatchNormalization())</span><br><span class="line"><span class="comment"># 搭建第二层池化层</span></span><br><span class="line">model.add(MaxPool2D(</span><br><span class="line">    pool_size=(<span class="number">3</span>, <span class="number">3</span>),</span><br><span class="line">    strides=<span class="number">2</span>,</span><br><span class="line">    padding=<span class="string">&quot;same&quot;</span>,</span><br><span class="line">))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 搭建第三层卷积</span></span><br><span class="line">model.add(Conv2D(</span><br><span class="line">    filters=<span class="number">384</span>,</span><br><span class="line">    kernel_size=(<span class="number">3</span>, <span class="number">3</span>),</span><br><span class="line">    strides=<span class="number">1</span>,</span><br><span class="line">    padding=<span class="string">&quot;same&quot;</span>,</span><br><span class="line">    activation=<span class="string">&quot;relu&quot;</span>,</span><br><span class="line">))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 搭建第四层卷积</span></span><br><span class="line">model.add(Conv2D(</span><br><span class="line">    filters=<span class="number">384</span>,</span><br><span class="line">    kernel_size=(<span class="number">3</span>, <span class="number">3</span>),</span><br><span class="line">    strides=<span class="number">1</span>,</span><br><span class="line">    padding=<span class="string">&quot;same&quot;</span>,</span><br><span class="line">    activation=<span class="string">&quot;relu&quot;</span></span><br><span class="line">))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 搭建第五卷积层</span></span><br><span class="line">model.add(Conv2D(</span><br><span class="line">    filters=<span class="number">256</span>,</span><br><span class="line">    kernel_size=(<span class="number">3</span>, <span class="number">3</span>),</span><br><span class="line">    strides=<span class="number">1</span>,</span><br><span class="line">    padding=<span class="string">&#x27;same&#x27;</span>,</span><br><span class="line">    activation=<span class="string">&quot;relu&quot;</span></span><br><span class="line">))</span><br><span class="line">model.add(MaxPool2D(</span><br><span class="line">    pool_size=(<span class="number">3</span>, <span class="number">3</span>),</span><br><span class="line">    strides=<span class="number">2</span>,</span><br><span class="line">    padding=<span class="string">&quot;same&quot;</span></span><br><span class="line">))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 搭建第六层：全连接层</span></span><br><span class="line"><span class="comment"># 在搭建全连接层之前，必须使用 Flatten() 降维</span></span><br><span class="line">model.add(Flatten())</span><br><span class="line"><span class="comment"># 全连接层</span></span><br><span class="line">model.add(Dense(<span class="number">4096</span>, activation=<span class="string">&quot;relu&quot;</span>))</span><br><span class="line">model.add(Dropout(<span class="number">0.5</span>))</span><br><span class="line"><span class="comment"># 搭建第七层：全连接层</span></span><br><span class="line">model.add(Dense(<span class="number">4096</span>, activation=<span class="string">&quot;relu&quot;</span>))</span><br><span class="line">model.add(Dropout(<span class="number">0.5</span>))</span><br><span class="line"><span class="comment"># 搭建第八层：全连接层即输出层</span></span><br><span class="line">model.add(Dense(<span class="number">10</span>, activation=<span class="string">&quot;softmax&quot;</span>))</span><br><span class="line">model.summary()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编译</span></span><br><span class="line">model.<span class="built_in">compile</span>(</span><br><span class="line">    loss=<span class="string">&quot;categorical_crossentropy&quot;</span>,</span><br><span class="line">    optimizer=<span class="string">&quot;adam&quot;</span>,</span><br><span class="line">    metrics=[<span class="string">&quot;accuracy&quot;</span>]</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 训练</span></span><br><span class="line">n_epoch = <span class="number">10</span></span><br><span class="line">n_batch = <span class="number">256</span></span><br><span class="line">training = model.fit(</span><br><span class="line">    X_train,</span><br><span class="line">    Y_train,</span><br><span class="line">    epochs=n_epoch,</span><br><span class="line">    batch_size=n_batch,</span><br><span class="line">    verbose=<span class="number">1</span>,</span><br><span class="line">    validation_split=<span class="number">0.20</span></span><br><span class="line">)</span><br><span class="line"><span class="comment"># 评估</span></span><br><span class="line"><span class="built_in">print</span>(model.evaluate(X_train, Y_train, verbose=<span class="number">1</span>))</span><br><span class="line"><span class="comment"># 保存模型</span></span><br><span class="line">model.save(<span class="string">&quot;AlexNet_model&quot;</span>, save_format=<span class="string">&quot;tf&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示训练过程</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show_process</span>(<span class="params">training, train, validation</span>):</span><br><span class="line">    plt.plot(training.history[train], linestyle=<span class="string">&quot;-&quot;</span>, color=<span class="string">&quot;b&quot;</span>)</span><br><span class="line">    plt.plot(training.history[validation], linestyle=<span class="string">&quot;--&quot;</span>, color=<span class="string">&quot;r&quot;</span>)</span><br><span class="line">    plt.title(<span class="string">&quot;training_history&quot;</span>)</span><br><span class="line">    plt.xlabel(<span class="string">&quot;epoch&quot;</span>)</span><br><span class="line">    plt.ylabel(train)</span><br><span class="line">    plt.legend([<span class="string">&quot;train&quot;</span>, <span class="string">&quot;validation&quot;</span>], loc=<span class="string">&quot;lower right&quot;</span>)</span><br><span class="line">    plt.show()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">show_process(training, <span class="string">&quot;accuracy&quot;</span>, <span class="string">&quot;val_accuracy&quot;</span>)</span><br><span class="line">show_process(training, <span class="string">&quot;loss&quot;</span>, <span class="string">&quot;val_loss&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 预测</span></span><br><span class="line">predict_x = model.predict(X_test)</span><br><span class="line">prediction = np.argmax(predict_x, axis=<span class="number">1</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">    index = np.random.randint(<span class="number">0</span>, <span class="number">10000</span>)</span><br><span class="line">    plt.subplot(<span class="number">1</span>, <span class="number">3</span>, i + <span class="number">1</span>)</span><br><span class="line">    plt.axis(<span class="string">&quot;off&quot;</span>)</span><br><span class="line">    plt.imshow(X_test1[index])</span><br><span class="line">    plt.title(<span class="string">&quot;y=&quot;</span> + <span class="built_in">str</span>(Y_test1[index]) + <span class="string">&quot;\ny_pred=&quot;</span> + <span class="built_in">str</span>(prediction[index]))</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><h6 id="实验结果：-1"><a href="# 实验结果：-1" class="headerlink" title="实验结果："></a>实验结果：</h6><p><img data-src="/images/AlexNet_acc.png"></p><p><img data-src="/images/AlexNet_loss.png"></p><p><img data-src="/images/AlexNet_res.png"></p><hr><h5 id="VGGNet"><a href="#VGGNet" class="headerlink" title="VGGNet"></a>VGGNet</h5><p>2014 年，牛津大学计算机视觉组和 Google DeepMind 公司的研究员一起研发出了新的深度卷积神经网络：VGGNet，并取得了 ILSVRC2014 比赛分类项目的第二名（第一名是 GoogLeNet，也是同年提出的）和定位项目的第一名。</p><p>VGGNet 探索了卷积神经网络的深度与其性能之间的关系，成功地构筑了 16~19 层深的卷积神经网络，证明了增加网络的深度能够在一定程度上影响网络最终的性能，使错误率大幅下降，同时拓展性又很强，迁移到其它图片数据上的泛化性也非常好。到目前为止，VGG 仍然被用来提取图像特征。VGGNet 可以看成是加深版本的 AlexNet，都是由卷积层、全连接层两大部分构成。它有如下几个特点：</p><ol><li>小卷积核和多卷积子层，使用小卷积核 (3x3) 和多卷积子层代替一个卷积核较大的卷积层的好处一是可以减少参数，二是相当于进行了更多的非线性映射，可以增加网络的拟合 &#x2F; 表达能力。VGG 的作者认为两个 3x3 的卷积堆叠获得的感受野大小，相当一个 5x5 的卷积；而 3 个 3x3 卷积的堆叠获取到的感受野相当于一个 7x7 的卷积。这样可以增加非线性映射，也能很好地减少参数（例如 7x7 的参数为 49 个，而 3 个 3x3 的参数为 27）</li><li>小池化核，相比 AlexNet 的 3x3 的池化核，VGG 全部采用 2x2 的池化核。</li><li>通道数多，VGG 网络第一层的通道数为 64，后面每层都进行了翻倍，最多到 512 个通道，通道数的增加，使得更多的信息可以被提取出来。</li><li>层数更深、特征图更宽，由于卷积核专注于扩大通道数、池化专注于缩小宽和高，使得模型架构上更深更宽的同时，控制了计算量的增加规模。</li><li>全连接转卷积（测试阶段），在网络测试阶段将训练阶段的三个全连接替换为三个卷积，使得测试得到的全卷积网络因为没有全连接的限制，因而可以接收任意宽或高为的输入，这在测试阶段很重要。</li><li>用简单模型初始化复杂模型，VGGNet 在训练的时候先训级别 A 的简单模型，再复用 A 网络的权重来初始化后面的几个复杂模型，这样收敛速度更快。</li><li>采用了 Multi-Scale 的方法来训练和预测，可以增加训练的数据量，防止模型过拟合，提升预测准确率。</li></ol><h6 id="模型结构：-2"><a href="# 模型结构：-2" class="headerlink" title="模型结构："></a>模型结构：</h6><p><img data-src="/images/VGGNet.png"></p><p>VGG16 处理过程如下：</p><ol><li>输入 224x224x3 的图片，经 64 个 3x3 的卷积核做两次卷积 +ReLU，卷积后的尺寸变为 224x224x64</li><li>做 max pooling（最大化池化），池化单元尺寸为 2x2（效果为图像尺寸减半），池化后的尺寸变为 112x112x64</li><li>经 128 个 3x3 的卷积核做两次卷积 +ReLU，尺寸变为 112x112x128</li><li>做 2x2 的 max pooling 池化，尺寸变为 56x56x128</li><li>经 256 个 3x3 的卷积核做三次卷积 +ReLU，尺寸变为 56x56x256</li><li>做 2x2 的 max pooling 池化，尺寸变为 28x28x256</li><li>经 512 个 3x3 的卷积核做三次卷积 +ReLU，尺寸变为 28x28x512</li><li>做 2x2 的 max pooling 池化，尺寸变为 14x14x512</li><li>经 512 个 3x3 的卷积核做三次卷积 +ReLU，尺寸变为 14x14x512</li><li>做 2x2 的 max pooling 池化，尺寸变为 7x7x512</li><li>与两层 1x1x4096，一层 1x1x1000 进行全连接 +ReLU（共三层）</li><li>通过 softmax 输出 1000 个预测结果</li></ol><h6 id="实验代码：-2"><a href="# 实验代码：-2" class="headerlink" title="实验代码："></a>实验代码：</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> keras.datasets <span class="keyword">import</span> cifar10</span><br><span class="line"><span class="keyword">from</span> keras.utils <span class="keyword">import</span> np_utils</span><br><span class="line"><span class="keyword">from</span> keras.layers <span class="keyword">import</span> Dense, Dropout, Flatten, Conv2D, MaxPool2D, BatchNormalization</span><br><span class="line"><span class="keyword">from</span> keras.models <span class="keyword">import</span> Sequential</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">os.environ[<span class="string">&#x27;KMP_DUPLICATE_LIB_OK&#x27;</span>] = <span class="string">&quot;True&quot;</span></span><br><span class="line"><span class="comment"># 获取所有 GPU 组成 list</span></span><br><span class="line">gpus = tf.config.experimental.list_physical_devices(<span class="string">&#x27;GPU&#x27;</span>)</span><br><span class="line"><span class="comment"># 设置按需申请</span></span><br><span class="line"><span class="comment"># 由于我这里仅有一块 GPU,multi-GPU 需要 for 一下</span></span><br><span class="line">tf.config.experimental.set_memory_growth(gpus[<span class="number">0</span>], <span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">(X_train, Y_train), (X_test, Y_test) = cifar10.load_data()</span><br><span class="line">X_test1 = X_test</span><br><span class="line">Y_test1 = Y_test</span><br><span class="line"></span><br><span class="line"><span class="comment"># 处理图像特征</span></span><br><span class="line">X_train = X_train.reshape(-<span class="number">1</span>, <span class="number">32</span>, <span class="number">32</span>, <span class="number">3</span>).astype(<span class="string">&quot;float32&quot;</span>) / <span class="number">255.0</span></span><br><span class="line">X_test = X_test.reshape(-<span class="number">1</span>, <span class="number">32</span>, <span class="number">32</span>, <span class="number">3</span>).astype(<span class="string">&quot;float32&quot;</span>) / <span class="number">255.0</span></span><br><span class="line"><span class="comment"># 处理标签</span></span><br><span class="line">Y_train = np_utils.to_categorical(Y_train, <span class="number">10</span>)</span><br><span class="line">Y_test = np_utils.to_categorical(Y_test, <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">model = Sequential()</span><br><span class="line">model.add(Conv2D(<span class="number">64</span>, (<span class="number">3</span>, <span class="number">3</span>), activation=<span class="string">&#x27;relu&#x27;</span>, padding=<span class="string">&#x27;same&#x27;</span>, input_shape=(<span class="number">32</span>, <span class="number">32</span>, <span class="number">3</span>)))</span><br><span class="line">model.add(BatchNormalization())</span><br><span class="line">model.add(Conv2D(<span class="number">64</span>, (<span class="number">3</span>, <span class="number">3</span>), activation=<span class="string">&#x27;relu&#x27;</span>, padding=<span class="string">&#x27;same&#x27;</span>))</span><br><span class="line">model.add(BatchNormalization())</span><br><span class="line">model.add(MaxPool2D(pool_size=(<span class="number">2</span>, <span class="number">2</span>), padding=<span class="string">&#x27;same&#x27;</span>))</span><br><span class="line"></span><br><span class="line">model.add(Conv2D(<span class="number">128</span>, (<span class="number">3</span>, <span class="number">3</span>), activation=<span class="string">&#x27;relu&#x27;</span>, padding=<span class="string">&#x27;same&#x27;</span>))</span><br><span class="line">model.add(BatchNormalization())</span><br><span class="line">model.add(Conv2D(<span class="number">128</span>, (<span class="number">3</span>, <span class="number">3</span>), activation=<span class="string">&#x27;relu&#x27;</span>, padding=<span class="string">&#x27;same&#x27;</span>))</span><br><span class="line">model.add(BatchNormalization())</span><br><span class="line">model.add(MaxPool2D(pool_size=(<span class="number">2</span>, <span class="number">2</span>), padding=<span class="string">&#x27;same&#x27;</span>))</span><br><span class="line"></span><br><span class="line">model.add(Conv2D(<span class="number">256</span>, (<span class="number">3</span>, <span class="number">3</span>), activation=<span class="string">&#x27;relu&#x27;</span>, padding=<span class="string">&#x27;same&#x27;</span>))</span><br><span class="line">model.add(BatchNormalization())</span><br><span class="line">model.add(Conv2D(<span class="number">256</span>, (<span class="number">3</span>, <span class="number">3</span>), activation=<span class="string">&#x27;relu&#x27;</span>, padding=<span class="string">&#x27;same&#x27;</span>))</span><br><span class="line">model.add(BatchNormalization())</span><br><span class="line">model.add(Conv2D(<span class="number">256</span>, (<span class="number">3</span>, <span class="number">3</span>), activation=<span class="string">&#x27;relu&#x27;</span>, padding=<span class="string">&#x27;same&#x27;</span>))</span><br><span class="line">model.add(BatchNormalization())</span><br><span class="line">model.add(MaxPool2D(pool_size=(<span class="number">2</span>, <span class="number">2</span>), padding=<span class="string">&#x27;same&#x27;</span>))</span><br><span class="line"></span><br><span class="line">model.add(Conv2D(<span class="number">512</span>, (<span class="number">3</span>, <span class="number">3</span>), activation=<span class="string">&#x27;relu&#x27;</span>, padding=<span class="string">&#x27;same&#x27;</span>))</span><br><span class="line">model.add(BatchNormalization())</span><br><span class="line">model.add(Conv2D(<span class="number">512</span>, (<span class="number">3</span>, <span class="number">3</span>), activation=<span class="string">&#x27;relu&#x27;</span>, padding=<span class="string">&#x27;same&#x27;</span>))</span><br><span class="line">model.add(BatchNormalization())</span><br><span class="line">model.add(Conv2D(<span class="number">512</span>, (<span class="number">3</span>, <span class="number">3</span>), activation=<span class="string">&#x27;relu&#x27;</span>, padding=<span class="string">&#x27;same&#x27;</span>))</span><br><span class="line">model.add(BatchNormalization())</span><br><span class="line">model.add(MaxPool2D(pool_size=(<span class="number">2</span>, <span class="number">2</span>), padding=<span class="string">&#x27;same&#x27;</span>))</span><br><span class="line"></span><br><span class="line">model.add(Conv2D(<span class="number">512</span>, (<span class="number">3</span>, <span class="number">3</span>), activation=<span class="string">&#x27;relu&#x27;</span>, padding=<span class="string">&#x27;same&#x27;</span>))</span><br><span class="line">model.add(BatchNormalization())</span><br><span class="line">model.add(Conv2D(<span class="number">512</span>, (<span class="number">3</span>, <span class="number">3</span>), activation=<span class="string">&#x27;relu&#x27;</span>, padding=<span class="string">&#x27;same&#x27;</span>))</span><br><span class="line">model.add(BatchNormalization())</span><br><span class="line">model.add(Conv2D(<span class="number">512</span>, (<span class="number">3</span>, <span class="number">3</span>), activation=<span class="string">&#x27;relu&#x27;</span>, padding=<span class="string">&#x27;same&#x27;</span>))</span><br><span class="line">model.add(BatchNormalization())</span><br><span class="line">model.add(MaxPool2D(pool_size=(<span class="number">2</span>, <span class="number">2</span>), padding=<span class="string">&#x27;same&#x27;</span>))</span><br><span class="line"></span><br><span class="line">model.add(Flatten())</span><br><span class="line">model.add(Dense(<span class="number">4096</span>, activation=<span class="string">&quot;relu&quot;</span>))</span><br><span class="line">model.add(Dropout(<span class="number">0.5</span>))</span><br><span class="line">model.add(Dense(<span class="number">4096</span>, activation=<span class="string">&quot;relu&quot;</span>))</span><br><span class="line">model.add(Dropout(<span class="number">0.5</span>))</span><br><span class="line">model.add(Dense(<span class="number">10</span>, activation=<span class="string">&quot;softmax&quot;</span>))</span><br><span class="line">model.summary()</span><br><span class="line"></span><br><span class="line">model.<span class="built_in">compile</span>(loss=<span class="string">&quot;categorical_crossentropy&quot;</span>, optimizer=<span class="string">&#x27;adam&#x27;</span>, metrics=[<span class="string">&#x27;accuracy&#x27;</span>])</span><br><span class="line"></span><br><span class="line">log_dir = <span class="string">&quot;logs/fit/&quot;</span> + datetime.datetime.now().strftime(<span class="string">&quot;%Y%m%d-%H%M%S&quot;</span>)</span><br><span class="line">tensorboard_callback = tf.keras.callbacks.TensorBoard(log_dir=log_dir, histogram_freq=<span class="number">1</span>)</span><br><span class="line">n_epoch = <span class="number">1000</span></span><br><span class="line">n_batch = <span class="number">512</span></span><br><span class="line">training = model.fit(</span><br><span class="line">    X_train,</span><br><span class="line">    Y_train,</span><br><span class="line">    epochs=n_epoch,</span><br><span class="line">    batch_size=n_batch,</span><br><span class="line">    verbose=<span class="number">1</span>,</span><br><span class="line">    validation_split=<span class="number">0.20</span>,</span><br><span class="line">    callbacks=[tensorboard_callback]</span><br><span class="line">)</span><br><span class="line"><span class="built_in">print</span>(model.evaluate(X_test, Y_test))</span><br><span class="line"><span class="comment"># 保存模型</span></span><br><span class="line">model.save(<span class="string">&quot;VGGNet16_model&quot;</span>, save_format=<span class="string">&quot;tf&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示训练过程</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show_process</span>(<span class="params">training, train, validation</span>):</span><br><span class="line">    plt.plot(training.history[train], linestyle=<span class="string">&quot;-&quot;</span>, color=<span class="string">&quot;b&quot;</span>)</span><br><span class="line">    plt.plot(training.history[validation], linestyle=<span class="string">&quot;--&quot;</span>, color=<span class="string">&quot;r&quot;</span>)</span><br><span class="line">    plt.title(<span class="string">&quot;training_history&quot;</span>)</span><br><span class="line">    plt.xlabel(<span class="string">&quot;epoch&quot;</span>)</span><br><span class="line">    plt.ylabel(train)</span><br><span class="line">    plt.legend([<span class="string">&quot;train&quot;</span>, <span class="string">&quot;validation&quot;</span>], loc=<span class="string">&quot;lower right&quot;</span>)</span><br><span class="line">    plt.show()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">show_process(training, <span class="string">&quot;accuracy&quot;</span>, <span class="string">&quot;val_accuracy&quot;</span>)</span><br><span class="line">show_process(training, <span class="string">&quot;loss&quot;</span>, <span class="string">&quot;val_loss&quot;</span>)</span><br><span class="line"></span><br><span class="line">class_names = [<span class="string">&#x27;airplane&#x27;</span>, <span class="string">&#x27;automobile&#x27;</span>, <span class="string">&#x27;bird&#x27;</span>, <span class="string">&#x27;cat&#x27;</span>, <span class="string">&#x27;deer&#x27;</span>, <span class="string">&#x27;dog&#x27;</span>, <span class="string">&#x27;frog&#x27;</span>, <span class="string">&#x27;horse&#x27;</span>, <span class="string">&#x27;ship&#x27;</span>, <span class="string">&#x27;truck&#x27;</span>]</span><br><span class="line">predict_x = model.predict(X_test)</span><br><span class="line">prediction = np.argmax(predict_x, axis=<span class="number">1</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">    index = np.random.randint(<span class="number">0</span>, <span class="number">10000</span>)</span><br><span class="line">    plt.subplot(<span class="number">1</span>, <span class="number">4</span>, i + <span class="number">1</span>)</span><br><span class="line">    plt.axis(<span class="string">&quot;off&quot;</span>)</span><br><span class="line">    plt.imshow(X_test1[index])</span><br><span class="line">    plt.title(<span class="string">&quot;y=&quot;</span> + <span class="built_in">str</span>(class_names[<span class="built_in">int</span>(Y_test1[index])]) + <span class="string">&quot;\ny_pred=&quot;</span> + <span class="built_in">str</span>(class_names[prediction[index]]))</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><h6 id="实验结果：-2"><a href="# 实验结果：-2" class="headerlink" title="实验结果："></a>实验结果：</h6><p><img data-src="/images/VGGNet16_acc.png"></p><p><img data-src="/images/VGGNet16_loss.png"></p><p><img data-src="/images/VGGNet16_res.png"></p>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深度学习 </tag>
            
            <tag> 读书笔记 </tag>
            
            <tag> CNN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Tensorflow2.x 深度学习使用 Sequential 一般步骤</title>
      <link href="/2022/04507f527d.html"/>
      <url>/2022/04507f527d.html</url>
      
        <content type="html"><![CDATA[<h3 id="Tensorflow2-x 深度学习使用 Sequential 一般步骤"><a href="#Tensorflow2-x 深度学习使用 Sequential 一般步骤" class="headerlink" title="Tensorflow2.x 深度学习使用 Sequential 一般步骤"></a>Tensorflow2.x 深度学习使用 Sequential 一般步骤 </h3><hr><ol><li> 建立模型 </li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">model = tf.keras.Sequential()</span><br><span class="line">model.add()</span><br></pre></td></tr></table></figure><ol start="2"><li> 查看摘要 </li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">model.summary()</span><br></pre></td></tr></table></figure><ol start="3"><li> 配置训练方法 </li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">model.<span class="built_in">compile</span>()</span><br></pre></td></tr></table></figure><ol start="4"><li> 训练模型 </li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">model.fit()</span><br></pre></td></tr></table></figure><ol start="5"><li> 评估模型 </li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">model.evaluate()</span><br></pre></td></tr></table></figure><ol start="6"><li> 使用模型 </li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">model.predict()</span><br></pre></td></tr></table></figure><hr><h4 id="实验代码："><a href="# 实验代码：" class="headerlink" title="实验代码："></a> 实验代码：</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 加载数据集 </span></span><br><span class="line">mnist = tf.keras.datasets.mnist</span><br><span class="line">(train_x, train_y), (test_x, test_y) = mnist.load_data()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 数据预处理 </span></span><br><span class="line">X_train = tf.cast(train_x/<span class="number">255.0</span>, tf.float32)</span><br><span class="line">X_test = tf.cast(test_x/<span class="number">255.0</span>, tf.float32)</span><br><span class="line">Y_train = tf.cast(train_y, tf.int16)</span><br><span class="line">Y_test = tf.cast(test_y, tf.int16)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 建立模型 </span></span><br><span class="line">model = tf.keras.Sequential()</span><br><span class="line"><span class="comment"># 输入层，MNIST 数据集每张图片大小为 28*28，需要先将图片转换为一维张量 </span></span><br><span class="line">model.add(tf.keras.layers.Flatten(input_shape=(<span class="number">28</span>, <span class="number">28</span>)))</span><br><span class="line"><span class="comment"># 一层隐藏层，为全连接层，节点个数为 128</span></span><br><span class="line">model.add(tf.keras.layers.Dense(<span class="number">128</span>, activation=<span class="string">&quot;relu&quot;</span>))</span><br><span class="line"><span class="comment"># 输出层，MNIST 共有 10 种结果，故节点数为 10</span></span><br><span class="line">model.add(tf.keras.layers.Dense(<span class="number">10</span>, activation=<span class="string">&quot;softmax&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看模型 </span></span><br><span class="line">model.summary()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置模型 </span></span><br><span class="line">model.<span class="built_in">compile</span>(optimizer=<span class="string">&quot;adam&quot;</span>,</span><br><span class="line">              loss=<span class="string">&quot;sparse_categorical_crossentropy&quot;</span>,</span><br><span class="line">              metrics=[<span class="string">&quot;sparse_categorical_accuracy&quot;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 训练模型 </span></span><br><span class="line">model.fit(X_train, Y_train, batch_size=<span class="number">64</span>, epochs=<span class="number">10</span>, validation_split=<span class="number">0.25</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 评估模型 </span></span><br><span class="line">model.evaluate(X_test, Y_test, verbose=<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 保存模型 </span></span><br><span class="line">model.save(<span class="string">&quot;mnist_model&quot;</span>, save_format=<span class="string">&quot;tf&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用模型 </span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">6</span>):</span><br><span class="line">    index = np.random.randint(<span class="number">0</span>, <span class="number">10000</span>)</span><br><span class="line">    <span class="comment"># 因为在输入层将数据转换为了一维数组，所以预测的时候也需要保证输入和输入层一致 </span></span><br><span class="line">    demo = tf.reshape(X_test[index], (<span class="number">1</span>, <span class="number">28</span>, <span class="number">28</span>))</span><br><span class="line">    y_pred = np.argmax(model.predict(demo))</span><br><span class="line">    plt.subplot(<span class="number">1</span>, <span class="number">6</span>, i+<span class="number">1</span>)</span><br><span class="line">    plt.axis(<span class="string">&quot;off&quot;</span>)</span><br><span class="line">    plt.imshow(test_x[index], cmap=<span class="string">&quot;gray&quot;</span>)</span><br><span class="line">    plt.title(<span class="string">&quot;y=&quot;</span> + <span class="built_in">str</span>(test_y[index]) + <span class="string">&quot;\ny_pred=&quot;</span> + <span class="built_in">str</span>(y_pred))</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><hr><h4 id="实验结果："><a href="# 实验结果：" class="headerlink" title="实验结果："></a> 实验结果：</h4><p><img data-src="/images/mnist.png"></p><hr><h4 id="实验总结："><a href="# 实验总结：" class="headerlink" title="实验总结："></a> 实验总结：</h4><p> 其实对于一般的神经网络，构建的方法都很类似，它们主要的不同体现在对各种参数（比如优化器、激活函数、评价指标、损失函数）的选择以及隐藏层的数量、每一层的神经元个数上。我们需要注意的是虽然使用 tf.keras.Sequential() 构建神经网络只需要关注输入层和输出层的结构（隐藏层会自动根据上下层的结构生成对应的训练参数结构），但是必须保证使用模型预测时数据集的处理和模型一致（这也是本次实验中容易出错的地方）。</p>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深度学习 </tag>
            
            <tag> 读书笔记 </tag>
            
            <tag> Tensorflow </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Tensorflow2.x 实现多元逻辑回归</title>
      <link href="/2022/04da61b44a.html"/>
      <url>/2022/04da61b44a.html</url>
      
        <content type="html"><![CDATA[<h3 id="Tensorflow2-x 实现多元逻辑回归"><a href="#Tensorflow2-x 实现多元逻辑回归" class="headerlink" title="Tensorflow2.x 实现多元逻辑回归"></a>Tensorflow2.x 实现多元逻辑回归 </h3><hr><p> 鸢尾花数据集是经典的机器学习数据集，该数据集包含了鸢尾花的三种分类，即 Setosa 鸢尾花、Versicolour 鸢尾花和 Virginica 鸢尾花，每一条数据用四个特征（萼长、萼宽、瓣长、瓣宽）来进行描述。</p><p> 多元逻辑回归模型的一般过程：</p><ol><li> 设置参数 </li><li> 构建函数 </li><li> 根据损失函数反向求导 </li><li> 根据梯度分别更新参数 </li></ol><hr><h4 id="实验代码："><a href="# 实验代码：" class="headerlink" title="实验代码："></a> 实验代码：</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 下载数据集 </span></span><br><span class="line">TRAIN_URL = <span class="string">&quot;https://download.tensorflow.org/data/iris_training.csv&quot;</span></span><br><span class="line">train_path = tf.keras.utils.get_file(TRAIN_URL.split(<span class="string">&#x27;/&#x27;</span>)[-<span class="number">1</span>], TRAIN_URL)</span><br><span class="line">TEST_URL = <span class="string">&quot;https://download.tensorflow.org/data/iris_test.csv&quot;</span></span><br><span class="line">test_path = tf.keras.utils.get_file(TEST_URL.split(<span class="string">&#x27;/&#x27;</span>)[-<span class="number">1</span>], TEST_URL)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 导入数据集 </span></span><br><span class="line">df_iris_train = pd.read_csv(train_path, header=<span class="number">0</span>)</span><br><span class="line">df_iris_test = pd.read_csv(test_path, header=<span class="number">0</span>)</span><br><span class="line">iris_train = np.array(df_iris_train)</span><br><span class="line">iris_test = np.array(df_iris_test)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对数据集数据进行随机打乱 </span></span><br><span class="line">np.random.seed(<span class="number">520</span>)</span><br><span class="line">np.random.shuffle(iris_train)</span><br><span class="line">np.random.shuffle(iris_test)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将数据的前 4 列特征作为训练数据，第 5 列标签提取出来 </span></span><br><span class="line">x_train = iris_train[:, <span class="number">0</span>:<span class="number">4</span>]</span><br><span class="line">y_train = iris_train[:, <span class="number">4</span>]</span><br><span class="line">x_test = iris_test[:, <span class="number">0</span>:<span class="number">4</span>]</span><br><span class="line">y_test = iris_test[:, <span class="number">4</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 数据预处理 </span></span><br><span class="line">x_train = x_train - np.mean(x_train, axis=<span class="number">0</span>)</span><br><span class="line">x_test = x_test - np.mean(x_test, axis=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># numpy 读取数据默认 float64，但在一般情况下，float32 在满足精度要求下计算速度更快；对标签进行 one-hot 编码 </span></span><br><span class="line">X_train = tf.cast(x_train, tf.float32)</span><br><span class="line">Y_train = tf.one_hot(tf.constant(y_train, dtype=tf.int32), <span class="number">3</span>)</span><br><span class="line">X_test = tf.cast(x_test, tf.float32)</span><br><span class="line">Y_test = tf.one_hot(tf.constant(y_test, dtype=tf.int32), <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置超参数 </span></span><br><span class="line">learn_rate = <span class="number">0.5</span></span><br><span class="line"><span class="built_in">iter</span> = <span class="number">100</span></span><br><span class="line">display_step = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置训练参数，构建模型 </span></span><br><span class="line">W1 = tf.Variable(np.random.randn(<span class="number">4</span>, <span class="number">32</span>), dtype=tf.float32)</span><br><span class="line">B1 = tf.Variable(np.zeros([<span class="number">32</span>]), dtype=tf.float32)</span><br><span class="line">W2 = tf.Variable(np.random.randn(<span class="number">32</span>, <span class="number">16</span>), dtype=tf.float32)</span><br><span class="line">B2 = tf.Variable(np.zeros([<span class="number">16</span>]), dtype=tf.float32)</span><br><span class="line">W3 = tf.Variable(np.random.randn(<span class="number">16</span>, <span class="number">3</span>), dtype=tf.float32)</span><br><span class="line">B3 = tf.Variable(np.zeros([<span class="number">3</span>]), dtype=tf.float32)</span><br><span class="line"></span><br><span class="line">acc_train = []</span><br><span class="line">acc_test = []</span><br><span class="line">cce_train = []</span><br><span class="line">cce_test = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">iter</span> + <span class="number">1</span>):</span><br><span class="line">    <span class="keyword">with</span> tf.GradientTape() <span class="keyword">as</span> tape:</span><br><span class="line">        Hidden1_train = tf.nn.relu(tf.matmul(X_train, W1) + B1)</span><br><span class="line">        Hidden2_train = tf.nn.relu(tf.matmul(Hidden1_train, W2) + B2)</span><br><span class="line">        PRED_train = tf.nn.softmax(tf.matmul(Hidden2_train, W3) + B3)</span><br><span class="line">        Loss_train = tf.reduce_mean(tf.keras.losses.categorical_crossentropy(y_true=Y_train, y_pred=PRED_train))</span><br><span class="line">    Hidden1_test = tf.nn.relu(tf.matmul(X_test, W1) + B1)</span><br><span class="line">    Hidden2_test = tf.nn.relu(tf.matmul(Hidden1_test, W2) + B2)</span><br><span class="line">    PRED_test = tf.nn.softmax(tf.matmul(Hidden2_test, W3) + B3)</span><br><span class="line">    Loss_test = tf.reduce_mean(tf.keras.losses.categorical_crossentropy(y_true=Y_test, y_pred=PRED_test))</span><br><span class="line"></span><br><span class="line">    accuracy_train = tf.reduce_mean(tf.cast(tf.equal(tf.argmax(PRED_train.numpy(), axis=<span class="number">1</span>), y_train), tf.float32))</span><br><span class="line">    accuracy_test = tf.reduce_mean(tf.cast(tf.equal(tf.argmax(PRED_test.numpy(), axis=<span class="number">1</span>), y_test), tf.float32))</span><br><span class="line">    acc_train.append(accuracy_train)</span><br><span class="line">    acc_test.append(accuracy_test)</span><br><span class="line">    cce_train.append(Loss_train)</span><br><span class="line">    cce_test.append(Loss_test)</span><br><span class="line"></span><br><span class="line">    grads = tape.gradient(Loss_train, [W1, B1, W2, B2, W3, B3])</span><br><span class="line">    W1.assign_sub(learn_rate * grads[<span class="number">0</span>])</span><br><span class="line">    B1.assign_sub(learn_rate * grads[<span class="number">1</span>])</span><br><span class="line">    W2.assign_sub(learn_rate * grads[<span class="number">2</span>])</span><br><span class="line">    B2.assign_sub(learn_rate * grads[<span class="number">3</span>])</span><br><span class="line">    W3.assign_sub(learn_rate * grads[<span class="number">4</span>])</span><br><span class="line">    B3.assign_sub(learn_rate * grads[<span class="number">5</span>])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> i % display_step == <span class="number">0</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;i: %i, TrainAcc: %f, TrainLoss: %f, TestAcc: %f, TestLoss: %f&quot;</span> % (i, accuracy_train, Loss_train, accuracy_test, Loss_test))</span><br><span class="line"></span><br><span class="line">plt.figure(figsize=(<span class="number">20</span>, <span class="number">6</span>))</span><br><span class="line"></span><br><span class="line">plt.subplot(<span class="number">121</span>)</span><br><span class="line">plt.plot(cce_train, color=<span class="string">&quot;blue&quot;</span>, label=<span class="string">&quot;train&quot;</span>)</span><br><span class="line">plt.plot(cce_test, color=<span class="string">&quot;red&quot;</span>, label=<span class="string">&quot;test&quot;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&quot;Iteration&quot;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&quot;Loss&quot;</span>)</span><br><span class="line">plt.legend()</span><br><span class="line"></span><br><span class="line">plt.subplot(<span class="number">122</span>)</span><br><span class="line">plt.plot(acc_train, color=<span class="string">&quot;blue&quot;</span>, label=<span class="string">&quot;train&quot;</span>)</span><br><span class="line">plt.plot(acc_test, color=<span class="string">&quot;red&quot;</span>, label=<span class="string">&quot;test&quot;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&quot;Iteration&quot;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&quot;Accuracy&quot;</span>)</span><br><span class="line">plt.legend()</span><br><span class="line"></span><br><span class="line">plt.tight_layout()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><hr><h4 id="实验结果："><a href="# 实验结果：" class="headerlink" title="实验结果："></a> 实验结果：</h4><p><img data-src="/images/iris.png"></p><hr><h4 id="实验总结："><a href="# 实验总结：" class="headerlink" title="实验总结："></a> 实验总结：</h4><p> 多元逻辑回归就是找到一条曲线（曲面）去划分多分类，整体相当于对于 f&#x3D;Wx + B 求得损失函数最小的参数，其中 x 和 b 是维度相同的一维向量，其大小代表了数据的维度。实验的主要工作在于应用 tensorflow2.5 的 api 构建函数以及对参数的求导（偏导），我们使用 tf.matmul() 构建函数，使用 tf.GradientTape() 进行自动求导，使用 tensorflow 的一大优势就在于我们不用关心损失函数复杂的链式求导过程，而可以将重心放在损失函数的设计以及其他参数的选择上。</p>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深度学习 </tag>
            
            <tag> 读书笔记 </tag>
            
            <tag> Tensorflow </tag>
            
            <tag> 多元逻辑回归 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深度学习之激活函数</title>
      <link href="/2022/04a611c275.html"/>
      <url>/2022/04a611c275.html</url>
      
        <content type="html"><![CDATA[<h2 id="深度学习之激活函数"><a href="# 深度学习之激活函数" class="headerlink" title="深度学习之激活函数"></a>深度学习之激活函数</h2><p>​最近在系统地学习一些深度学习的知识，发现其中的激活函数很有意思，激活函数的选择也往往可以作为深度学习中调优的一种手段，针对不同的数据、不同的问题采取合适的激活函数，往往可以取得比较好的效果。结合网上的一些文章以及自己的理解，在此记录一下以便之后复习。<br>​首先要明确的是激活函数的作用，激活函数在神经网络中将神经元上经过权重计算完毕的输入以某种方式（根据具体选择的激活函数）进行映射，从而输出作为该神经元对于下一层网络的输入，那么明明已经对输入根据参数进行了权重计算为什么仍然需要激活函数呢？激活函数的作用在于增加网络的非线性，我们知道，一般的权重计算往往是 Wx + b 的形式，即神经元对于输入进行线性组合，如果不使用激活函数，那么无论神经网络有多少层，最终的结果仍然是线性的，即该计算可以用一层网络替代，这种神经网络一般不能解决复杂一点的问题。而使用激活函数后，每一层网络间就不仅仅是线性的叠加，我们通过使用非线性激活函数的方式来使得神经网络具有了解决非线性问题的能力。<br>​以下是常用的几种激活函数。</p><h4 id="1-Sigmoid 函数"><a href="#1-Sigmoid 函数" class="headerlink" title="1.Sigmoid 函数"></a>1.Sigmoid 函数 </h4><p> 公式：<br>$$ f(x)&#x3D;\frac{1}{1+e^{-x}} $$<br>图像：</p><p><img data-src="/images/sigmoid.png"></p><p>​Sigmoid 是早期较为常用的激活函数，我们可以看出，Sigmoid 函数的值域为(0, 1)，这相当于对数据进行了归一化处理，又因为概率的值域为[0, 1]，故 Sigmoid 很适合一些将概率作为输出的模型。同时，Sigmoid 的图像比较平滑，这避免了输出存在较大的跳跃。</p><p>​但是，Sigmoid 的平均值不是 0（一般来说输出的均值为 0 的模型效果较好一些），同时，因为函数涉及到指数计算，而参数的更新又依赖于梯度下降，所以计算的时间一般较长。</p><h4 id="2-Tanh（Hyperbolic-tangent-function，双曲正切激活函数）"><a href="#2-Tanh（Hyperbolic-tangent-function，双曲正切激活函数）" class="headerlink" title="2.Tanh（Hyperbolic tangent function，双曲正切激活函数）"></a>2.Tanh（Hyperbolic tangent function，双曲正切激活函数）</h4><p>公式：<br>$$ f(x)&#x3D;tanh(x)&#x3D;\frac{e^x-e^{-x}}{e^x+e^{-x}}&#x3D;\frac{2}{1+e^{-2x}}-1 $$<br>图像：</p><p><img data-src="/images/tanh.png"></p><p>​同 Sigmoid 函数类似，Tanh 函数也是一条平滑的 S 型曲线，但是 Tanh 函数的平均值为 0，同时，对于负输入，Tanh 将其映射为负，对于正输入，Tanh 将其映射为正</p><h4 id="3-ReLU（Linear-rectification-function，线性整流函数）"><a href="#3-ReLU（Linear-rectification-function，线性整流函数）" class="headerlink" title="3.ReLU（Linear rectification function，线性整流函数）"></a>3.ReLU（Linear rectification function，线性整流函数）</h4><p>公式：<br>$$ f(x)&#x3D;\begin{cases} x，x\geq0\ 0， x&lt;0\end{cases}&#x3D;max(0,x) $$<br>图像：</p><p><img data-src="/images/relu.png"></p><p>​ReLU 函数是深度学习中较为流行的一种激活函数，ReLU 可以实现单侧抑制（即把一部分神经元置 0），能够稀疏模型，Sigmoid 和 Tanh 激活函数会导致一个非稀疏的神经网络，而 ReLU 大约 50% 的神经元会处于激活状态，具有很好的稀疏性。同时，ReLU 函数右侧线性部分梯度始终为 1，具有宽兴奋边界的特性（即兴奋程度可以非常高），不会发生神经网络的梯度消失问题，能够加速梯度下降的收敛速度。而 Tanh 和 Sigmoid 在离 0 点近的时候梯度大，在远离 0 点的时候梯度小，容易出现梯度消失。ReLU 的计算也较为简单。</p><p>​ReLU 的缺点在于 ReLU 函数的值域在 0 到正无穷，相当于给后一层的神经网络引入偏置偏移，会影响梯度下降的效率。另外，在训练时，如果参数在一次不恰当的更新后，某个 ReLU 神经元输出为 0，那么这个神经元自身参数的梯度永远都会是 0，在以后的训练过程中永远不能被激活。</p><h4 id="4-Leaky-ReLU-（带泄露线性整流函数）"><a href="#4-Leaky-ReLU-（带泄露线性整流函数）" class="headerlink" title="4.Leaky ReLU  （带泄露线性整流函数）"></a>4.Leaky ReLU  （带泄露线性整流函数）</h4><p>公式：<br>$$ f(x)&#x3D;\begin{cases} x，x\geq0\ \gamma x， x&lt;0\end{cases}&#x3D;max(0,x)+\gamma min(0,x) $$<br>图像：</p><p><img data-src="/images/lrelu.png"></p><p>​这里，r 取 0.01（r 通常是 0 到 1 之间的数，通常取小于 1 的很小常数）。</p><p>​Leaky ReLU 函数在输入 x&lt;0 时，能保持一个很小的梯度 r。这样当神经元非激活时也能有一个非零的梯度可以更新参数，避免永远不能被激活，以便给网络继续学习的机会。特殊的，当不确定 r，将 r 作为一个可学习的参数时，这种激活函数为 PReLU。</p><p>​总结性的：当 r&#x3D;0 时，为 ReLU；当 r&#x3D; 常数时，为 Leaky ReLU；当 r&#x3D; 训练的参数时，为 PReLU。理论上，后两者具有 ReLU 的所有优点并且避免了 Dead ReLU 问题，但是并没有实验能够证明后两者一定比 ReLU 更为优秀。一般在实验当中，我们可以首先试试 ReLU 的效果，当结果不大理想时可以试一试 Leaky ReLU，而因为 PReLU 增加了需要学习的参数，建议只在训练数据集较大的情况下使用。</p><h4 id="5-ELU（Exponential-Linear-Unit，指数线性单元）"><a href="#5-ELU（Exponential-Linear-Unit，指数线性单元）" class="headerlink" title="5.ELU（Exponential Linear Unit，指数线性单元）"></a>5.ELU（Exponential Linear Unit，指数线性单元）</h4><p>公式：<br>$$ f(x)&#x3D;\begin{cases} x，x\geq0\ \alpha (e^x-1)， x&lt;0\end{cases} $$<br>图像：</p><p><img data-src="/images/elu.png"></p><p>​这里 a 取 1。</p><p>​ELU 函数融合了 Sigmoid 和 ReLU，左侧具有软饱和性，右侧无饱和性。右侧线性部分使得 ELU 能够缓解梯度消失，而左侧软饱能够让 ELU 对输入变化或噪声更鲁棒。ELU 的输出均值接近于零，所以收敛速度更快。</p><h4 id="6-SoftPlus"><a href="#6-SoftPlus" class="headerlink" title="6.SoftPlus"></a>6.SoftPlus</h4><p>公式：<br>$$ f(x)&#x3D;log(1+e^x) $$<br>图像：</p><p><img data-src="/images/softplus.png"></p>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深度学习 </tag>
            
            <tag> 读书笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 访问 HashMap 的方式</title>
      <link href="/2022/03efc9353a.html"/>
      <url>/2022/03efc9353a.html</url>
      
        <content type="html"><![CDATA[<h1 id="Java 访问 HashMap 元素的方式"><a href="#Java 访问 HashMap 元素的方式" class="headerlink" title="Java 访问 HashMap 元素的方式"></a>Java 访问 HashMap 元素的方式 </h1><p>  HashMap 作为最常用的集合之一，可以表示元素间的映射关系，或者用于数据的统计。</p><p>  HashMap 最多只允许一条记录的键为 Null；允许多条记录的值为 Null。（不允许键重复，但允许值重复）</p><p>  HashMap 不支持线程的同步（任一时刻可以有多个线程同时写 HashMap，即线程非安全），可能会导致数据的不一致。如果需要同步，可以用 Collections 的 synchronizedMap() 方法使 HashMap 具有同步的能力，或者使 ConcurrentHashMap。</p><p>  Hashtable 与 HashMap 类似。不同的是：它不允许记录的键或者值为空；它支持线程的同步（任一时刻只有一个线程能写 Hashtable，即线程安全），因此也导致了 Hashtable 在写入时会比较慢。</p><p>  最近在刷算法题中，发现经常需要使用它，所以这里对 Java 访问 HashMap 元素的方式进行一个汇总，一方面巩固学习，另一方面方便日后查看使用。</p><hr><h4 id="第一种方式：通过 Key 来访问 Value"><a href="# 第一种方式：通过 Key 来访问 Value" class="headerlink" title="第一种方式：通过 Key 来访问 Value"></a> 第一种方式：通过 Key 来访问 Value</h4><p>  HashMap 中内置的方法 keySet() 可以返回一个 hashmap 中所有 key 的 set 集合，再根据得到的 key 就可以访问 hashmap 中对应 key 的 value。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, String&gt; hm = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span>(String key : hm.keySet())&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> hm.get(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="第二种方式：通过 Map-keySet- 使用 iterator 访问 key 和 value"><a href="# 第二种方式：通过 Map-keySet- 使用 iterator 访问 key 和 value" class="headerlink" title="第二种方式：通过 Map.keySet() 使用 iterator 访问 key 和 value"></a> 第二种方式：通过 Map.keySet() 使用 iterator 访问 key 和 value</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, String&gt; hm = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">Iterator&lt;String&gt; it = hm.keySet().iterator();</span><br><span class="line"><span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> it.next();</span><br><span class="line">    <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> hm.get(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="第三种方式：通过 Map-Entry- 访问 key 和 value"><a href="# 第三种方式：通过 Map-Entry- 访问 key 和 value" class="headerlink" title="第三种方式：通过 Map.Entry() 访问 key 和 value"></a> 第三种方式：通过 Map.Entry() 访问 key 和 value</h4><p>  entrySet() 方法将返回映射中包含的映射的 Set 视图 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, String&gt; hm = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span>(Map.Entry&lt;String, String&gt; entry : hm.entrySet())&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> entry.getKey();</span><br><span class="line">    <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> entry.getValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="第四种方式：通过 Map-entrySet- 使用 iterator 访问 key 和 value"><a href="# 第四种方式：通过 Map-entrySet- 使用 iterator 访问 key 和 value" class="headerlink" title="第四种方式：通过 Map.entrySet() 使用 iterator 访问 key 和 value"></a> 第四种方式：通过 Map.entrySet() 使用 iterator 访问 key 和 value</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, String&gt; hm = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">Iterator&lt;Map.Entry&lt;String, String&gt;&gt; it = hm.entrySet().iterator();</span><br><span class="line"><span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">    Map.Entry&lt;String, String&gt; entry = it.next();</span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> entry.getKey();</span><br><span class="line">    <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> entry.getValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="第五种方式：通过 Map-values- 遍历所有的 value，但是不能遍历键 key"><a href="# 第五种方式：通过 Map-values- 遍历所有的 value，但是不能遍历键 key" class="headerlink" title="第五种方式：通过 Map.values() 遍历所有的 value，但是不能遍历键 key"></a> 第五种方式：通过 Map.values() 遍历所有的 value，但是不能遍历键 key</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, String&gt; hm = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span>(String value : hm.values())&#123;</span><br><span class="line">    <span class="comment">/* 处理逻辑 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>  上述五种方式中，除了最后一种方式只能获取 HashMap 的 value，其余方式都可以同时获取到 key 和 value；同时，方式一和方式二都是使用 keySet() 方法先获取到 key 的集合再访问 value，只是方式二在对 key 的获取上使用了迭代器，类似的方式三和方式四也是这样。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书笔记 </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>外文文献词汇</title>
      <link href="/2022/03c1cebf30.html"/>
      <url>/2022/03c1cebf30.html</url>
      
        <content type="html"><![CDATA[<h2 id="外文文献词汇"><a href="# 外文文献词汇" class="headerlink" title="外文文献词汇"></a> 外文文献词汇 </h2><hr><table><thead><tr><th></th><th align="left"></th></tr></thead><tbody><tr><td>decomposition</td><td align="left"> 分解；变质 </td></tr><tr><td>demonstrate</td><td align="left"> 证明；展示；论证 </td></tr><tr><td>benchmark</td><td align="left"> 基准；标杆 </td></tr><tr><td>tackle</td><td align="left"> 应付；解决；处理 </td></tr><tr><td>vice versa</td><td align="left"> 反之亦然 </td></tr><tr><td>metric</td><td align="left"> 衡量标准 </td></tr><tr><td>heuristic</td><td align="left"> 启发式的；探索的 </td></tr><tr><td>non-symmetric</td><td align="left"> 不对称式的 </td></tr><tr><td>paradox</td><td align="left"> 悖论 </td></tr><tr><td>cardinality</td><td align="left"> 基数；集的势 </td></tr><tr><td>authoritative</td><td align="left"> 可信的；权威的 </td></tr><tr><td>denominator</td><td align="left"> 分母 </td></tr><tr><td>trivial</td><td align="left"> 不重要的；琐碎的 </td></tr><tr><td>optimal</td><td align="left"> 最理想的；最佳的 </td></tr><tr><td>numerator</td><td align="left"> 分子 </td></tr><tr><td>corresponding</td><td align="left"> 一致的 </td></tr><tr><td>intersection</td><td align="left"> 十字路口；交叉；交集 </td></tr><tr><td>ambiguity</td><td align="left"> 模棱两可；暧昧 </td></tr><tr><td>preliminary</td><td align="left"> 初步的；准备的 </td></tr><tr><td>intuition</td><td align="left"> 直觉 </td></tr><tr><td>sufficient</td><td align="left"> 足够的；充分的 </td></tr><tr><td></td><td align="left"></td></tr><tr><td></td><td align="left"></td></tr><tr><td></td><td align="left"></td></tr><tr><td></td><td align="left"></td></tr><tr><td></td><td align="left"></td></tr><tr><td></td><td align="left"></td></tr><tr><td></td><td align="left"></td></tr><tr><td></td><td align="left"></td></tr><tr><td></td><td align="left"></td></tr><tr><td></td><td align="left"></td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 文献阅读 </tag>
            
            <tag> English </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 核心技术·卷Ⅰ读书笔记</title>
      <link href="/2021/12e2377c46.html"/>
      <url>/2021/12e2377c46.html</url>
      
        <content type="html"><![CDATA[<h2 id="Java 核心技术·卷Ⅰ读书笔记"><a href="#Java 核心技术·卷Ⅰ读书笔记" class="headerlink" title="Java 核心技术·卷Ⅰ读书笔记"></a>Java 核心技术·卷Ⅰ读书笔记</h2><p><img data-src="/images/java_top_img.png"></p><h4 id="数据类型"><a href="# 数据类型" class="headerlink" title="数据类型"></a>数据类型</h4><p>​Java 中一共 8 种基本类型：int、short、long、byte、float、double、char、boolean。</p><p>​Java 中没有任何无符号（unsigned）形式的 int、short、long 或者 byte 类型。</p><p>​不同于其他语言，Java 整型的范围与运行 Java 代码的机器无关，而例如 C&#x2F;C++ 中，int 在 16 位机器上占 2 字节，在 32 位机器上占 4 字节，在 64 位机器上占 8 字节。</p><p>​浮点数值不适用于无法接受舍入误差的金融计算中。舍入误差产生的原因：根据 IEEE 754 标准，单精度 float 类型使用 32 比特存储，其中 1 位表示符号，8 位表示指数，23 位表示尾数；双精度 double 类型使用 64 比特存储，1 位符号位，11 位指数位，52 位尾数位。</p><p>​Float 精度为 6-7 位，Double 精度为 15 位，所以说 Int 类型的数据转向 Float 会损失精度，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> intData1=<span class="number">123</span>;</span><br><span class="line"><span class="type">int</span> intData2=<span class="number">123456789</span>;</span><br><span class="line">System.out.println((<span class="type">float</span>)intData1);</span><br><span class="line">System.out.println((<span class="type">float</span>)intData2);</span><br></pre></td></tr></table></figure><p>结果为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">123.0</span></span><br><span class="line"><span class="number">1.23456792E8</span>  <span class="comment">// 此处已经损失精度</span></span><br></pre></td></tr></table></figure><p>​整型值和布尔值之间不能相互转换。</p><p>​Java 中父类强制转换成子类的原则：父类型的引用指向的是哪个子类的实例，就能转换成哪个子类的引用。父类转子类的前提是：此父类对象为子类对象的引用。</p><p>​从 Java 7 开始，加上前缀 0b 就可以写成二进制数。例如 0b1010 就是十进制数 10，另外，同样是从 Java 7 开始，还可以在数字字面量加下划线，如用 1_000_000(或 0b1111_0100_0010_0000)表示一百万。这些下划线只是为了让人更容易阅读，Java 编译器会去除这些下划线。</p><p><img data-src="/images/java_type.png"></p><h4 id="变量"><a href="# 变量" class="headerlink" title="变量"></a>变量</h4><p>​声明一个变量后，必须用赋值语句对变量进行显式初始化。</p><p>​建议变量的声明尽可能地靠近变量第一次使用的地方。</p><p>​在 Java 中，利用关键字 final 指示常量，常量名习惯上使用全大写。</p><p>​final 修饰对象引用相当于一个常量指针，在内存中的地址不能改变，但是可以修改引用指向内存地址的具体内容。</p><p>​如果希望一个常量在一个类的多个方法中都可以使用，可以将常量用 static final 修饰；类常量的定义位于 main 方法外。</p><p>​const 是 Java 的保留关键字，但是还没有使用。</p><p>​Java 中的所有参数都通过值传递。当参数是原始数据类型时，实际参数的值将复制到参数中，对方法主体中的参数值进行的任何更改只会更改形式参数的副本，而不会更改实际参数的值；而当参数是引用类型时，存储在实际参数中的引用被复制到形式参数，此时实际参数和形式参数都指向内存中的相同对象，在方法主体中对引用变量做出的任何操作将会改变实参指向的对象。</p><h4 id="运算符"><a href="# 运算符" class="headerlink" title="运算符"></a>运算符</h4><p>​参与 &#x2F; （除法）运算的两个操作数都是整数时，表示整数除法，否则表示浮点数除法。</p><p>​只有整数才有 % （求余）运算。</p><p>​低精度向高精度转换不存在精度丢失，称为隐式类型转换；反之，高精度向低精度转换可能存在精度丢失，称为显示类型转换，或者强制类型转换。</p><p>​逻辑运算符 &amp;&amp; 和 || 按照”短路”方式求值，且 &amp;&amp; 的优先级高于 || ；但是 &amp; 和 | 不遵循”短路”的原则，也可以达到逻辑与和或的目的。</p><p>​逻辑位移是移动数字的所有物理比特位；算数位移是对数字除了符号位以外的比特位进行位移，符号位保持不变。</p><p>​在 Java 中，使用 &gt;&gt;&gt; 表示逻辑位移，使用 &gt;&gt; 表示算数位移； &gt;&gt; (算术右移)将用符号位填充高位， &gt;&gt;&gt; 会用 0 填充最高位，不存在 &lt;&lt;&lt; 的运算。</p><p><img data-src="/images/java_operator.png"></p><h4 id="字符串"><a href="# 字符串" class="headerlink" title="字符串"></a>字符串</h4><p>​静态方法 join() 可以将字符串以一个分界符连接起来。</p><p>​Java 中 String 类型是不可变字符串，字符串不可变的优点在于编译器可以让字符串共享。</p><p>​&#x3D;&#x3D; 运算符用于判断字符串对象时判断的是对象的引用是否相同，即引用是否指向内存中同一个地址，如果需要判断字符串的内容是否一致，则需要调用方法 equals() 。</p><p>​如果需要以频繁地拼接字符串作为构建字符串的方式，则使用 StringBuilder 类（非线程安全，效率高）或者 StringBuffer 类（线程安全）更好。</p><h4 id="数组"><a href="# 数组" class="headerlink" title="数组"></a>数组</h4><p>​数组长度不要求是常量。</p><p>​创建一个数字数组时，所有元素初始化为 0；创建一个对象数组时，所有元素初始化为 null ；创建一个 boolean 数组时，所有元素初始化为 false 。</p><p>​Arrays 类的 toString() 方法可以快递打印一个数组。</p><p>​数组的拷贝默认是浅层拷贝，即复制的是数组对象的引用，前后两者指向同一片内存；若要深层拷贝，则需要调 Arrays 类的 copyOf() 方法。</p><h4 id="对象与类"><a href="# 对象与类" class="headerlink" title="对象与类"></a>对象与类</h4><p>​对象的三个主要特性：行为；状态；标识。</p><p>​类之间的关系：依赖；继承；聚合。</p><p>​依赖是一种“uses-a”的关系，如果一个类的方法操作另一个类的对象，则说前者依赖于后者。应尽可能地减少依赖关系，如果类 A 不知道类 B 的存在，那么任何对类 B 的修改都不会引起类 A 的变化，即类之间的耦合度越小越好。</p><p>​聚合是一种“has-a”的关系，即一个类的对象中包含另一个类的对象。</p><p>​继承是一种“is-a”的关系，是一种用于表示特殊与一般的关系。</p><p>​一个对象变量并没有实际包含一个对象，仅仅只是一个对象的引用。</p><p>​局部变量不会自动地初始化为 null ，必须通过调用 new 对其进行初始化或者将他们设置为 null 。</p><p>​封装的优点：保证该类的内部修改不会影响到其他的代码；尽量提供独立的域访问器和域更改器，保证实例域值不受到外界的破坏，即不提倡直接以成员变量访问实例域值的方式。</p><p>​如果构造器没有显式地给域赋初始值，那么会自动地被赋初始值，这也是域与局部变量的主要不同点，但是一般还是建议对域都进行初始化。</p><p>​如果类中提供了至少一个构造器，但是没有提供无参数的构造器，则在构造对象时如果没有提供参数就会被视为不合法。</p><p>​如果构造器的第一个语句形如 this(…) ，这个构造器将调用同一个类的另一个构造器。采用这种方式使用 this 关键字非常有用，这样对公共的构造器代码部分只编写一次即可。</p><p>​在一个类的声明中，可以包含多个代码块。只要构造类的对象，这些块就会被执行。</p><p>​一个类可以使用所属包中的所有类和其他包中的公有类。</p><p>​类设计技巧：一定要保证数据私有；一定要对数据初始化；不要在类中使用过多的基本类型；不是所有的域都需要独立的域访问器和域更改器（比如创建时间等初始化后无需更改的数据）；将职责过多的类进行分解；类名和方法名要能够体现他们的职责；优先使用不可变的类（保证多线程安全）。</p><h4 id="继承"><a href="# 继承" class="headerlink" title="继承"></a>继承</h4><p>​在 Java 中，所有继承都是公有继承（不同于 C++ 中存在私有继承和保护继承）。</p><p>​在子类中可以增加域、增加方法、覆盖超类的方法，但是不能删除继承的任何域和方法。</p><p>​子类想要访问超类的域一般要借助超类的域访问器，使用关键字 super 。</p><p>​我们可以通过 super 实现对超类构造器的调用，使用 super 调用构造器的语句必须是子类构造器的第一条语句。</p><p>​如果子类的构造器没有显式地调用超类的构造器，则将自动地调用超类默认（没有参数）的构造器。如果超类没有不带参数的构造器，并且在子类的构造器中又没有显式地调用超类的其他构造器，则 Java 编译器将报告错误。</p><p>​一个对象变量（例如，变量 e ）可以指示多种实际类型的现象被称为多态（polymorphism）；在运行时能够自动地选择调用哪个方法的现象称为动态绑定（dynamic binding）。</p><p>​Java 不支持多继承。</p><p>​程序中出现超类对象的任何地方都可以用子类对象置换，例如，可以将一个子类的对象赋值给超类变量，但是反之则是不成立的。</p><p>​包含一个或者多个抽象方法的类必须被声明为抽象类；抽象类中依然可以包含具体数据和具体方法。</p><p>​抽象类不能被实例化，但是可以创建抽象类的对象变量，它只能指向具体子类的对象。</p><p>​Java 规定 equals() 方法具有如下特性：自反性；对称性；传递性；一致性；对于任意非空引用 x，<code>x.equals(null)</code> 返回 false。</p><p>​ArrayList 是一个采用类型参数的泛型类，可以实现动态数组；但是他不能直接使用 [] 访问数组元素，必须借助 set() 和 get() 方法。可以将一个类型化的数组列表传递给一个原始无参数 ArrayList 而不需要任何类型转换；也可以将一个原始无参数 ArrayList 赋值给一个类型化 ArrayList（这样将会得到一个警告）。</p><p>​包装器：Integer、Long、Float、Double、Short、Byte、Character、Void、Boolean，对象包装器是不可变的，一旦构造了包装器，就不允许更改包装在其中的值。</p><p>​继承的设计技巧：将公共操作和域放在超类；使用继承实现“is-a”的关系；除非所有继承的方法都有意义，否则不要使用继承；在覆盖方法时，不要改变预期的行为；使用多态而非类型信息（即不要通过判断对象的类型来确定执行同一概念的不同行为，可以将该行为放置在超类或者接口中，通过多态性提供的动态分派机制执行相应的行为）；不要过多地使用反射。</p><h4 id="接口、内部类"><a href="# 接口、内部类" class="headerlink" title="接口、内部类"></a>接口、内部类</h4><p>​接口决不能含有实例域，但却可以包含常量，可以实现一些简单的方法。</p><p>​Java 中的类可以实现任意数量的接口。</p><p>​实现接口必须实现其中所有的方法。</p><p>​在接口中，所有的方法默认都是 public 的，但是在实现接口中，必须声明方法为 public；接口中的域默认是 public static final 的。</p><p>​可以为接口方法提供一个默认实现，必须用 default 修饰符标记；且默认方法可以调用任何其他方法。</p><p>​为接口增加一个非默认方法不能保证“源代码兼容”，在之前的接口中添加非默认方法可能导致之前实现接口的类编译出错（因为没有实现新加入的方法）。</p><p>​解决默认方法冲突：超类优先；接口冲突。如果一个类继承自一个超类并且实现了一个接口，且超类提供了一个和接口冲突的方法，此时接口的方法（无论是否存在默认方法都将失效，满足类优先原则）；如果一个类实现了两个接口，且两个接口中含有冲突的方法，且一个接口存在默认方法，必须程序员自己实现该方法来覆盖接口的方法（并不是直接选取其中的一个默认实现），如果两个接口冲突的方法都不存在默认方法，则该类本身就是抽象的，不存在方法冲突的问题。</p><p>​lambda 表达式形式：（参数） -&gt; 表达式，表达式可以是代码块并用 return 语句返回，即使没有参数，也不能省略小括号；如果参数类型可以被推导出来，则可以省略参数类型；如果参数只有一个且类型可以被推导出来，则可以省略小括号和类型。</p><p>​无需指定 lambda 表达式的返回值类型，它总是可以根据上下文推导出来的。</p><p>​如果一个 lambda 表达式只在部分分支返回值，而在另一些分支不返回值，这样的表达式是不合法的。</p><p>​对于只有一个抽象方法的接口，需要这种接口的对象时，就可以提供一个 lambda 表达式，这种接口成为函数式接口。</p><p>​lambda 表达式有三个部分：一个代码块；参数；自由变量的值，指的是非参数而且不在代码中定义的量，但是在 lambda 表达式中只能引用值不会改变的变量。</p><p>​内部类既可以访问自身的数据域，也可以访问创建它的外围类对象的数据域。</p><p>​内部类中声明的所有静态域都必须是 final 的；内部类中不允许有 static 方法。</p><h4 id="异常、断言和日志"><a href="# 异常、断言和日志" class="headerlink" title="异常、断言和日志"></a>异常、断言和日志</h4><p>​在 Java 中，异常对象都是派生于 Throwable 类的一个实例。需要注意的是，虽然所有的异常都是由 Throwable 继承而来，但在下一层立即分解为两个分支：Error 和 Exception。</p><p>​Error 类层次结构描述了 Java 运行时系统的内部错误和资源耗尽错误。应用程序不应该抛出这种类型的对象。如果出现了这样的内部错误，除了通告给用户，并尽力使程序安全地终止之外，再也无能为力了。这种情况很少出现。</p><p>​由程序错误导致的异常属于 RuntimeException; 而程序本身没有问题，但由于像 I&#x2F;O 错误这类问题导致的异常属于其他异常。</p><p>​派生于 RuntimeException 的异常包含下面几种情况：<br>​•错误的类型转换。<br>​•数组访问越界 i。<br>​•访问 null 指针。<br>​不是派生于 RuntimeException 的异常包括：<br>​•试图在文件尾部后面读取数据。<br>​•试图打开一个不存在的文件。<br>​•试图根据给定的字符串查找 Class 对象，而这个字符串表示的类并不存在。</p><p>​throws 抛出的是异常类，throw 抛出的是具体异常类实例化的对象。</p><p>​当多个异常捕获处理的逻辑一样时，可以用一个 catch 语句块进行捕获。但是只有当捕获的异常类型彼此之间不存在子类关系时才可以用一个 catch 语句块捕获多个异常，并且捕获多个异常时，异常变量隐含为 final 变量。</p><p>​在 catch 子句中可以抛出一个异常，这样做的目的是改变异常的类型。</p><p>​当 finally 子句包含 return 语句时，将会出现一种意想不到的结果，假设利用 return 语句从 try 语句块中退出。在方法返回前，finally 子句的内容将被执行。如果 finally 子句中也有一个 return 语句，这个返回值将会覆盖原始的返回值。具体来说，就是先执行 try 语句块中的 return 语句，但并不返回，继续执行 finally 语句块中的语句，执行完后再返回。</p><h4 id="泛型程序设计"><a href="# 泛型程序设计" class="headerlink" title="泛型程序设计"></a>泛型程序设计</h4><p>​在 Java SE 7 及以后的版本中， 构造函数中可以省略泛型类型，比如：<code>ArrayList&lt;String&gt; files = new ArrayList&lt;&gt;();</code></p><p>​类型参数的魅力在于：使得程序具有更好的可读性和安全性。</p><p>​泛型类可看作普通类的工厂。</p><p>​泛型方法可以定义在普通类中，也可以定义在泛型类中。当调用一个泛型方法时，在方法名前的尖括号中放人具体的类型。</p><p>​一个类型变量或通配符可以有多个限定， 例如：<code>T extends Comparable &amp; Serializable</code> ，限定类型用“ &amp;” 分隔，而逗号用来分隔类型变量。</p><h4 id="集合"><a href="# 集合" class="headerlink" title="集合"></a>集合</h4><p><img data-src="/images/java_collection.png"></p><p>​当在程序中使用队列时，一旦构建了集合就不需要知道究竟使用了哪种实现。因此，只有在构建集合对象时，使用具体的类才有意义。可以使用接口类型存放集合的引用，比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Queue&lt;Customer&gt; expressLane = <span class="keyword">new</span> <span class="title class_">CircularArrayQueue</span>&lt;&gt;(<span class="number">100</span>) :</span><br><span class="line">expressLane.add(<span class="keyword">new</span> <span class="title class_">Customer</span>(<span class="string">&quot;Harry&quot;</span>));</span><br></pre></td></tr></table></figure><p>利用这种方式，一旦改变了想法，可以轻松地使用另外一种不同的实现。只需要对程序的一个地方做出修改，即调用构造器的地方。如果觉得 LinkedListQueue 是个更好的选择，就将代码修改为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Queue&lt;Customer&gt; expressLane = <span class="keyword">new</span> <span class="title class_">LinkedListQueue</span>&lt;&gt;() ;</span><br><span class="line">expressLane.add(<span class="keyword">new</span> <span class="title class_">Customer</span>(<span class="string">&quot;Harry&quot;</span>));</span><br></pre></td></tr></table></figure><p>​访问集合元素时，需要先使用 hasNext 方法判断集合中是否还有元素，如果有的话再使用 next 方法访问。</p><p>​利用迭代器删除集合元素的时候必须先访问再删除，即 remove 方法的调用依赖于 next 方法，类似的，不能连续调用两次 remove 方法来删除连续的两个集合元素。</p><p>​Iterator 和 ListIterator 之间的主要区别：</p><p>​1、遍历</p><p>​使用 Iterator，可以遍历所有集合，如 Map，List，Set；但只能在向前方向上遍历集合中的元素。</p><p>​使用 ListIterator，只能遍历 List 实现的对象，但可以向前和向后遍历集合中的元素。</p><p>​2、添加元素</p><p>​Iterator 无法向集合中添加元素；而 ListIteror 可以向集合添加元素。</p><p>​3、修改元素</p><p>​Iterator 无法修改集合中的元素；而 ListIterator 可以使用 set()方法修改集合中的元素。set()方法用一个新元素取代调用 next()或 previous()方法返回的上一个元素。</p><p>​4、索引</p><p>​Iterator 无法获取集合中元素的索引；而使用 ListIterator，可以获取集合中元素的索引。</p><p>​ArrayList 和 Vector 的主要区别在于 Vector 类的所有方法都是同步的，而 ArrayList 方法不是同步的。</p><p>​对于散列表，在 Java 中用链表数组实现，每个列表被称作桶。在 JavaSE 8 中，桶满时会从链表变为平衡二叉树。如果选择的散列函数不当，会产生很多冲突，或者如果有恶意代码试图在散列表中填充多个有相同散列码的值，这样就能提高性能。</p><p>​如果大致知道最终会有多少个元素要插人到散列表中，就可以设置桶数。通常，将桶数设置为预计元素个数的 75% ~ 150%。有些研究人员认为：尽管还没有确凿的证据，但最好将桶数设置为一个素数，以防键的集聚。 </p><p>​散列表可以用于实现几个重要的数据结构。其中最简单的是 set 类型，set 是没有重复元素的元素集合。set 的 add 方法首先在集合中查找要添加的对象，如果不存在，就将这个对象添加进去。Java 集合类库提供了一个 HashSet 类，它实现了基于散列表的集合，可以用 add 方法添加元素。contains 方法已经被重新定义，用来快速地查看某个元素是否已经出现在集中，它只在某个桶中査找元素，而不必查看集合中的所有元素。同时，如果元素的散列码发生了改变（一般来说就是值改变），元素在数据结构中的位置也会发生变化。</p><p>​TreeSet 类（当前使用红黑树实现）与散列集十分类似，不过，它比散列集有所改进。树集是一个有序集合(sorted collection) ，可以以任意顺序将元素插入到集合中。在对集合进行遍历时，每个值将自动地按照排序后的顺序呈现。</p><p>​要使用树集，必须能够比较元素。这些元素必须实现 Comparable 接口，或者构造集时必须提供一个 Comparator。为此，并不是树集就优于散列表，虽然表面上看树集比散列表多了有序的性质，但是在一些情况下，元素之间的比较不是那么容易，计算散列值一般都是比较容易的，此时在不要求元素有序的情况下就可以选择使用散列表。</p><p>​队列可以让人们有效地在尾部添加一个元素，在头部删除一个元素。有两个端头的队列，即双端队列，可以让人们有效地在头部和尾部同时添加或删除元素，不支持在队列中间添加元素。在 Java SE 6 中引人了 Deque 接口，并由 ArrayDeque 和 LinkedList 类实现。这两个类都提供了双端队列，而且在必要时可以增加队列的长度。</p><p>​通常，我们知道某些键的信息，并想要查找与之对应的元素。映射（map）就是为此设计的。映射用来存放键 &#x2F; 值对，如果提供了键，就能够查找到值。Java 类库为映射提供了两个通用的实现：HashMap 和 TreeMap，这两个类都实现了 Map 接口。</p><p>​散列映射对键进行散列，树映射用键的整体顺序对元素进行排序，并将其组织成搜索树。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书笔记 </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>语录</title>
      <link href="/2021/12788454a6.html"/>
      <url>/2021/12788454a6.html</url>
      
        <content type="html"><![CDATA[<h2 id="语录"><a href="# 语录" class="headerlink" title="语录"></a> 语录 </h2><p><img data-src="/images/sentence_top_img.jpg"></p><p>​也许吧，因为人要接受事与愿违啊。我们太有限了，我们只能做我们觉得是对的事情，然后接受，它的事与愿违。因为人生所有东西，它都是有负斜率的。在跑的时候，可能慢慢的负斜率，使得偏离了最初的目标，这是人的有限性。所以这就是为什么不要对自己所投入的事情、所看中的事情，抱有不加边际的幻想和热情。</p><p align="right">—— 罗翔 </p><p>  苏格拉底说过：“对于你懂的东西，你才会真正地认同。对于你不懂的东西，你不可能真正地认同。”</p><p align="right">—— 罗翔 </p><p>  人最大的痛苦就是在于无法跨越知道和做到的那个鸿沟。笛卡尔说：“我思故我在”，这个很对，但是，“我思故我在” 会经常让我们沉浸于一种幻想之中，就是我们只要思考到了，我们就能做到。但其实不是这样。</p><p align="right">—— 罗翔 </p><p>  人片刻的感动，不可能持久的感动。很多人所谓的被你影响，只是片刻的感动了，最终还是投入到自己以前的生活。片刻的感动，在很多时候是一种自我欺骗。你在欺骗自己，你也在欺骗别人，你也让别人陷入到一种自我欺骗。</p><p align="right">—— 罗翔 </p><p>  我们画不出一个完美的圆，但完美的圆是存在的。虽不能至，心向往之。</p><p align="right">—— 罗翔 </p><p>  人都是会犯错误的，所以就是永远要接受我们所有的看法都是在偏见之中。我们的一生都是像苏格拉底所说的，走出那个偏见的洞穴。</p><p align="right">—— 罗翔 </p><p>  人这一生自己能决定的也许只有 5%，有 95% 是你决定不了的，你的努力也许只是那 5% 的一个支点，撬动了那 95% 的命运。但是你不要把所有的功劳归给你自己，你飞得越高，你要注意有根线是拉着你的，像气球一样，如果你说我太厉害了，我没有必要受这个线的约束，最后你会爆炸的。因此你要感恩你生命中所拥有的一切。</p><p align="right">—— 罗翔 </p><p>  奥古斯丁在《忏悔录》中说过这样一段话：“当你问我时间是什么，如果你不问我，我感觉自己还知道，你一旦问我，我就茫然无知了。” 昨天的已经成为过去，明天的还没有到来，所以今天是一个礼物，大家把今天当作一个礼物，去珍惜享受你现在拥有的平凡的幸福。因为这种幸福现在你觉得平凡，但到你失去那一天，你会觉得它是如此的珍贵。</p><p align="right">—— 罗翔 </p><p>  世界即不黑也不白，而是一道精致的灰。（The world is not black or white, but a delicious shade of grey.）</p><p align="right">—— 英雄联盟卡密尔台词 </p><p>  人在少年的时候，大多会经历一场情不知所起一往而深的感情，或者是因为他成绩好，或者是他擅长打篮球，或者是言行有趣，或者是长得好看。总之就是某个不经意的刹那，怦然心动。但大多数时候，它来得突然，却也无疾而终，在某年某月，等你再回首的时候，想起自己曾经的一往情深，不免哑然失笑。那些曾经我们看来很美好的事物，也会随着时间的流逝，而变得无关紧要。对于很多人来说终其一生会遇到很多人，但可能要倾尽所有的运气，才会遇见到特别的那一个。</p><p align="right">——b 站 up 主阿斗归来了讲解电影《怦然心动》</p>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书 </tag>
            
            <tag> 语录 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2021/124a17b156.html"/>
      <url>/2021/124a17b156.html</url>
      
        <content type="html"><![CDATA[<p>Welcome to <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlvLw==">Hexo<i class="fa fa-external-link-alt"></i></span>! This is your very first post. Check <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlvL2RvY3Mv">documentation<i class="fa fa-external-link-alt"></i></span> for more info. If you get any problems when using Hexo, you can find the answer in <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlvL2RvY3MvdHJvdWJsZXNob290aW5nLmh0bWw=">troubleshooting<i class="fa fa-external-link-alt"></i></span> or you can ask me on <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2hleG9qcy9oZXhvL2lzc3Vlcw==">GitHub<i class="fa fa-external-link-alt"></i></span>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlvL2RvY3Mvd3JpdGluZy5odG1s">Writing<i class="fa fa-external-link-alt"></i></span></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlvL2RvY3Mvc2VydmVyLmh0bWw=">Server<i class="fa fa-external-link-alt"></i></span></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlvL2RvY3MvZ2VuZXJhdGluZy5odG1s">Generating<i class="fa fa-external-link-alt"></i></span></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlvL2RvY3Mvb25lLWNvbW1hbmQtZGVwbG95bWVudC5odG1s">Deployment<i class="fa fa-external-link-alt"></i></span></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
